// Copyright 2014 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package mongo_test

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/juju/clock"
	"github.com/juju/clock/testclock"
	"github.com/juju/errors"
	"github.com/juju/testing"
	jc "github.com/juju/testing/checkers"
	gc "gopkg.in/check.v1"

	"github.com/juju/juju/v3/core/network"
	"github.com/juju/juju/v3/mongo"
	"github.com/juju/juju/v3/mongo/mongotest"
	"github.com/juju/juju/v3/packaging"
	"github.com/juju/juju/v3/service/common"
	"github.com/juju/juju/v3/service/snap"
	coretesting "github.com/juju/juju/v3/testing"
)

type MongoSuite struct {
	coretesting.BaseSuite

	clock            clock.Clock
	mongodConfigPath string

	mongoSnapService *mongotest.MockMongoSnapService
}

var _ = gc.Suite(&MongoSuite{})

var testInfo = struct {
	StatePort    int
	Cert         string
	PrivateKey   string
	SharedSecret string
}{
	StatePort:    25252,
	Cert:         "foobar-cert",
	PrivateKey:   "foobar-privkey",
	SharedSecret: "foobar-sharedsecret",
}

func makeEnsureServerParams(dataDir, configDir string) mongo.EnsureServerParams {
	return mongo.EnsureServerParams{
		StatePort:    testInfo.StatePort,
		Cert:         testInfo.Cert,
		PrivateKey:   testInfo.PrivateKey,
		SharedSecret: testInfo.SharedSecret,

		DataDir:           dataDir,
		ConfigDir:         configDir,
		JujuDBSnapChannel: "latest",

		OplogSize: 1,
	}
}

func (s *MongoSuite) SetUpTest(c *gc.C) {
	s.BaseSuite.SetUpTest(c)

	testing.PatchExecutable(c, s, "juju-db.mongod", "#!/bin/bash\n\nprintf %s 'db version v6.6.6'\n")
	jujuMongodPath, err := exec.LookPath("juju-db.mongod")
	c.Assert(err, jc.ErrorIsNil)
	s.PatchValue(&mongo.JujuDbSnapMongodPath, jujuMongodPath)

	// Patch "df" such that it always reports there's 1MB free.
	s.PatchValue(mongo.AvailSpace, func(dir string) (float64, error) {
		info, err := os.Stat(dir)
		if err != nil {
			return 0, err
		}
		if info.IsDir() {
			return 1, nil

		}
		return 0, fmt.Errorf("not a directory")
	})
	s.PatchValue(mongo.SmallOplogSizeMB, 1)

	s.clock = testclock.NewClock(time.Now())
}

func (s *MongoSuite) setupMocks(c *gc.C) *gomock.Controller {
	ctrl := gomock.NewController(c)

	s.mongoSnapService = mongotest.NewMockMongoSnapService(ctrl)

	return ctrl
}

func (s *MongoSuite) expectNoLegacyMongo() {
	s.PatchValue(mongo.FindLegacyMongo, func(search mongo.SearchTools) (string, mongo.Version, error) {
		return "", mongo.Version{}, errors.NotFoundf("a version of mongo")
	})
}

func (s *MongoSuite) expectMongoSnapInstalled() {
	mExp := s.mongoSnapService.EXPECT()
	mExp.Installed().Return(true, nil)
	mExp.Running().Return(true, nil)

	s.PatchValue(mongo.NewSnapService, func(mainSnap, serviceName string, conf common.Conf, snapPath, configDir, channel string, confinementPolicy snap.ConfinementPolicy, backgroundServices []snap.BackgroundService, prerequisites []snap.Installable) (mongo.MongoSnapService, error) {
		return s.mongoSnapService, nil
	})
}

func (s *MongoSuite) expectInstallMongoSnap() {
	mExp := s.mongoSnapService.EXPECT()
	mExp.Installed().Return(false, nil)
	mExp.Name().Return("not-juju-db")
	mExp.Install().Return(nil)
	mExp.ConfigOverride().Return(nil)
	mExp.Stop().Return(nil)
	mExp.Start().Return(nil)

	s.PatchValue(mongo.NewSnapService, func(mainSnap, serviceName string, conf common.Conf, snapPath, configDir, channel string, confinementPolicy snap.ConfinementPolicy, backgroundServices []snap.BackgroundService, prerequisites []snap.Installable) (mongo.MongoSnapService, error) {
		return s.mongoSnapService, nil
	})
}

func (s *MongoSuite) assertTLSKeyFile(c *gc.C, dataDir string) {
	contents, err := ioutil.ReadFile(mongo.SSLKeyPath(dataDir))
	c.Assert(err, jc.ErrorIsNil)
	c.Assert(string(contents), gc.Equals, testInfo.Cert+"\n"+testInfo.PrivateKey)
}

func (s *MongoSuite) assertSharedSecretFile(c *gc.C, dataDir string) {
	contents, err := ioutil.ReadFile(mongo.SharedSecretPath(dataDir))
	c.Assert(err, jc.ErrorIsNil)
	c.Assert(string(contents), gc.Equals, testInfo.SharedSecret)
}

func (s *MongoSuite) assertMongoConfigFile(c *gc.C, dataDir string, ipV6 bool) {
	contents, err := ioutil.ReadFile(s.mongodConfigPath)
	c.Assert(err, jc.ErrorIsNil)
	part1 := fmt.Sprintf(`
# WARNING
# autogenerated by juju on %s
# manual changes to this file are likely be overwritten
auth = true
bind_ip_all = true
dbpath = %s/db`[1:], s.clock.Now().UTC().Format(time.RFC822), dataDir)
	if ipV6 {
		part1 += "\nipv6 = true"
	}

	part2 := fmt.Sprintf(`
journal = true
keyFile = %s/shared-secret
logappend = true
logpath = %s/logs/mongodb.log
oplogSize = 1
port = 25252
quiet = true
replSet = juju
storageEngine = wiredTiger
tlsCertificateKeyFile = %s/server.pem
tlsCertificateKeyFilePassword=ignored
tlsMode = requireTLS`, dataDir, dataDir, dataDir)

	c.Assert(string(contents), jc.DeepEquals, part1+part2)
}

func (s *MongoSuite) TestEnsureServer(c *gc.C) {
	defer s.setupMocks(c).Finish()
	s.expectNoLegacyMongo()
	s.expectInstallMongoSnap()

	dataDir := s.assertEnsureServerIPv6(c, true)

	s.assertTLSKeyFile(c, dataDir)
	s.assertSharedSecretFile(c, dataDir)
	s.assertMongoConfigFile(c, dataDir, true)

	// make sure that we log the version of mongodb as we get ready to
	// start it
	tlog := c.GetTestLog()
	any := `(.|\n)*`
	start := "^" + any
	tail := any + "$"
	c.Assert(tlog, gc.Matches, start+`using mongod: .*mongod --version:\sdb version v\d\.\d\.\d`+tail)
}

func (s *MongoSuite) TestEnsureServerServerExistsAndRunning(c *gc.C) {
	defer s.setupMocks(c).Finish()
	s.expectNoLegacyMongo()
	s.expectMongoSnapInstalled()

	_ = s.assertEnsureServerIPv6(c, true)
}

func (s *MongoSuite) TestEnsureServerNoIPv6(c *gc.C) {
	defer s.setupMocks(c).Finish()
	s.expectNoLegacyMongo()
	dataDir := s.assertEnsureServerIPv6(c, false)

	s.assertTLSKeyFile(c, dataDir)
	s.assertSharedSecretFile(c, dataDir)
	s.assertMongoConfigFile(c, dataDir, false)
}

func (s *MongoSuite) TestEnsureServerSetsSysctlValues(c *gc.C) {
	defer s.setupMocks(c).Finish()
	s.expectNoLegacyMongo()
	dataDir := c.MkDir()
	dataFilePath := filepath.Join(dataDir, "mongoKernelTweaks")
	dataFile, err := os.Create(dataFilePath)
	c.Assert(err, jc.ErrorIsNil)
	_, err = dataFile.WriteString("original value")
	c.Assert(err, jc.ErrorIsNil)
	_ = dataFile.Close()

	testing.PatchExecutableAsEchoArgs(c, s, "snap")

	contents, err := ioutil.ReadFile(dataFilePath)
	c.Assert(err, jc.ErrorIsNil)
	c.Assert(string(contents), gc.Equals, "original value")

	configDir := c.MkDir()
	err = mongo.SysctlEditableEnsureServer(makeEnsureServerParams(dataDir, configDir),
		map[string]string{dataFilePath: "new value"})
	c.Assert(err, jc.ErrorIsNil)

	contents, err = ioutil.ReadFile(dataFilePath)
	c.Assert(err, jc.ErrorIsNil)
	c.Assert(string(contents), gc.Equals, "new value")
}

func (s *MongoSuite) TestEnsureServerError(c *gc.C) {
	defer s.setupMocks(c).Finish()
	s.expectNoLegacyMongo()
	dataDir := c.MkDir()
	configDir := c.MkDir()

	testing.PatchExecutableAsEchoArgs(c, s, "snap")

	failure := errors.New("boom")
	s.PatchValue(mongo.InstallMongo, func(dep packaging.Dependency, series string) error {
		return failure
	})
	err := mongo.EnsureServer(makeEnsureServerParams(dataDir, configDir))
	c.Assert(errors.Cause(err), gc.Equals, failure)
}

func (s *MongoSuite) assertEnsureServerIPv6(c *gc.C, ipv6 bool) string {
	dataDir := c.MkDir()
	configDir := c.MkDir()
	s.mongodConfigPath = filepath.Join(dataDir, "juju-db.config")

	testing.PatchExecutableAsEchoArgs(c, s, "snap")

	s.PatchValue(mongo.SupportsIPv6, func() bool {
		return ipv6
	})
	testParams := makeEnsureServerParams(dataDir, configDir)
	err := mongo.EnsureServer(testParams)
	c.Assert(err, jc.ErrorIsNil)
	return dataDir
}

func (s *MongoSuite) TestNoMongoDir(c *gc.C) {
	// Make a non-existent directory that can nonetheless be
	// created.
	testing.PatchExecutableAsEchoArgs(c, s, "snap")

	dataDir := filepath.Join(c.MkDir(), "dir", "data")
	configDir := c.MkDir()
	err := mongo.EnsureServer(makeEnsureServerParams(dataDir, configDir))
	c.Check(err, jc.ErrorIsNil)

	_, err = os.Stat(filepath.Join(dataDir, "db"))
	c.Assert(err, jc.ErrorIsNil)
}

func (s *MongoSuite) TestSelectPeerAddress(c *gc.C) {
	addresses := network.ProviderAddresses{
		network.NewMachineAddress("126.0.0.1", network.WithScope(network.ScopeMachineLocal)).AsProviderAddress(),
		network.NewMachineAddress("10.0.0.1", network.WithScope(network.ScopeCloudLocal)).AsProviderAddress(),
		network.NewMachineAddress("8.8.8.8", network.WithScope(network.ScopePublic)).AsProviderAddress(),
	}

	address := mongo.SelectPeerAddress(addresses)
	c.Assert(address, gc.Equals, "10.0.0.1")
}

func (s *MongoSuite) TestGenerateSharedSecret(c *gc.C) {
	secret, err := mongo.GenerateSharedSecret()
	c.Assert(err, jc.ErrorIsNil)
	c.Assert(secret, gc.HasLen, 1024)
	_, err = base64.StdEncoding.DecodeString(secret)
	c.Assert(err, jc.ErrorIsNil)
}

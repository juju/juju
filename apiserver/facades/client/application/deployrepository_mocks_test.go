// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/apiserver/facades/client/application (interfaces: Bindings,DeployFromRepositoryState,DeployFromRepositoryValidator,Model,Machine,Application,Charm)
//
// Generated by this command:
//
//	mockgen -typed -package application -destination deployrepository_mocks_test.go github.com/juju/juju/apiserver/facades/client/application Bindings,DeployFromRepositoryState,DeployFromRepositoryValidator,Model,Machine,Application,Charm
//

// Package application is a generated GoMock package.
package application

import (
	context "context"
	reflect "reflect"

	config "github.com/juju/juju/core/config"
	constraints "github.com/juju/juju/core/constraints"
	instance "github.com/juju/juju/core/instance"
	network "github.com/juju/juju/core/network"
	objectstore "github.com/juju/juju/core/objectstore"
	charm "github.com/juju/juju/internal/charm"
	resource "github.com/juju/juju/internal/charm/resource"
	services "github.com/juju/juju/internal/charm/services"
	tools "github.com/juju/juju/internal/tools"
	params "github.com/juju/juju/rpc/params"
	state "github.com/juju/juju/state"
	names "github.com/juju/names/v5"
	schema "github.com/juju/schema"
	gomock "go.uber.org/mock/gomock"
	environschema "gopkg.in/juju/environschema.v1"
)

// MockBindings is a mock of Bindings interface.
type MockBindings struct {
	ctrl     *gomock.Controller
	recorder *MockBindingsMockRecorder
}

// MockBindingsMockRecorder is the mock recorder for MockBindings.
type MockBindingsMockRecorder struct {
	mock *MockBindings
}

// NewMockBindings creates a new mock instance.
func NewMockBindings(ctrl *gomock.Controller) *MockBindings {
	mock := &MockBindings{ctrl: ctrl}
	mock.recorder = &MockBindingsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBindings) EXPECT() *MockBindingsMockRecorder {
	return m.recorder
}

// Map mocks base method.
func (m *MockBindings) Map() map[string]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Map")
	ret0, _ := ret[0].(map[string]string)
	return ret0
}

// Map indicates an expected call of Map.
func (mr *MockBindingsMockRecorder) Map() *MockBindingsMapCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Map", reflect.TypeOf((*MockBindings)(nil).Map))
	return &MockBindingsMapCall{Call: call}
}

// MockBindingsMapCall wrap *gomock.Call
type MockBindingsMapCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBindingsMapCall) Return(arg0 map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBindingsMapCall) Do(f func() map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBindingsMapCall) DoAndReturn(f func() map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MapWithSpaceNames mocks base method.
func (m *MockBindings) MapWithSpaceNames(arg0 network.SpaceInfos) (map[string]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapWithSpaceNames", arg0)
	ret0, _ := ret[0].(map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MapWithSpaceNames indicates an expected call of MapWithSpaceNames.
func (mr *MockBindingsMockRecorder) MapWithSpaceNames(arg0 any) *MockBindingsMapWithSpaceNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapWithSpaceNames", reflect.TypeOf((*MockBindings)(nil).MapWithSpaceNames), arg0)
	return &MockBindingsMapWithSpaceNamesCall{Call: call}
}

// MockBindingsMapWithSpaceNamesCall wrap *gomock.Call
type MockBindingsMapWithSpaceNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBindingsMapWithSpaceNamesCall) Return(arg0 map[string]string, arg1 error) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBindingsMapWithSpaceNamesCall) Do(f func(network.SpaceInfos) (map[string]string, error)) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBindingsMapWithSpaceNamesCall) DoAndReturn(f func(network.SpaceInfos) (map[string]string, error)) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDeployFromRepositoryState is a mock of DeployFromRepositoryState interface.
type MockDeployFromRepositoryState struct {
	ctrl     *gomock.Controller
	recorder *MockDeployFromRepositoryStateMockRecorder
}

// MockDeployFromRepositoryStateMockRecorder is the mock recorder for MockDeployFromRepositoryState.
type MockDeployFromRepositoryStateMockRecorder struct {
	mock *MockDeployFromRepositoryState
}

// NewMockDeployFromRepositoryState creates a new mock instance.
func NewMockDeployFromRepositoryState(ctrl *gomock.Controller) *MockDeployFromRepositoryState {
	mock := &MockDeployFromRepositoryState{ctrl: ctrl}
	mock.recorder = &MockDeployFromRepositoryStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployFromRepositoryState) EXPECT() *MockDeployFromRepositoryStateMockRecorder {
	return m.recorder
}

// AddApplication mocks base method.
func (m *MockDeployFromRepositoryState) AddApplication(arg0 state.AddApplicationArgs, arg1 objectstore.ObjectStore) (Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddApplication", arg0, arg1)
	ret0, _ := ret[0].(Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddApplication indicates an expected call of AddApplication.
func (mr *MockDeployFromRepositoryStateMockRecorder) AddApplication(arg0, arg1 any) *MockDeployFromRepositoryStateAddApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddApplication", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).AddApplication), arg0, arg1)
	return &MockDeployFromRepositoryStateAddApplicationCall{Call: call}
}

// MockDeployFromRepositoryStateAddApplicationCall wrap *gomock.Call
type MockDeployFromRepositoryStateAddApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateAddApplicationCall) Return(arg0 Application, arg1 error) *MockDeployFromRepositoryStateAddApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateAddApplicationCall) Do(f func(state.AddApplicationArgs, objectstore.ObjectStore) (Application, error)) *MockDeployFromRepositoryStateAddApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateAddApplicationCall) DoAndReturn(f func(state.AddApplicationArgs, objectstore.ObjectStore) (Application, error)) *MockDeployFromRepositoryStateAddApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddCharmMetadata mocks base method.
func (m *MockDeployFromRepositoryState) AddCharmMetadata(arg0 state.CharmInfo) (Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCharmMetadata", arg0)
	ret0, _ := ret[0].(Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCharmMetadata indicates an expected call of AddCharmMetadata.
func (mr *MockDeployFromRepositoryStateMockRecorder) AddCharmMetadata(arg0 any) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCharmMetadata", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).AddCharmMetadata), arg0)
	return &MockDeployFromRepositoryStateAddCharmMetadataCall{Call: call}
}

// MockDeployFromRepositoryStateAddCharmMetadataCall wrap *gomock.Call
type MockDeployFromRepositoryStateAddCharmMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateAddCharmMetadataCall) Return(arg0 Charm, arg1 error) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateAddCharmMetadataCall) Do(f func(state.CharmInfo) (Charm, error)) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateAddCharmMetadataCall) DoAndReturn(f func(state.CharmInfo) (Charm, error)) *MockDeployFromRepositoryStateAddCharmMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPendingResource mocks base method.
func (m *MockDeployFromRepositoryState) AddPendingResource(arg0 string, arg1 resource.Resource, arg2 objectstore.ObjectStore) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPendingResource", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddPendingResource indicates an expected call of AddPendingResource.
func (mr *MockDeployFromRepositoryStateMockRecorder) AddPendingResource(arg0, arg1, arg2 any) *MockDeployFromRepositoryStateAddPendingResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPendingResource", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).AddPendingResource), arg0, arg1, arg2)
	return &MockDeployFromRepositoryStateAddPendingResourceCall{Call: call}
}

// MockDeployFromRepositoryStateAddPendingResourceCall wrap *gomock.Call
type MockDeployFromRepositoryStateAddPendingResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateAddPendingResourceCall) Return(arg0 string, arg1 error) *MockDeployFromRepositoryStateAddPendingResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateAddPendingResourceCall) Do(f func(string, resource.Resource, objectstore.ObjectStore) (string, error)) *MockDeployFromRepositoryStateAddPendingResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateAddPendingResourceCall) DoAndReturn(f func(string, resource.Resource, objectstore.ObjectStore) (string, error)) *MockDeployFromRepositoryStateAddPendingResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Charm mocks base method.
func (m *MockDeployFromRepositoryState) Charm(arg0 string) (Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm", arg0)
	ret0, _ := ret[0].(Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Charm indicates an expected call of Charm.
func (mr *MockDeployFromRepositoryStateMockRecorder) Charm(arg0 any) *MockDeployFromRepositoryStateCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).Charm), arg0)
	return &MockDeployFromRepositoryStateCharmCall{Call: call}
}

// MockDeployFromRepositoryStateCharmCall wrap *gomock.Call
type MockDeployFromRepositoryStateCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateCharmCall) Return(arg0 Charm, arg1 error) *MockDeployFromRepositoryStateCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateCharmCall) Do(f func(string) (Charm, error)) *MockDeployFromRepositoryStateCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateCharmCall) DoAndReturn(f func(string) (Charm, error)) *MockDeployFromRepositoryStateCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Machine mocks base method.
func (m *MockDeployFromRepositoryState) Machine(arg0 string) (Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Machine", arg0)
	ret0, _ := ret[0].(Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Machine indicates an expected call of Machine.
func (mr *MockDeployFromRepositoryStateMockRecorder) Machine(arg0 any) *MockDeployFromRepositoryStateMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Machine", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).Machine), arg0)
	return &MockDeployFromRepositoryStateMachineCall{Call: call}
}

// MockDeployFromRepositoryStateMachineCall wrap *gomock.Call
type MockDeployFromRepositoryStateMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateMachineCall) Return(arg0 Machine, arg1 error) *MockDeployFromRepositoryStateMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateMachineCall) Do(f func(string) (Machine, error)) *MockDeployFromRepositoryStateMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateMachineCall) DoAndReturn(f func(string) (Machine, error)) *MockDeployFromRepositoryStateMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelConstraints mocks base method.
func (m *MockDeployFromRepositoryState) ModelConstraints() (constraints.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelConstraints")
	ret0, _ := ret[0].(constraints.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelConstraints indicates an expected call of ModelConstraints.
func (mr *MockDeployFromRepositoryStateMockRecorder) ModelConstraints() *MockDeployFromRepositoryStateModelConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelConstraints", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).ModelConstraints))
	return &MockDeployFromRepositoryStateModelConstraintsCall{Call: call}
}

// MockDeployFromRepositoryStateModelConstraintsCall wrap *gomock.Call
type MockDeployFromRepositoryStateModelConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateModelConstraintsCall) Return(arg0 constraints.Value, arg1 error) *MockDeployFromRepositoryStateModelConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateModelConstraintsCall) Do(f func() (constraints.Value, error)) *MockDeployFromRepositoryStateModelConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateModelConstraintsCall) DoAndReturn(f func() (constraints.Value, error)) *MockDeployFromRepositoryStateModelConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelUUID mocks base method.
func (m *MockDeployFromRepositoryState) ModelUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ModelUUID indicates an expected call of ModelUUID.
func (mr *MockDeployFromRepositoryStateMockRecorder) ModelUUID() *MockDeployFromRepositoryStateModelUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelUUID", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).ModelUUID))
	return &MockDeployFromRepositoryStateModelUUIDCall{Call: call}
}

// MockDeployFromRepositoryStateModelUUIDCall wrap *gomock.Call
type MockDeployFromRepositoryStateModelUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateModelUUIDCall) Return(arg0 string) *MockDeployFromRepositoryStateModelUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateModelUUIDCall) Do(f func() string) *MockDeployFromRepositoryStateModelUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateModelUUIDCall) DoAndReturn(f func() string) *MockDeployFromRepositoryStateModelUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareCharmUpload mocks base method.
func (m *MockDeployFromRepositoryState) PrepareCharmUpload(arg0 string) (services.UploadedCharm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareCharmUpload", arg0)
	ret0, _ := ret[0].(services.UploadedCharm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareCharmUpload indicates an expected call of PrepareCharmUpload.
func (mr *MockDeployFromRepositoryStateMockRecorder) PrepareCharmUpload(arg0 any) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareCharmUpload", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).PrepareCharmUpload), arg0)
	return &MockDeployFromRepositoryStatePrepareCharmUploadCall{Call: call}
}

// MockDeployFromRepositoryStatePrepareCharmUploadCall wrap *gomock.Call
type MockDeployFromRepositoryStatePrepareCharmUploadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStatePrepareCharmUploadCall) Return(arg0 services.UploadedCharm, arg1 error) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStatePrepareCharmUploadCall) Do(f func(string) (services.UploadedCharm, error)) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStatePrepareCharmUploadCall) DoAndReturn(f func(string) (services.UploadedCharm, error)) *MockDeployFromRepositoryStatePrepareCharmUploadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadSequence mocks base method.
func (m *MockDeployFromRepositoryState) ReadSequence(arg0 string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadSequence", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadSequence indicates an expected call of ReadSequence.
func (mr *MockDeployFromRepositoryStateMockRecorder) ReadSequence(arg0 any) *MockDeployFromRepositoryStateReadSequenceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadSequence", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).ReadSequence), arg0)
	return &MockDeployFromRepositoryStateReadSequenceCall{Call: call}
}

// MockDeployFromRepositoryStateReadSequenceCall wrap *gomock.Call
type MockDeployFromRepositoryStateReadSequenceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateReadSequenceCall) Return(arg0 int, arg1 error) *MockDeployFromRepositoryStateReadSequenceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateReadSequenceCall) Do(f func(string) (int, error)) *MockDeployFromRepositoryStateReadSequenceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateReadSequenceCall) DoAndReturn(f func(string) (int, error)) *MockDeployFromRepositoryStateReadSequenceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemovePendingResources mocks base method.
func (m *MockDeployFromRepositoryState) RemovePendingResources(arg0 string, arg1 map[string]string, arg2 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemovePendingResources", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemovePendingResources indicates an expected call of RemovePendingResources.
func (mr *MockDeployFromRepositoryStateMockRecorder) RemovePendingResources(arg0, arg1, arg2 any) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePendingResources", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).RemovePendingResources), arg0, arg1, arg2)
	return &MockDeployFromRepositoryStateRemovePendingResourcesCall{Call: call}
}

// MockDeployFromRepositoryStateRemovePendingResourcesCall wrap *gomock.Call
type MockDeployFromRepositoryStateRemovePendingResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateRemovePendingResourcesCall) Return(arg0 error) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateRemovePendingResourcesCall) Do(f func(string, map[string]string, objectstore.ObjectStore) error) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateRemovePendingResourcesCall) DoAndReturn(f func(string, map[string]string, objectstore.ObjectStore) error) *MockDeployFromRepositoryStateRemovePendingResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateUploadedCharm mocks base method.
func (m *MockDeployFromRepositoryState) UpdateUploadedCharm(arg0 state.CharmInfo) (services.UploadedCharm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUploadedCharm", arg0)
	ret0, _ := ret[0].(services.UploadedCharm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateUploadedCharm indicates an expected call of UpdateUploadedCharm.
func (mr *MockDeployFromRepositoryStateMockRecorder) UpdateUploadedCharm(arg0 any) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUploadedCharm", reflect.TypeOf((*MockDeployFromRepositoryState)(nil).UpdateUploadedCharm), arg0)
	return &MockDeployFromRepositoryStateUpdateUploadedCharmCall{Call: call}
}

// MockDeployFromRepositoryStateUpdateUploadedCharmCall wrap *gomock.Call
type MockDeployFromRepositoryStateUpdateUploadedCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryStateUpdateUploadedCharmCall) Return(arg0 services.UploadedCharm, arg1 error) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryStateUpdateUploadedCharmCall) Do(f func(state.CharmInfo) (services.UploadedCharm, error)) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryStateUpdateUploadedCharmCall) DoAndReturn(f func(state.CharmInfo) (services.UploadedCharm, error)) *MockDeployFromRepositoryStateUpdateUploadedCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDeployFromRepositoryValidator is a mock of DeployFromRepositoryValidator interface.
type MockDeployFromRepositoryValidator struct {
	ctrl     *gomock.Controller
	recorder *MockDeployFromRepositoryValidatorMockRecorder
}

// MockDeployFromRepositoryValidatorMockRecorder is the mock recorder for MockDeployFromRepositoryValidator.
type MockDeployFromRepositoryValidatorMockRecorder struct {
	mock *MockDeployFromRepositoryValidator
}

// NewMockDeployFromRepositoryValidator creates a new mock instance.
func NewMockDeployFromRepositoryValidator(ctrl *gomock.Controller) *MockDeployFromRepositoryValidator {
	mock := &MockDeployFromRepositoryValidator{ctrl: ctrl}
	mock.recorder = &MockDeployFromRepositoryValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeployFromRepositoryValidator) EXPECT() *MockDeployFromRepositoryValidatorMockRecorder {
	return m.recorder
}

// ValidateArg mocks base method.
func (m *MockDeployFromRepositoryValidator) ValidateArg(arg0 context.Context, arg1 params.DeployFromRepositoryArg) (deployTemplate, []error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateArg", arg0, arg1)
	ret0, _ := ret[0].(deployTemplate)
	ret1, _ := ret[1].([]error)
	return ret0, ret1
}

// ValidateArg indicates an expected call of ValidateArg.
func (mr *MockDeployFromRepositoryValidatorMockRecorder) ValidateArg(arg0, arg1 any) *MockDeployFromRepositoryValidatorValidateArgCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateArg", reflect.TypeOf((*MockDeployFromRepositoryValidator)(nil).ValidateArg), arg0, arg1)
	return &MockDeployFromRepositoryValidatorValidateArgCall{Call: call}
}

// MockDeployFromRepositoryValidatorValidateArgCall wrap *gomock.Call
type MockDeployFromRepositoryValidatorValidateArgCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeployFromRepositoryValidatorValidateArgCall) Return(arg0 deployTemplate, arg1 []error) *MockDeployFromRepositoryValidatorValidateArgCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeployFromRepositoryValidatorValidateArgCall) Do(f func(context.Context, params.DeployFromRepositoryArg) (deployTemplate, []error)) *MockDeployFromRepositoryValidatorValidateArgCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeployFromRepositoryValidatorValidateArgCall) DoAndReturn(f func(context.Context, params.DeployFromRepositoryArg) (deployTemplate, []error)) *MockDeployFromRepositoryValidatorValidateArgCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockModel is a mock of Model interface.
type MockModel struct {
	ctrl     *gomock.Controller
	recorder *MockModelMockRecorder
}

// MockModelMockRecorder is the mock recorder for MockModel.
type MockModelMockRecorder struct {
	mock *MockModel
}

// NewMockModel creates a new mock instance.
func NewMockModel(ctrl *gomock.Controller) *MockModel {
	mock := &MockModel{ctrl: ctrl}
	mock.recorder = &MockModelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModel) EXPECT() *MockModelMockRecorder {
	return m.recorder
}

// CloudCredentialTag mocks base method.
func (m *MockModel) CloudCredentialTag() (names.CloudCredentialTag, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudCredentialTag")
	ret0, _ := ret[0].(names.CloudCredentialTag)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CloudCredentialTag indicates an expected call of CloudCredentialTag.
func (mr *MockModelMockRecorder) CloudCredentialTag() *MockModelCloudCredentialTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudCredentialTag", reflect.TypeOf((*MockModel)(nil).CloudCredentialTag))
	return &MockModelCloudCredentialTagCall{Call: call}
}

// MockModelCloudCredentialTagCall wrap *gomock.Call
type MockModelCloudCredentialTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudCredentialTagCall) Return(arg0 names.CloudCredentialTag, arg1 bool) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudCredentialTagCall) Do(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudCredentialTagCall) DoAndReturn(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudName mocks base method.
func (m *MockModel) CloudName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudName")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudName indicates an expected call of CloudName.
func (mr *MockModelMockRecorder) CloudName() *MockModelCloudNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudName", reflect.TypeOf((*MockModel)(nil).CloudName))
	return &MockModelCloudNameCall{Call: call}
}

// MockModelCloudNameCall wrap *gomock.Call
type MockModelCloudNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudNameCall) Return(arg0 string) *MockModelCloudNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudNameCall) Do(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudNameCall) DoAndReturn(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudRegion mocks base method.
func (m *MockModel) CloudRegion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudRegion")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudRegion indicates an expected call of CloudRegion.
func (mr *MockModelMockRecorder) CloudRegion() *MockModelCloudRegionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudRegion", reflect.TypeOf((*MockModel)(nil).CloudRegion))
	return &MockModelCloudRegionCall{Call: call}
}

// MockModelCloudRegionCall wrap *gomock.Call
type MockModelCloudRegionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudRegionCall) Return(arg0 string) *MockModelCloudRegionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudRegionCall) Do(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudRegionCall) DoAndReturn(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ControllerUUID mocks base method.
func (m *MockModel) ControllerUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ControllerUUID indicates an expected call of ControllerUUID.
func (mr *MockModelMockRecorder) ControllerUUID() *MockModelControllerUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerUUID", reflect.TypeOf((*MockModel)(nil).ControllerUUID))
	return &MockModelControllerUUIDCall{Call: call}
}

// MockModelControllerUUIDCall wrap *gomock.Call
type MockModelControllerUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelControllerUUIDCall) Return(arg0 string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelControllerUUIDCall) Do(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelControllerUUIDCall) DoAndReturn(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelTag mocks base method.
func (m *MockModel) ModelTag() names.ModelTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelTag")
	ret0, _ := ret[0].(names.ModelTag)
	return ret0
}

// ModelTag indicates an expected call of ModelTag.
func (mr *MockModelMockRecorder) ModelTag() *MockModelModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelTag", reflect.TypeOf((*MockModel)(nil).ModelTag))
	return &MockModelModelTagCall{Call: call}
}

// MockModelModelTagCall wrap *gomock.Call
type MockModelModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelTagCall) Return(arg0 names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelTagCall) Do(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelTagCall) DoAndReturn(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenedPortRangesForMachine mocks base method.
func (m *MockModel) OpenedPortRangesForMachine(arg0 string) (state.MachinePortRanges, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenedPortRangesForMachine", arg0)
	ret0, _ := ret[0].(state.MachinePortRanges)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenedPortRangesForMachine indicates an expected call of OpenedPortRangesForMachine.
func (mr *MockModelMockRecorder) OpenedPortRangesForMachine(arg0 any) *MockModelOpenedPortRangesForMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenedPortRangesForMachine", reflect.TypeOf((*MockModel)(nil).OpenedPortRangesForMachine), arg0)
	return &MockModelOpenedPortRangesForMachineCall{Call: call}
}

// MockModelOpenedPortRangesForMachineCall wrap *gomock.Call
type MockModelOpenedPortRangesForMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelOpenedPortRangesForMachineCall) Return(arg0 state.MachinePortRanges, arg1 error) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelOpenedPortRangesForMachineCall) Do(f func(string) (state.MachinePortRanges, error)) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelOpenedPortRangesForMachineCall) DoAndReturn(f func(string) (state.MachinePortRanges, error)) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockModel) Type() state.ModelType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(state.ModelType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockModelMockRecorder) Type() *MockModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockModel)(nil).Type))
	return &MockModelTypeCall{Call: call}
}

// MockModelTypeCall wrap *gomock.Call
type MockModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTypeCall) Return(arg0 state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTypeCall) Do(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTypeCall) DoAndReturn(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockMachine is a mock of Machine interface.
type MockMachine struct {
	ctrl     *gomock.Controller
	recorder *MockMachineMockRecorder
}

// MockMachineMockRecorder is the mock recorder for MockMachine.
type MockMachineMockRecorder struct {
	mock *MockMachine
}

// NewMockMachine creates a new mock instance.
func NewMockMachine(ctrl *gomock.Controller) *MockMachine {
	mock := &MockMachine{ctrl: ctrl}
	mock.recorder = &MockMachineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachine) EXPECT() *MockMachineMockRecorder {
	return m.recorder
}

// Base mocks base method.
func (m *MockMachine) Base() state.Base {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Base")
	ret0, _ := ret[0].(state.Base)
	return ret0
}

// Base indicates an expected call of Base.
func (mr *MockMachineMockRecorder) Base() *MockMachineBaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Base", reflect.TypeOf((*MockMachine)(nil).Base))
	return &MockMachineBaseCall{Call: call}
}

// MockMachineBaseCall wrap *gomock.Call
type MockMachineBaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineBaseCall) Return(arg0 state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineBaseCall) Do(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineBaseCall) DoAndReturn(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HardwareCharacteristics mocks base method.
func (m *MockMachine) HardwareCharacteristics() (*instance.HardwareCharacteristics, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HardwareCharacteristics")
	ret0, _ := ret[0].(*instance.HardwareCharacteristics)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HardwareCharacteristics indicates an expected call of HardwareCharacteristics.
func (mr *MockMachineMockRecorder) HardwareCharacteristics() *MockMachineHardwareCharacteristicsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HardwareCharacteristics", reflect.TypeOf((*MockMachine)(nil).HardwareCharacteristics))
	return &MockMachineHardwareCharacteristicsCall{Call: call}
}

// MockMachineHardwareCharacteristicsCall wrap *gomock.Call
type MockMachineHardwareCharacteristicsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineHardwareCharacteristicsCall) Return(arg0 *instance.HardwareCharacteristics, arg1 error) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineHardwareCharacteristicsCall) Do(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineHardwareCharacteristicsCall) DoAndReturn(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Id mocks base method.
func (m *MockMachine) Id() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Id")
	ret0, _ := ret[0].(string)
	return ret0
}

// Id indicates an expected call of Id.
func (mr *MockMachineMockRecorder) Id() *MockMachineIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Id", reflect.TypeOf((*MockMachine)(nil).Id))
	return &MockMachineIdCall{Call: call}
}

// MockMachineIdCall wrap *gomock.Call
type MockMachineIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIdCall) Return(arg0 string) *MockMachineIdCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIdCall) Do(f func() string) *MockMachineIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIdCall) DoAndReturn(f func() string) *MockMachineIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PublicAddress mocks base method.
func (m *MockMachine) PublicAddress() (network.SpaceAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublicAddress")
	ret0, _ := ret[0].(network.SpaceAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublicAddress indicates an expected call of PublicAddress.
func (mr *MockMachineMockRecorder) PublicAddress() *MockMachinePublicAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublicAddress", reflect.TypeOf((*MockMachine)(nil).PublicAddress))
	return &MockMachinePublicAddressCall{Call: call}
}

// MockMachinePublicAddressCall wrap *gomock.Call
type MockMachinePublicAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachinePublicAddressCall) Return(arg0 network.SpaceAddress, arg1 error) *MockMachinePublicAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachinePublicAddressCall) Do(f func() (network.SpaceAddress, error)) *MockMachinePublicAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachinePublicAddressCall) DoAndReturn(f func() (network.SpaceAddress, error)) *MockMachinePublicAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockApplication is a mock of Application interface.
type MockApplication struct {
	ctrl     *gomock.Controller
	recorder *MockApplicationMockRecorder
}

// MockApplicationMockRecorder is the mock recorder for MockApplication.
type MockApplicationMockRecorder struct {
	mock *MockApplication
}

// NewMockApplication creates a new mock instance.
func NewMockApplication(ctrl *gomock.Controller) *MockApplication {
	mock := &MockApplication{ctrl: ctrl}
	mock.recorder = &MockApplicationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplication) EXPECT() *MockApplicationMockRecorder {
	return m.recorder
}

// AddUnit mocks base method.
func (m *MockApplication) AddUnit(arg0 state.AddUnitParams) (Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddUnit", arg0)
	ret0, _ := ret[0].(Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddUnit indicates an expected call of AddUnit.
func (mr *MockApplicationMockRecorder) AddUnit(arg0 any) *MockApplicationAddUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUnit", reflect.TypeOf((*MockApplication)(nil).AddUnit), arg0)
	return &MockApplicationAddUnitCall{Call: call}
}

// MockApplicationAddUnitCall wrap *gomock.Call
type MockApplicationAddUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationAddUnitCall) Return(arg0 Unit, arg1 error) *MockApplicationAddUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationAddUnitCall) Do(f func(state.AddUnitParams) (Unit, error)) *MockApplicationAddUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationAddUnitCall) DoAndReturn(f func(state.AddUnitParams) (Unit, error)) *MockApplicationAddUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AgentTools mocks base method.
func (m *MockApplication) AgentTools() (*tools.Tools, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AgentTools")
	ret0, _ := ret[0].(*tools.Tools)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AgentTools indicates an expected call of AgentTools.
func (mr *MockApplicationMockRecorder) AgentTools() *MockApplicationAgentToolsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AgentTools", reflect.TypeOf((*MockApplication)(nil).AgentTools))
	return &MockApplicationAgentToolsCall{Call: call}
}

// MockApplicationAgentToolsCall wrap *gomock.Call
type MockApplicationAgentToolsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationAgentToolsCall) Return(arg0 *tools.Tools, arg1 error) *MockApplicationAgentToolsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationAgentToolsCall) Do(f func() (*tools.Tools, error)) *MockApplicationAgentToolsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationAgentToolsCall) DoAndReturn(f func() (*tools.Tools, error)) *MockApplicationAgentToolsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AllUnits mocks base method.
func (m *MockApplication) AllUnits() ([]Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllUnits")
	ret0, _ := ret[0].([]Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllUnits indicates an expected call of AllUnits.
func (mr *MockApplicationMockRecorder) AllUnits() *MockApplicationAllUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllUnits", reflect.TypeOf((*MockApplication)(nil).AllUnits))
	return &MockApplicationAllUnitsCall{Call: call}
}

// MockApplicationAllUnitsCall wrap *gomock.Call
type MockApplicationAllUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationAllUnitsCall) Return(arg0 []Unit, arg1 error) *MockApplicationAllUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationAllUnitsCall) Do(f func() ([]Unit, error)) *MockApplicationAllUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationAllUnitsCall) DoAndReturn(f func() ([]Unit, error)) *MockApplicationAllUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationConfig mocks base method.
func (m *MockApplication) ApplicationConfig() (config.ConfigAttributes, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationConfig")
	ret0, _ := ret[0].(config.ConfigAttributes)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplicationConfig indicates an expected call of ApplicationConfig.
func (mr *MockApplicationMockRecorder) ApplicationConfig() *MockApplicationApplicationConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationConfig", reflect.TypeOf((*MockApplication)(nil).ApplicationConfig))
	return &MockApplicationApplicationConfigCall{Call: call}
}

// MockApplicationApplicationConfigCall wrap *gomock.Call
type MockApplicationApplicationConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationApplicationConfigCall) Return(arg0 config.ConfigAttributes, arg1 error) *MockApplicationApplicationConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationApplicationConfigCall) Do(f func() (config.ConfigAttributes, error)) *MockApplicationApplicationConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationApplicationConfigCall) DoAndReturn(f func() (config.ConfigAttributes, error)) *MockApplicationApplicationConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationTag mocks base method.
func (m *MockApplication) ApplicationTag() names.ApplicationTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationTag")
	ret0, _ := ret[0].(names.ApplicationTag)
	return ret0
}

// ApplicationTag indicates an expected call of ApplicationTag.
func (mr *MockApplicationMockRecorder) ApplicationTag() *MockApplicationApplicationTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationTag", reflect.TypeOf((*MockApplication)(nil).ApplicationTag))
	return &MockApplicationApplicationTagCall{Call: call}
}

// MockApplicationApplicationTagCall wrap *gomock.Call
type MockApplicationApplicationTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationApplicationTagCall) Return(arg0 names.ApplicationTag) *MockApplicationApplicationTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationApplicationTagCall) Do(f func() names.ApplicationTag) *MockApplicationApplicationTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationApplicationTagCall) DoAndReturn(f func() names.ApplicationTag) *MockApplicationApplicationTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ChangeScale mocks base method.
func (m *MockApplication) ChangeScale(arg0 int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeScale", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChangeScale indicates an expected call of ChangeScale.
func (mr *MockApplicationMockRecorder) ChangeScale(arg0 any) *MockApplicationChangeScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeScale", reflect.TypeOf((*MockApplication)(nil).ChangeScale), arg0)
	return &MockApplicationChangeScaleCall{Call: call}
}

// MockApplicationChangeScaleCall wrap *gomock.Call
type MockApplicationChangeScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationChangeScaleCall) Return(arg0 int, arg1 error) *MockApplicationChangeScaleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationChangeScaleCall) Do(f func(int) (int, error)) *MockApplicationChangeScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationChangeScaleCall) DoAndReturn(f func(int) (int, error)) *MockApplicationChangeScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Charm mocks base method.
func (m *MockApplication) Charm() (Charm, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm")
	ret0, _ := ret[0].(Charm)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Charm indicates an expected call of Charm.
func (mr *MockApplicationMockRecorder) Charm() *MockApplicationCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockApplication)(nil).Charm))
	return &MockApplicationCharmCall{Call: call}
}

// MockApplicationCharmCall wrap *gomock.Call
type MockApplicationCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmCall) Return(arg0 Charm, arg1 bool, arg2 error) *MockApplicationCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmCall) Do(f func() (Charm, bool, error)) *MockApplicationCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmCall) DoAndReturn(f func() (Charm, bool, error)) *MockApplicationCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmConfig mocks base method.
func (m *MockApplication) CharmConfig() (charm.Settings, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmConfig")
	ret0, _ := ret[0].(charm.Settings)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CharmConfig indicates an expected call of CharmConfig.
func (mr *MockApplicationMockRecorder) CharmConfig() *MockApplicationCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmConfig", reflect.TypeOf((*MockApplication)(nil).CharmConfig))
	return &MockApplicationCharmConfigCall{Call: call}
}

// MockApplicationCharmConfigCall wrap *gomock.Call
type MockApplicationCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmConfigCall) Return(arg0 charm.Settings, arg1 error) *MockApplicationCharmConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmConfigCall) Do(f func() (charm.Settings, error)) *MockApplicationCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmConfigCall) DoAndReturn(f func() (charm.Settings, error)) *MockApplicationCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmOrigin mocks base method.
func (m *MockApplication) CharmOrigin() *state.CharmOrigin {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmOrigin")
	ret0, _ := ret[0].(*state.CharmOrigin)
	return ret0
}

// CharmOrigin indicates an expected call of CharmOrigin.
func (mr *MockApplicationMockRecorder) CharmOrigin() *MockApplicationCharmOriginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmOrigin", reflect.TypeOf((*MockApplication)(nil).CharmOrigin))
	return &MockApplicationCharmOriginCall{Call: call}
}

// MockApplicationCharmOriginCall wrap *gomock.Call
type MockApplicationCharmOriginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmOriginCall) Return(arg0 *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmOriginCall) Do(f func() *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmOriginCall) DoAndReturn(f func() *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmURL mocks base method.
func (m *MockApplication) CharmURL() (*string, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmURL")
	ret0, _ := ret[0].(*string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CharmURL indicates an expected call of CharmURL.
func (mr *MockApplicationMockRecorder) CharmURL() *MockApplicationCharmURLCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmURL", reflect.TypeOf((*MockApplication)(nil).CharmURL))
	return &MockApplicationCharmURLCall{Call: call}
}

// MockApplicationCharmURLCall wrap *gomock.Call
type MockApplicationCharmURLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmURLCall) Return(arg0 *string, arg1 bool) *MockApplicationCharmURLCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmURLCall) Do(f func() (*string, bool)) *MockApplicationCharmURLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmURLCall) DoAndReturn(f func() (*string, bool)) *MockApplicationCharmURLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClearExposed mocks base method.
func (m *MockApplication) ClearExposed() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClearExposed")
	ret0, _ := ret[0].(error)
	return ret0
}

// ClearExposed indicates an expected call of ClearExposed.
func (mr *MockApplicationMockRecorder) ClearExposed() *MockApplicationClearExposedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearExposed", reflect.TypeOf((*MockApplication)(nil).ClearExposed))
	return &MockApplicationClearExposedCall{Call: call}
}

// MockApplicationClearExposedCall wrap *gomock.Call
type MockApplicationClearExposedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationClearExposedCall) Return(arg0 error) *MockApplicationClearExposedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationClearExposedCall) Do(f func() error) *MockApplicationClearExposedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationClearExposedCall) DoAndReturn(f func() error) *MockApplicationClearExposedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Constraints mocks base method.
func (m *MockApplication) Constraints() (constraints.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Constraints")
	ret0, _ := ret[0].(constraints.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Constraints indicates an expected call of Constraints.
func (mr *MockApplicationMockRecorder) Constraints() *MockApplicationConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Constraints", reflect.TypeOf((*MockApplication)(nil).Constraints))
	return &MockApplicationConstraintsCall{Call: call}
}

// MockApplicationConstraintsCall wrap *gomock.Call
type MockApplicationConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationConstraintsCall) Return(arg0 constraints.Value, arg1 error) *MockApplicationConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationConstraintsCall) Do(f func() (constraints.Value, error)) *MockApplicationConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationConstraintsCall) DoAndReturn(f func() (constraints.Value, error)) *MockApplicationConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Destroy mocks base method.
func (m *MockApplication) Destroy(arg0 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockApplicationMockRecorder) Destroy(arg0 any) *MockApplicationDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockApplication)(nil).Destroy), arg0)
	return &MockApplicationDestroyCall{Call: call}
}

// MockApplicationDestroyCall wrap *gomock.Call
type MockApplicationDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationDestroyCall) Return(arg0 error) *MockApplicationDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationDestroyCall) Do(f func(objectstore.ObjectStore) error) *MockApplicationDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationDestroyCall) DoAndReturn(f func(objectstore.ObjectStore) error) *MockApplicationDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DestroyOperation mocks base method.
func (m *MockApplication) DestroyOperation(arg0 objectstore.ObjectStore) *state.DestroyApplicationOperation {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyOperation", arg0)
	ret0, _ := ret[0].(*state.DestroyApplicationOperation)
	return ret0
}

// DestroyOperation indicates an expected call of DestroyOperation.
func (mr *MockApplicationMockRecorder) DestroyOperation(arg0 any) *MockApplicationDestroyOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyOperation", reflect.TypeOf((*MockApplication)(nil).DestroyOperation), arg0)
	return &MockApplicationDestroyOperationCall{Call: call}
}

// MockApplicationDestroyOperationCall wrap *gomock.Call
type MockApplicationDestroyOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationDestroyOperationCall) Return(arg0 *state.DestroyApplicationOperation) *MockApplicationDestroyOperationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationDestroyOperationCall) Do(f func(objectstore.ObjectStore) *state.DestroyApplicationOperation) *MockApplicationDestroyOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationDestroyOperationCall) DoAndReturn(f func(objectstore.ObjectStore) *state.DestroyApplicationOperation) *MockApplicationDestroyOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EndpointBindings mocks base method.
func (m *MockApplication) EndpointBindings() (Bindings, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EndpointBindings")
	ret0, _ := ret[0].(Bindings)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EndpointBindings indicates an expected call of EndpointBindings.
func (mr *MockApplicationMockRecorder) EndpointBindings() *MockApplicationEndpointBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndpointBindings", reflect.TypeOf((*MockApplication)(nil).EndpointBindings))
	return &MockApplicationEndpointBindingsCall{Call: call}
}

// MockApplicationEndpointBindingsCall wrap *gomock.Call
type MockApplicationEndpointBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationEndpointBindingsCall) Return(arg0 Bindings, arg1 error) *MockApplicationEndpointBindingsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationEndpointBindingsCall) Do(f func() (Bindings, error)) *MockApplicationEndpointBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationEndpointBindingsCall) DoAndReturn(f func() (Bindings, error)) *MockApplicationEndpointBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Endpoints mocks base method.
func (m *MockApplication) Endpoints() ([]state.Endpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Endpoints")
	ret0, _ := ret[0].([]state.Endpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Endpoints indicates an expected call of Endpoints.
func (mr *MockApplicationMockRecorder) Endpoints() *MockApplicationEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoints", reflect.TypeOf((*MockApplication)(nil).Endpoints))
	return &MockApplicationEndpointsCall{Call: call}
}

// MockApplicationEndpointsCall wrap *gomock.Call
type MockApplicationEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationEndpointsCall) Return(arg0 []state.Endpoint, arg1 error) *MockApplicationEndpointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationEndpointsCall) Do(f func() ([]state.Endpoint, error)) *MockApplicationEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationEndpointsCall) DoAndReturn(f func() ([]state.Endpoint, error)) *MockApplicationEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExposedEndpoints mocks base method.
func (m *MockApplication) ExposedEndpoints() map[string]state.ExposedEndpoint {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExposedEndpoints")
	ret0, _ := ret[0].(map[string]state.ExposedEndpoint)
	return ret0
}

// ExposedEndpoints indicates an expected call of ExposedEndpoints.
func (mr *MockApplicationMockRecorder) ExposedEndpoints() *MockApplicationExposedEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExposedEndpoints", reflect.TypeOf((*MockApplication)(nil).ExposedEndpoints))
	return &MockApplicationExposedEndpointsCall{Call: call}
}

// MockApplicationExposedEndpointsCall wrap *gomock.Call
type MockApplicationExposedEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationExposedEndpointsCall) Return(arg0 map[string]state.ExposedEndpoint) *MockApplicationExposedEndpointsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationExposedEndpointsCall) Do(f func() map[string]state.ExposedEndpoint) *MockApplicationExposedEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationExposedEndpointsCall) DoAndReturn(f func() map[string]state.ExposedEndpoint) *MockApplicationExposedEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsExposed mocks base method.
func (m *MockApplication) IsExposed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsExposed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsExposed indicates an expected call of IsExposed.
func (mr *MockApplicationMockRecorder) IsExposed() *MockApplicationIsExposedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsExposed", reflect.TypeOf((*MockApplication)(nil).IsExposed))
	return &MockApplicationIsExposedCall{Call: call}
}

// MockApplicationIsExposedCall wrap *gomock.Call
type MockApplicationIsExposedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationIsExposedCall) Return(arg0 bool) *MockApplicationIsExposedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationIsExposedCall) Do(f func() bool) *MockApplicationIsExposedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationIsExposedCall) DoAndReturn(f func() bool) *MockApplicationIsExposedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPrincipal mocks base method.
func (m *MockApplication) IsPrincipal() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPrincipal")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPrincipal indicates an expected call of IsPrincipal.
func (mr *MockApplicationMockRecorder) IsPrincipal() *MockApplicationIsPrincipalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPrincipal", reflect.TypeOf((*MockApplication)(nil).IsPrincipal))
	return &MockApplicationIsPrincipalCall{Call: call}
}

// MockApplicationIsPrincipalCall wrap *gomock.Call
type MockApplicationIsPrincipalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationIsPrincipalCall) Return(arg0 bool) *MockApplicationIsPrincipalCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationIsPrincipalCall) Do(f func() bool) *MockApplicationIsPrincipalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationIsPrincipalCall) DoAndReturn(f func() bool) *MockApplicationIsPrincipalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsRemote mocks base method.
func (m *MockApplication) IsRemote() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRemote")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRemote indicates an expected call of IsRemote.
func (mr *MockApplicationMockRecorder) IsRemote() *MockApplicationIsRemoteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRemote", reflect.TypeOf((*MockApplication)(nil).IsRemote))
	return &MockApplicationIsRemoteCall{Call: call}
}

// MockApplicationIsRemoteCall wrap *gomock.Call
type MockApplicationIsRemoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationIsRemoteCall) Return(arg0 bool) *MockApplicationIsRemoteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationIsRemoteCall) Do(f func() bool) *MockApplicationIsRemoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationIsRemoteCall) DoAndReturn(f func() bool) *MockApplicationIsRemoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeBindings mocks base method.
func (m *MockApplication) MergeBindings(arg0 *state.Bindings, arg1 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeBindings", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// MergeBindings indicates an expected call of MergeBindings.
func (mr *MockApplicationMockRecorder) MergeBindings(arg0, arg1 any) *MockApplicationMergeBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeBindings", reflect.TypeOf((*MockApplication)(nil).MergeBindings), arg0, arg1)
	return &MockApplicationMergeBindingsCall{Call: call}
}

// MockApplicationMergeBindingsCall wrap *gomock.Call
type MockApplicationMergeBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationMergeBindingsCall) Return(arg0 error) *MockApplicationMergeBindingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationMergeBindingsCall) Do(f func(*state.Bindings, bool) error) *MockApplicationMergeBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationMergeBindingsCall) DoAndReturn(f func(*state.Bindings, bool) error) *MockApplicationMergeBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeExposeSettings mocks base method.
func (m *MockApplication) MergeExposeSettings(arg0 map[string]state.ExposedEndpoint) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeExposeSettings", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// MergeExposeSettings indicates an expected call of MergeExposeSettings.
func (mr *MockApplicationMockRecorder) MergeExposeSettings(arg0 any) *MockApplicationMergeExposeSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeExposeSettings", reflect.TypeOf((*MockApplication)(nil).MergeExposeSettings), arg0)
	return &MockApplicationMergeExposeSettingsCall{Call: call}
}

// MockApplicationMergeExposeSettingsCall wrap *gomock.Call
type MockApplicationMergeExposeSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationMergeExposeSettingsCall) Return(arg0 error) *MockApplicationMergeExposeSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationMergeExposeSettingsCall) Do(f func(map[string]state.ExposedEndpoint) error) *MockApplicationMergeExposeSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationMergeExposeSettingsCall) DoAndReturn(f func(map[string]state.ExposedEndpoint) error) *MockApplicationMergeExposeSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockApplication) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockApplicationMockRecorder) Name() *MockApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockApplication)(nil).Name))
	return &MockApplicationNameCall{Call: call}
}

// MockApplicationNameCall wrap *gomock.Call
type MockApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationNameCall) Return(arg0 string) *MockApplicationNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationNameCall) Do(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationNameCall) DoAndReturn(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Relations mocks base method.
func (m *MockApplication) Relations() ([]Relation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Relations")
	ret0, _ := ret[0].([]Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Relations indicates an expected call of Relations.
func (mr *MockApplicationMockRecorder) Relations() *MockApplicationRelationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Relations", reflect.TypeOf((*MockApplication)(nil).Relations))
	return &MockApplicationRelationsCall{Call: call}
}

// MockApplicationRelationsCall wrap *gomock.Call
type MockApplicationRelationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationRelationsCall) Return(arg0 []Relation, arg1 error) *MockApplicationRelationsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationRelationsCall) Do(f func() ([]Relation, error)) *MockApplicationRelationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationRelationsCall) DoAndReturn(f func() ([]Relation, error)) *MockApplicationRelationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharm mocks base method.
func (m *MockApplication) SetCharm(arg0 state.SetCharmConfig, arg1 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharm", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCharm indicates an expected call of SetCharm.
func (mr *MockApplicationMockRecorder) SetCharm(arg0, arg1 any) *MockApplicationSetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharm", reflect.TypeOf((*MockApplication)(nil).SetCharm), arg0, arg1)
	return &MockApplicationSetCharmCall{Call: call}
}

// MockApplicationSetCharmCall wrap *gomock.Call
type MockApplicationSetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetCharmCall) Return(arg0 error) *MockApplicationSetCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetCharmCall) Do(f func(state.SetCharmConfig, objectstore.ObjectStore) error) *MockApplicationSetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetCharmCall) DoAndReturn(f func(state.SetCharmConfig, objectstore.ObjectStore) error) *MockApplicationSetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetConstraints mocks base method.
func (m *MockApplication) SetConstraints(arg0 constraints.Value) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetConstraints", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetConstraints indicates an expected call of SetConstraints.
func (mr *MockApplicationMockRecorder) SetConstraints(arg0 any) *MockApplicationSetConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConstraints", reflect.TypeOf((*MockApplication)(nil).SetConstraints), arg0)
	return &MockApplicationSetConstraintsCall{Call: call}
}

// MockApplicationSetConstraintsCall wrap *gomock.Call
type MockApplicationSetConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetConstraintsCall) Return(arg0 error) *MockApplicationSetConstraintsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetConstraintsCall) Do(f func(constraints.Value) error) *MockApplicationSetConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetConstraintsCall) DoAndReturn(f func(constraints.Value) error) *MockApplicationSetConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetMinUnits mocks base method.
func (m *MockApplication) SetMinUnits(arg0 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetMinUnits", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetMinUnits indicates an expected call of SetMinUnits.
func (mr *MockApplicationMockRecorder) SetMinUnits(arg0 any) *MockApplicationSetMinUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMinUnits", reflect.TypeOf((*MockApplication)(nil).SetMinUnits), arg0)
	return &MockApplicationSetMinUnitsCall{Call: call}
}

// MockApplicationSetMinUnitsCall wrap *gomock.Call
type MockApplicationSetMinUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetMinUnitsCall) Return(arg0 error) *MockApplicationSetMinUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetMinUnitsCall) Do(f func(int) error) *MockApplicationSetMinUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetMinUnitsCall) DoAndReturn(f func(int) error) *MockApplicationSetMinUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsetExposeSettings mocks base method.
func (m *MockApplication) UnsetExposeSettings(arg0 []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnsetExposeSettings", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnsetExposeSettings indicates an expected call of UnsetExposeSettings.
func (mr *MockApplicationMockRecorder) UnsetExposeSettings(arg0 any) *MockApplicationUnsetExposeSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsetExposeSettings", reflect.TypeOf((*MockApplication)(nil).UnsetExposeSettings), arg0)
	return &MockApplicationUnsetExposeSettingsCall{Call: call}
}

// MockApplicationUnsetExposeSettingsCall wrap *gomock.Call
type MockApplicationUnsetExposeSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUnsetExposeSettingsCall) Return(arg0 error) *MockApplicationUnsetExposeSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUnsetExposeSettingsCall) Do(f func([]string) error) *MockApplicationUnsetExposeSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUnsetExposeSettingsCall) DoAndReturn(f func([]string) error) *MockApplicationUnsetExposeSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateApplicationConfig mocks base method.
func (m *MockApplication) UpdateApplicationConfig(arg0 config.ConfigAttributes, arg1 []string, arg2 environschema.Fields, arg3 schema.Defaults) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateApplicationConfig", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateApplicationConfig indicates an expected call of UpdateApplicationConfig.
func (mr *MockApplicationMockRecorder) UpdateApplicationConfig(arg0, arg1, arg2, arg3 any) *MockApplicationUpdateApplicationConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateApplicationConfig", reflect.TypeOf((*MockApplication)(nil).UpdateApplicationConfig), arg0, arg1, arg2, arg3)
	return &MockApplicationUpdateApplicationConfigCall{Call: call}
}

// MockApplicationUpdateApplicationConfigCall wrap *gomock.Call
type MockApplicationUpdateApplicationConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUpdateApplicationConfigCall) Return(arg0 error) *MockApplicationUpdateApplicationConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUpdateApplicationConfigCall) Do(f func(config.ConfigAttributes, []string, environschema.Fields, schema.Defaults) error) *MockApplicationUpdateApplicationConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUpdateApplicationConfigCall) DoAndReturn(f func(config.ConfigAttributes, []string, environschema.Fields, schema.Defaults) error) *MockApplicationUpdateApplicationConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateCharmConfig mocks base method.
func (m *MockApplication) UpdateCharmConfig(arg0 charm.Settings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateCharmConfig", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateCharmConfig indicates an expected call of UpdateCharmConfig.
func (mr *MockApplicationMockRecorder) UpdateCharmConfig(arg0 any) *MockApplicationUpdateCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCharmConfig", reflect.TypeOf((*MockApplication)(nil).UpdateCharmConfig), arg0)
	return &MockApplicationUpdateCharmConfigCall{Call: call}
}

// MockApplicationUpdateCharmConfigCall wrap *gomock.Call
type MockApplicationUpdateCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUpdateCharmConfigCall) Return(arg0 error) *MockApplicationUpdateCharmConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUpdateCharmConfigCall) Do(f func(charm.Settings) error) *MockApplicationUpdateCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUpdateCharmConfigCall) DoAndReturn(f func(charm.Settings) error) *MockApplicationUpdateCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharm is a mock of Charm interface.
type MockCharm struct {
	ctrl     *gomock.Controller
	recorder *MockCharmMockRecorder
}

// MockCharmMockRecorder is the mock recorder for MockCharm.
type MockCharmMockRecorder struct {
	mock *MockCharm
}

// NewMockCharm creates a new mock instance.
func NewMockCharm(ctrl *gomock.Controller) *MockCharm {
	mock := &MockCharm{ctrl: ctrl}
	mock.recorder = &MockCharmMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharm) EXPECT() *MockCharmMockRecorder {
	return m.recorder
}

// Actions mocks base method.
func (m *MockCharm) Actions() *charm.Actions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Actions")
	ret0, _ := ret[0].(*charm.Actions)
	return ret0
}

// Actions indicates an expected call of Actions.
func (mr *MockCharmMockRecorder) Actions() *MockCharmActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Actions", reflect.TypeOf((*MockCharm)(nil).Actions))
	return &MockCharmActionsCall{Call: call}
}

// MockCharmActionsCall wrap *gomock.Call
type MockCharmActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmActionsCall) Return(arg0 *charm.Actions) *MockCharmActionsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmActionsCall) Do(f func() *charm.Actions) *MockCharmActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmActionsCall) DoAndReturn(f func() *charm.Actions) *MockCharmActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockCharm) Config() *charm.Config {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*charm.Config)
	return ret0
}

// Config indicates an expected call of Config.
func (mr *MockCharmMockRecorder) Config() *MockCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockCharm)(nil).Config))
	return &MockCharmConfigCall{Call: call}
}

// MockCharmConfigCall wrap *gomock.Call
type MockCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmConfigCall) Return(arg0 *charm.Config) *MockCharmConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmConfigCall) Do(f func() *charm.Config) *MockCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmConfigCall) DoAndReturn(f func() *charm.Config) *MockCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsUploaded mocks base method.
func (m *MockCharm) IsUploaded() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUploaded")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsUploaded indicates an expected call of IsUploaded.
func (mr *MockCharmMockRecorder) IsUploaded() *MockCharmIsUploadedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUploaded", reflect.TypeOf((*MockCharm)(nil).IsUploaded))
	return &MockCharmIsUploadedCall{Call: call}
}

// MockCharmIsUploadedCall wrap *gomock.Call
type MockCharmIsUploadedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmIsUploadedCall) Return(arg0 bool) *MockCharmIsUploadedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmIsUploadedCall) Do(f func() bool) *MockCharmIsUploadedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmIsUploadedCall) DoAndReturn(f func() bool) *MockCharmIsUploadedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Manifest mocks base method.
func (m *MockCharm) Manifest() *charm.Manifest {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Manifest")
	ret0, _ := ret[0].(*charm.Manifest)
	return ret0
}

// Manifest indicates an expected call of Manifest.
func (mr *MockCharmMockRecorder) Manifest() *MockCharmManifestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Manifest", reflect.TypeOf((*MockCharm)(nil).Manifest))
	return &MockCharmManifestCall{Call: call}
}

// MockCharmManifestCall wrap *gomock.Call
type MockCharmManifestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmManifestCall) Return(arg0 *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmManifestCall) Do(f func() *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmManifestCall) DoAndReturn(f func() *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Meta mocks base method.
func (m *MockCharm) Meta() *charm.Meta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Meta")
	ret0, _ := ret[0].(*charm.Meta)
	return ret0
}

// Meta indicates an expected call of Meta.
func (mr *MockCharmMockRecorder) Meta() *MockCharmMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Meta", reflect.TypeOf((*MockCharm)(nil).Meta))
	return &MockCharmMetaCall{Call: call}
}

// MockCharmMetaCall wrap *gomock.Call
type MockCharmMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmMetaCall) Return(arg0 *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmMetaCall) Do(f func() *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmMetaCall) DoAndReturn(f func() *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Revision mocks base method.
func (m *MockCharm) Revision() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revision")
	ret0, _ := ret[0].(int)
	return ret0
}

// Revision indicates an expected call of Revision.
func (mr *MockCharmMockRecorder) Revision() *MockCharmRevisionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revision", reflect.TypeOf((*MockCharm)(nil).Revision))
	return &MockCharmRevisionCall{Call: call}
}

// MockCharmRevisionCall wrap *gomock.Call
type MockCharmRevisionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmRevisionCall) Return(arg0 int) *MockCharmRevisionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmRevisionCall) Do(f func() int) *MockCharmRevisionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmRevisionCall) DoAndReturn(f func() int) *MockCharmRevisionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

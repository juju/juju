// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/apiserver/facades/client/application (interfaces: Backend,StorageInterface,BlockChecker,Model,CaasBrokerInterface,Application,RemoteApplication,Charm,Relation,Unit,RelationUnit,Machine,Generation,Bindings,Resources)
//
// Generated by this command:
//
//	mockgen -typed -package mocks -destination mocks/application_mock.go github.com/juju/juju/apiserver/facades/client/application Backend,StorageInterface,BlockChecker,Model,CaasBrokerInterface,Application,RemoteApplication,Charm,Relation,Unit,RelationUnit,Machine,Generation,Bindings,Resources
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	storagecommon "github.com/juju/juju/apiserver/common/storagecommon"
	application "github.com/juju/juju/apiserver/facades/client/application"
	config "github.com/juju/juju/core/config"
	constraints "github.com/juju/juju/core/constraints"
	crossmodel "github.com/juju/juju/core/crossmodel"
	instance "github.com/juju/juju/core/instance"
	network "github.com/juju/juju/core/network"
	objectstore "github.com/juju/juju/core/objectstore"
	status "github.com/juju/juju/core/status"
	config0 "github.com/juju/juju/environs/config"
	charm "github.com/juju/juju/internal/charm"
	resource "github.com/juju/juju/internal/charm/resource"
	services "github.com/juju/juju/internal/charm/services"
	tools "github.com/juju/juju/internal/tools"
	state "github.com/juju/juju/state"
	names "github.com/juju/names/v5"
	schema "github.com/juju/schema"
	version "github.com/juju/version/v2"
	gomock "go.uber.org/mock/gomock"
	environschema "gopkg.in/juju/environschema.v1"
)

// MockBackend is a mock of Backend interface.
type MockBackend struct {
	ctrl     *gomock.Controller
	recorder *MockBackendMockRecorder
}

// MockBackendMockRecorder is the mock recorder for MockBackend.
type MockBackendMockRecorder struct {
	mock *MockBackend
}

// NewMockBackend creates a new mock instance.
func NewMockBackend(ctrl *gomock.Controller) *MockBackend {
	mock := &MockBackend{ctrl: ctrl}
	mock.recorder = &MockBackendMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackend) EXPECT() *MockBackendMockRecorder {
	return m.recorder
}

// AddApplication mocks base method.
func (m *MockBackend) AddApplication(arg0 state.AddApplicationArgs, arg1 objectstore.ObjectStore) (application.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddApplication", arg0, arg1)
	ret0, _ := ret[0].(application.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddApplication indicates an expected call of AddApplication.
func (mr *MockBackendMockRecorder) AddApplication(arg0, arg1 any) *MockBackendAddApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddApplication", reflect.TypeOf((*MockBackend)(nil).AddApplication), arg0, arg1)
	return &MockBackendAddApplicationCall{Call: call}
}

// MockBackendAddApplicationCall wrap *gomock.Call
type MockBackendAddApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddApplicationCall) Return(arg0 application.Application, arg1 error) *MockBackendAddApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddApplicationCall) Do(f func(state.AddApplicationArgs, objectstore.ObjectStore) (application.Application, error)) *MockBackendAddApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddApplicationCall) DoAndReturn(f func(state.AddApplicationArgs, objectstore.ObjectStore) (application.Application, error)) *MockBackendAddApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddCharmMetadata mocks base method.
func (m *MockBackend) AddCharmMetadata(arg0 state.CharmInfo) (application.Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCharmMetadata", arg0)
	ret0, _ := ret[0].(application.Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCharmMetadata indicates an expected call of AddCharmMetadata.
func (mr *MockBackendMockRecorder) AddCharmMetadata(arg0 any) *MockBackendAddCharmMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCharmMetadata", reflect.TypeOf((*MockBackend)(nil).AddCharmMetadata), arg0)
	return &MockBackendAddCharmMetadataCall{Call: call}
}

// MockBackendAddCharmMetadataCall wrap *gomock.Call
type MockBackendAddCharmMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddCharmMetadataCall) Return(arg0 application.Charm, arg1 error) *MockBackendAddCharmMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddCharmMetadataCall) Do(f func(state.CharmInfo) (application.Charm, error)) *MockBackendAddCharmMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddCharmMetadataCall) DoAndReturn(f func(state.CharmInfo) (application.Charm, error)) *MockBackendAddCharmMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPendingResource mocks base method.
func (m *MockBackend) AddPendingResource(arg0 string, arg1 resource.Resource, arg2 objectstore.ObjectStore) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPendingResource", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddPendingResource indicates an expected call of AddPendingResource.
func (mr *MockBackendMockRecorder) AddPendingResource(arg0, arg1, arg2 any) *MockBackendAddPendingResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPendingResource", reflect.TypeOf((*MockBackend)(nil).AddPendingResource), arg0, arg1, arg2)
	return &MockBackendAddPendingResourceCall{Call: call}
}

// MockBackendAddPendingResourceCall wrap *gomock.Call
type MockBackendAddPendingResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddPendingResourceCall) Return(arg0 string, arg1 error) *MockBackendAddPendingResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddPendingResourceCall) Do(f func(string, resource.Resource, objectstore.ObjectStore) (string, error)) *MockBackendAddPendingResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddPendingResourceCall) DoAndReturn(f func(string, resource.Resource, objectstore.ObjectStore) (string, error)) *MockBackendAddPendingResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRelation mocks base method.
func (m *MockBackend) AddRelation(arg0 ...state.Endpoint) (application.Relation, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddRelation", varargs...)
	ret0, _ := ret[0].(application.Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddRelation indicates an expected call of AddRelation.
func (mr *MockBackendMockRecorder) AddRelation(arg0 ...any) *MockBackendAddRelationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRelation", reflect.TypeOf((*MockBackend)(nil).AddRelation), arg0...)
	return &MockBackendAddRelationCall{Call: call}
}

// MockBackendAddRelationCall wrap *gomock.Call
type MockBackendAddRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddRelationCall) Return(arg0 application.Relation, arg1 error) *MockBackendAddRelationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddRelationCall) Do(f func(...state.Endpoint) (application.Relation, error)) *MockBackendAddRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddRelationCall) DoAndReturn(f func(...state.Endpoint) (application.Relation, error)) *MockBackendAddRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRemoteApplication mocks base method.
func (m *MockBackend) AddRemoteApplication(arg0 state.AddRemoteApplicationParams) (application.RemoteApplication, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddRemoteApplication", arg0)
	ret0, _ := ret[0].(application.RemoteApplication)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddRemoteApplication indicates an expected call of AddRemoteApplication.
func (mr *MockBackendMockRecorder) AddRemoteApplication(arg0 any) *MockBackendAddRemoteApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRemoteApplication", reflect.TypeOf((*MockBackend)(nil).AddRemoteApplication), arg0)
	return &MockBackendAddRemoteApplicationCall{Call: call}
}

// MockBackendAddRemoteApplicationCall wrap *gomock.Call
type MockBackendAddRemoteApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddRemoteApplicationCall) Return(arg0 application.RemoteApplication, arg1 error) *MockBackendAddRemoteApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddRemoteApplicationCall) Do(f func(state.AddRemoteApplicationParams) (application.RemoteApplication, error)) *MockBackendAddRemoteApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddRemoteApplicationCall) DoAndReturn(f func(state.AddRemoteApplicationParams) (application.RemoteApplication, error)) *MockBackendAddRemoteApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AllModelUUIDs mocks base method.
func (m *MockBackend) AllModelUUIDs() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllModelUUIDs")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllModelUUIDs indicates an expected call of AllModelUUIDs.
func (mr *MockBackendMockRecorder) AllModelUUIDs() *MockBackendAllModelUUIDsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllModelUUIDs", reflect.TypeOf((*MockBackend)(nil).AllModelUUIDs))
	return &MockBackendAllModelUUIDsCall{Call: call}
}

// MockBackendAllModelUUIDsCall wrap *gomock.Call
type MockBackendAllModelUUIDsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAllModelUUIDsCall) Return(arg0 []string, arg1 error) *MockBackendAllModelUUIDsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAllModelUUIDsCall) Do(f func() ([]string, error)) *MockBackendAllModelUUIDsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAllModelUUIDsCall) DoAndReturn(f func() ([]string, error)) *MockBackendAllModelUUIDsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Application mocks base method.
func (m *MockBackend) Application(arg0 string) (application.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Application", arg0)
	ret0, _ := ret[0].(application.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Application indicates an expected call of Application.
func (mr *MockBackendMockRecorder) Application(arg0 any) *MockBackendApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Application", reflect.TypeOf((*MockBackend)(nil).Application), arg0)
	return &MockBackendApplicationCall{Call: call}
}

// MockBackendApplicationCall wrap *gomock.Call
type MockBackendApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendApplicationCall) Return(arg0 application.Application, arg1 error) *MockBackendApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendApplicationCall) Do(f func(string) (application.Application, error)) *MockBackendApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendApplicationCall) DoAndReturn(f func(string) (application.Application, error)) *MockBackendApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationOfferForUUID mocks base method.
func (m *MockBackend) ApplicationOfferForUUID(arg0 string) (*crossmodel.ApplicationOffer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationOfferForUUID", arg0)
	ret0, _ := ret[0].(*crossmodel.ApplicationOffer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplicationOfferForUUID indicates an expected call of ApplicationOfferForUUID.
func (mr *MockBackendMockRecorder) ApplicationOfferForUUID(arg0 any) *MockBackendApplicationOfferForUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationOfferForUUID", reflect.TypeOf((*MockBackend)(nil).ApplicationOfferForUUID), arg0)
	return &MockBackendApplicationOfferForUUIDCall{Call: call}
}

// MockBackendApplicationOfferForUUIDCall wrap *gomock.Call
type MockBackendApplicationOfferForUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendApplicationOfferForUUIDCall) Return(arg0 *crossmodel.ApplicationOffer, arg1 error) *MockBackendApplicationOfferForUUIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendApplicationOfferForUUIDCall) Do(f func(string) (*crossmodel.ApplicationOffer, error)) *MockBackendApplicationOfferForUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendApplicationOfferForUUIDCall) DoAndReturn(f func(string) (*crossmodel.ApplicationOffer, error)) *MockBackendApplicationOfferForUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplyOperation mocks base method.
func (m *MockBackend) ApplyOperation(arg0 state.ModelOperation) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyOperation", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ApplyOperation indicates an expected call of ApplyOperation.
func (mr *MockBackendMockRecorder) ApplyOperation(arg0 any) *MockBackendApplyOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyOperation", reflect.TypeOf((*MockBackend)(nil).ApplyOperation), arg0)
	return &MockBackendApplyOperationCall{Call: call}
}

// MockBackendApplyOperationCall wrap *gomock.Call
type MockBackendApplyOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendApplyOperationCall) Return(arg0 error) *MockBackendApplyOperationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendApplyOperationCall) Do(f func(state.ModelOperation) error) *MockBackendApplyOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendApplyOperationCall) DoAndReturn(f func(state.ModelOperation) error) *MockBackendApplyOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Branch mocks base method.
func (m *MockBackend) Branch(arg0 string) (application.Generation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Branch", arg0)
	ret0, _ := ret[0].(application.Generation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Branch indicates an expected call of Branch.
func (mr *MockBackendMockRecorder) Branch(arg0 any) *MockBackendBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Branch", reflect.TypeOf((*MockBackend)(nil).Branch), arg0)
	return &MockBackendBranchCall{Call: call}
}

// MockBackendBranchCall wrap *gomock.Call
type MockBackendBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendBranchCall) Return(arg0 application.Generation, arg1 error) *MockBackendBranchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendBranchCall) Do(f func(string) (application.Generation, error)) *MockBackendBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendBranchCall) DoAndReturn(f func(string) (application.Generation, error)) *MockBackendBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Charm mocks base method.
func (m *MockBackend) Charm(arg0 string) (application.Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm", arg0)
	ret0, _ := ret[0].(application.Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Charm indicates an expected call of Charm.
func (mr *MockBackendMockRecorder) Charm(arg0 any) *MockBackendCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockBackend)(nil).Charm), arg0)
	return &MockBackendCharmCall{Call: call}
}

// MockBackendCharmCall wrap *gomock.Call
type MockBackendCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendCharmCall) Return(arg0 application.Charm, arg1 error) *MockBackendCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendCharmCall) Do(f func(string) (application.Charm, error)) *MockBackendCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendCharmCall) DoAndReturn(f func(string) (application.Charm, error)) *MockBackendCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ControllerTag mocks base method.
func (m *MockBackend) ControllerTag() names.ControllerTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerTag")
	ret0, _ := ret[0].(names.ControllerTag)
	return ret0
}

// ControllerTag indicates an expected call of ControllerTag.
func (mr *MockBackendMockRecorder) ControllerTag() *MockBackendControllerTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerTag", reflect.TypeOf((*MockBackend)(nil).ControllerTag))
	return &MockBackendControllerTagCall{Call: call}
}

// MockBackendControllerTagCall wrap *gomock.Call
type MockBackendControllerTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendControllerTagCall) Return(arg0 names.ControllerTag) *MockBackendControllerTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendControllerTagCall) Do(f func() names.ControllerTag) *MockBackendControllerTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendControllerTagCall) DoAndReturn(f func() names.ControllerTag) *MockBackendControllerTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InferActiveRelation mocks base method.
func (m *MockBackend) InferActiveRelation(arg0 ...string) (application.Relation, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InferActiveRelation", varargs...)
	ret0, _ := ret[0].(application.Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InferActiveRelation indicates an expected call of InferActiveRelation.
func (mr *MockBackendMockRecorder) InferActiveRelation(arg0 ...any) *MockBackendInferActiveRelationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InferActiveRelation", reflect.TypeOf((*MockBackend)(nil).InferActiveRelation), arg0...)
	return &MockBackendInferActiveRelationCall{Call: call}
}

// MockBackendInferActiveRelationCall wrap *gomock.Call
type MockBackendInferActiveRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendInferActiveRelationCall) Return(arg0 application.Relation, arg1 error) *MockBackendInferActiveRelationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendInferActiveRelationCall) Do(f func(...string) (application.Relation, error)) *MockBackendInferActiveRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendInferActiveRelationCall) DoAndReturn(f func(...string) (application.Relation, error)) *MockBackendInferActiveRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InferEndpoints mocks base method.
func (m *MockBackend) InferEndpoints(arg0 ...string) ([]state.Endpoint, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InferEndpoints", varargs...)
	ret0, _ := ret[0].([]state.Endpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InferEndpoints indicates an expected call of InferEndpoints.
func (mr *MockBackendMockRecorder) InferEndpoints(arg0 ...any) *MockBackendInferEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InferEndpoints", reflect.TypeOf((*MockBackend)(nil).InferEndpoints), arg0...)
	return &MockBackendInferEndpointsCall{Call: call}
}

// MockBackendInferEndpointsCall wrap *gomock.Call
type MockBackendInferEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendInferEndpointsCall) Return(arg0 []state.Endpoint, arg1 error) *MockBackendInferEndpointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendInferEndpointsCall) Do(f func(...string) ([]state.Endpoint, error)) *MockBackendInferEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendInferEndpointsCall) DoAndReturn(f func(...string) ([]state.Endpoint, error)) *MockBackendInferEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Machine mocks base method.
func (m *MockBackend) Machine(arg0 string) (application.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Machine", arg0)
	ret0, _ := ret[0].(application.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Machine indicates an expected call of Machine.
func (mr *MockBackendMockRecorder) Machine(arg0 any) *MockBackendMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Machine", reflect.TypeOf((*MockBackend)(nil).Machine), arg0)
	return &MockBackendMachineCall{Call: call}
}

// MockBackendMachineCall wrap *gomock.Call
type MockBackendMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendMachineCall) Return(arg0 application.Machine, arg1 error) *MockBackendMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendMachineCall) Do(f func(string) (application.Machine, error)) *MockBackendMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendMachineCall) DoAndReturn(f func(string) (application.Machine, error)) *MockBackendMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Model mocks base method.
func (m *MockBackend) Model() (application.Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Model")
	ret0, _ := ret[0].(application.Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Model indicates an expected call of Model.
func (mr *MockBackendMockRecorder) Model() *MockBackendModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Model", reflect.TypeOf((*MockBackend)(nil).Model))
	return &MockBackendModelCall{Call: call}
}

// MockBackendModelCall wrap *gomock.Call
type MockBackendModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendModelCall) Return(arg0 application.Model, arg1 error) *MockBackendModelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendModelCall) Do(f func() (application.Model, error)) *MockBackendModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendModelCall) DoAndReturn(f func() (application.Model, error)) *MockBackendModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelConstraints mocks base method.
func (m *MockBackend) ModelConstraints() (constraints.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelConstraints")
	ret0, _ := ret[0].(constraints.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelConstraints indicates an expected call of ModelConstraints.
func (mr *MockBackendMockRecorder) ModelConstraints() *MockBackendModelConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelConstraints", reflect.TypeOf((*MockBackend)(nil).ModelConstraints))
	return &MockBackendModelConstraintsCall{Call: call}
}

// MockBackendModelConstraintsCall wrap *gomock.Call
type MockBackendModelConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendModelConstraintsCall) Return(arg0 constraints.Value, arg1 error) *MockBackendModelConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendModelConstraintsCall) Do(f func() (constraints.Value, error)) *MockBackendModelConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendModelConstraintsCall) DoAndReturn(f func() (constraints.Value, error)) *MockBackendModelConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelUUID mocks base method.
func (m *MockBackend) ModelUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ModelUUID indicates an expected call of ModelUUID.
func (mr *MockBackendMockRecorder) ModelUUID() *MockBackendModelUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelUUID", reflect.TypeOf((*MockBackend)(nil).ModelUUID))
	return &MockBackendModelUUIDCall{Call: call}
}

// MockBackendModelUUIDCall wrap *gomock.Call
type MockBackendModelUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendModelUUIDCall) Return(arg0 string) *MockBackendModelUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendModelUUIDCall) Do(f func() string) *MockBackendModelUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendModelUUIDCall) DoAndReturn(f func() string) *MockBackendModelUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OfferConnectionForRelation mocks base method.
func (m *MockBackend) OfferConnectionForRelation(arg0 string) (application.OfferConnection, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OfferConnectionForRelation", arg0)
	ret0, _ := ret[0].(application.OfferConnection)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OfferConnectionForRelation indicates an expected call of OfferConnectionForRelation.
func (mr *MockBackendMockRecorder) OfferConnectionForRelation(arg0 any) *MockBackendOfferConnectionForRelationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OfferConnectionForRelation", reflect.TypeOf((*MockBackend)(nil).OfferConnectionForRelation), arg0)
	return &MockBackendOfferConnectionForRelationCall{Call: call}
}

// MockBackendOfferConnectionForRelationCall wrap *gomock.Call
type MockBackendOfferConnectionForRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendOfferConnectionForRelationCall) Return(arg0 application.OfferConnection, arg1 error) *MockBackendOfferConnectionForRelationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendOfferConnectionForRelationCall) Do(f func(string) (application.OfferConnection, error)) *MockBackendOfferConnectionForRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendOfferConnectionForRelationCall) DoAndReturn(f func(string) (application.OfferConnection, error)) *MockBackendOfferConnectionForRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareCharmUpload mocks base method.
func (m *MockBackend) PrepareCharmUpload(arg0 string) (services.UploadedCharm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareCharmUpload", arg0)
	ret0, _ := ret[0].(services.UploadedCharm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareCharmUpload indicates an expected call of PrepareCharmUpload.
func (mr *MockBackendMockRecorder) PrepareCharmUpload(arg0 any) *MockBackendPrepareCharmUploadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareCharmUpload", reflect.TypeOf((*MockBackend)(nil).PrepareCharmUpload), arg0)
	return &MockBackendPrepareCharmUploadCall{Call: call}
}

// MockBackendPrepareCharmUploadCall wrap *gomock.Call
type MockBackendPrepareCharmUploadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendPrepareCharmUploadCall) Return(arg0 services.UploadedCharm, arg1 error) *MockBackendPrepareCharmUploadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendPrepareCharmUploadCall) Do(f func(string) (services.UploadedCharm, error)) *MockBackendPrepareCharmUploadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendPrepareCharmUploadCall) DoAndReturn(f func(string) (services.UploadedCharm, error)) *MockBackendPrepareCharmUploadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadSequence mocks base method.
func (m *MockBackend) ReadSequence(arg0 string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadSequence", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadSequence indicates an expected call of ReadSequence.
func (mr *MockBackendMockRecorder) ReadSequence(arg0 any) *MockBackendReadSequenceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadSequence", reflect.TypeOf((*MockBackend)(nil).ReadSequence), arg0)
	return &MockBackendReadSequenceCall{Call: call}
}

// MockBackendReadSequenceCall wrap *gomock.Call
type MockBackendReadSequenceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendReadSequenceCall) Return(arg0 int, arg1 error) *MockBackendReadSequenceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendReadSequenceCall) Do(f func(string) (int, error)) *MockBackendReadSequenceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendReadSequenceCall) DoAndReturn(f func(string) (int, error)) *MockBackendReadSequenceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Relation mocks base method.
func (m *MockBackend) Relation(arg0 int) (application.Relation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Relation", arg0)
	ret0, _ := ret[0].(application.Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Relation indicates an expected call of Relation.
func (mr *MockBackendMockRecorder) Relation(arg0 any) *MockBackendRelationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Relation", reflect.TypeOf((*MockBackend)(nil).Relation), arg0)
	return &MockBackendRelationCall{Call: call}
}

// MockBackendRelationCall wrap *gomock.Call
type MockBackendRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendRelationCall) Return(arg0 application.Relation, arg1 error) *MockBackendRelationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendRelationCall) Do(f func(int) (application.Relation, error)) *MockBackendRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendRelationCall) DoAndReturn(f func(int) (application.Relation, error)) *MockBackendRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoteApplication mocks base method.
func (m *MockBackend) RemoteApplication(arg0 string) (application.RemoteApplication, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteApplication", arg0)
	ret0, _ := ret[0].(application.RemoteApplication)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoteApplication indicates an expected call of RemoteApplication.
func (mr *MockBackendMockRecorder) RemoteApplication(arg0 any) *MockBackendRemoteApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteApplication", reflect.TypeOf((*MockBackend)(nil).RemoteApplication), arg0)
	return &MockBackendRemoteApplicationCall{Call: call}
}

// MockBackendRemoteApplicationCall wrap *gomock.Call
type MockBackendRemoteApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendRemoteApplicationCall) Return(arg0 application.RemoteApplication, arg1 error) *MockBackendRemoteApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendRemoteApplicationCall) Do(f func(string) (application.RemoteApplication, error)) *MockBackendRemoteApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendRemoteApplicationCall) DoAndReturn(f func(string) (application.RemoteApplication, error)) *MockBackendRemoteApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemovePendingResources mocks base method.
func (m *MockBackend) RemovePendingResources(arg0 string, arg1 map[string]string, arg2 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemovePendingResources", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemovePendingResources indicates an expected call of RemovePendingResources.
func (mr *MockBackendMockRecorder) RemovePendingResources(arg0, arg1, arg2 any) *MockBackendRemovePendingResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePendingResources", reflect.TypeOf((*MockBackend)(nil).RemovePendingResources), arg0, arg1, arg2)
	return &MockBackendRemovePendingResourcesCall{Call: call}
}

// MockBackendRemovePendingResourcesCall wrap *gomock.Call
type MockBackendRemovePendingResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendRemovePendingResourcesCall) Return(arg0 error) *MockBackendRemovePendingResourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendRemovePendingResourcesCall) Do(f func(string, map[string]string, objectstore.ObjectStore) error) *MockBackendRemovePendingResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendRemovePendingResourcesCall) DoAndReturn(f func(string, map[string]string, objectstore.ObjectStore) error) *MockBackendRemovePendingResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Resources mocks base method.
func (m *MockBackend) Resources(arg0 objectstore.ObjectStore) application.Resources {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resources", arg0)
	ret0, _ := ret[0].(application.Resources)
	return ret0
}

// Resources indicates an expected call of Resources.
func (mr *MockBackendMockRecorder) Resources(arg0 any) *MockBackendResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resources", reflect.TypeOf((*MockBackend)(nil).Resources), arg0)
	return &MockBackendResourcesCall{Call: call}
}

// MockBackendResourcesCall wrap *gomock.Call
type MockBackendResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendResourcesCall) Return(arg0 application.Resources) *MockBackendResourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendResourcesCall) Do(f func(objectstore.ObjectStore) application.Resources) *MockBackendResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendResourcesCall) DoAndReturn(f func(objectstore.ObjectStore) application.Resources) *MockBackendResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveEgressNetworks mocks base method.
func (m *MockBackend) SaveEgressNetworks(arg0 string, arg1 []string) (state.RelationNetworks, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveEgressNetworks", arg0, arg1)
	ret0, _ := ret[0].(state.RelationNetworks)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveEgressNetworks indicates an expected call of SaveEgressNetworks.
func (mr *MockBackendMockRecorder) SaveEgressNetworks(arg0, arg1 any) *MockBackendSaveEgressNetworksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveEgressNetworks", reflect.TypeOf((*MockBackend)(nil).SaveEgressNetworks), arg0, arg1)
	return &MockBackendSaveEgressNetworksCall{Call: call}
}

// MockBackendSaveEgressNetworksCall wrap *gomock.Call
type MockBackendSaveEgressNetworksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendSaveEgressNetworksCall) Return(arg0 state.RelationNetworks, arg1 error) *MockBackendSaveEgressNetworksCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendSaveEgressNetworksCall) Do(f func(string, []string) (state.RelationNetworks, error)) *MockBackendSaveEgressNetworksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendSaveEgressNetworksCall) DoAndReturn(f func(string, []string) (state.RelationNetworks, error)) *MockBackendSaveEgressNetworksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unit mocks base method.
func (m *MockBackend) Unit(arg0 string) (application.Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unit", arg0)
	ret0, _ := ret[0].(application.Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unit indicates an expected call of Unit.
func (mr *MockBackendMockRecorder) Unit(arg0 any) *MockBackendUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unit", reflect.TypeOf((*MockBackend)(nil).Unit), arg0)
	return &MockBackendUnitCall{Call: call}
}

// MockBackendUnitCall wrap *gomock.Call
type MockBackendUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendUnitCall) Return(arg0 application.Unit, arg1 error) *MockBackendUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendUnitCall) Do(f func(string) (application.Unit, error)) *MockBackendUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendUnitCall) DoAndReturn(f func(string) (application.Unit, error)) *MockBackendUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitsInError mocks base method.
func (m *MockBackend) UnitsInError() ([]application.Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitsInError")
	ret0, _ := ret[0].([]application.Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnitsInError indicates an expected call of UnitsInError.
func (mr *MockBackendMockRecorder) UnitsInError() *MockBackendUnitsInErrorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitsInError", reflect.TypeOf((*MockBackend)(nil).UnitsInError))
	return &MockBackendUnitsInErrorCall{Call: call}
}

// MockBackendUnitsInErrorCall wrap *gomock.Call
type MockBackendUnitsInErrorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendUnitsInErrorCall) Return(arg0 []application.Unit, arg1 error) *MockBackendUnitsInErrorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendUnitsInErrorCall) Do(f func() ([]application.Unit, error)) *MockBackendUnitsInErrorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendUnitsInErrorCall) DoAndReturn(f func() ([]application.Unit, error)) *MockBackendUnitsInErrorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateUploadedCharm mocks base method.
func (m *MockBackend) UpdateUploadedCharm(arg0 state.CharmInfo) (services.UploadedCharm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUploadedCharm", arg0)
	ret0, _ := ret[0].(services.UploadedCharm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateUploadedCharm indicates an expected call of UpdateUploadedCharm.
func (mr *MockBackendMockRecorder) UpdateUploadedCharm(arg0 any) *MockBackendUpdateUploadedCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUploadedCharm", reflect.TypeOf((*MockBackend)(nil).UpdateUploadedCharm), arg0)
	return &MockBackendUpdateUploadedCharmCall{Call: call}
}

// MockBackendUpdateUploadedCharmCall wrap *gomock.Call
type MockBackendUpdateUploadedCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendUpdateUploadedCharmCall) Return(arg0 services.UploadedCharm, arg1 error) *MockBackendUpdateUploadedCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendUpdateUploadedCharmCall) Do(f func(state.CharmInfo) (services.UploadedCharm, error)) *MockBackendUpdateUploadedCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendUpdateUploadedCharmCall) DoAndReturn(f func(state.CharmInfo) (services.UploadedCharm, error)) *MockBackendUpdateUploadedCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStorageInterface is a mock of StorageInterface interface.
type MockStorageInterface struct {
	ctrl     *gomock.Controller
	recorder *MockStorageInterfaceMockRecorder
}

// MockStorageInterfaceMockRecorder is the mock recorder for MockStorageInterface.
type MockStorageInterfaceMockRecorder struct {
	mock *MockStorageInterface
}

// NewMockStorageInterface creates a new mock instance.
func NewMockStorageInterface(ctrl *gomock.Controller) *MockStorageInterface {
	mock := &MockStorageInterface{ctrl: ctrl}
	mock.recorder = &MockStorageInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorageInterface) EXPECT() *MockStorageInterfaceMockRecorder {
	return m.recorder
}

// FilesystemAccess mocks base method.
func (m *MockStorageInterface) FilesystemAccess() storagecommon.FilesystemAccess {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilesystemAccess")
	ret0, _ := ret[0].(storagecommon.FilesystemAccess)
	return ret0
}

// FilesystemAccess indicates an expected call of FilesystemAccess.
func (mr *MockStorageInterfaceMockRecorder) FilesystemAccess() *MockStorageInterfaceFilesystemAccessCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilesystemAccess", reflect.TypeOf((*MockStorageInterface)(nil).FilesystemAccess))
	return &MockStorageInterfaceFilesystemAccessCall{Call: call}
}

// MockStorageInterfaceFilesystemAccessCall wrap *gomock.Call
type MockStorageInterfaceFilesystemAccessCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceFilesystemAccessCall) Return(arg0 storagecommon.FilesystemAccess) *MockStorageInterfaceFilesystemAccessCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceFilesystemAccessCall) Do(f func() storagecommon.FilesystemAccess) *MockStorageInterfaceFilesystemAccessCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceFilesystemAccessCall) DoAndReturn(f func() storagecommon.FilesystemAccess) *MockStorageInterfaceFilesystemAccessCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageInstance mocks base method.
func (m *MockStorageInterface) StorageInstance(arg0 names.StorageTag) (state.StorageInstance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageInstance", arg0)
	ret0, _ := ret[0].(state.StorageInstance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageInstance indicates an expected call of StorageInstance.
func (mr *MockStorageInterfaceMockRecorder) StorageInstance(arg0 any) *MockStorageInterfaceStorageInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageInstance", reflect.TypeOf((*MockStorageInterface)(nil).StorageInstance), arg0)
	return &MockStorageInterfaceStorageInstanceCall{Call: call}
}

// MockStorageInterfaceStorageInstanceCall wrap *gomock.Call
type MockStorageInterfaceStorageInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceStorageInstanceCall) Return(arg0 state.StorageInstance, arg1 error) *MockStorageInterfaceStorageInstanceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceStorageInstanceCall) Do(f func(names.StorageTag) (state.StorageInstance, error)) *MockStorageInterfaceStorageInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceStorageInstanceCall) DoAndReturn(f func(names.StorageTag) (state.StorageInstance, error)) *MockStorageInterfaceStorageInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitStorageAttachments mocks base method.
func (m *MockStorageInterface) UnitStorageAttachments(arg0 names.UnitTag) ([]state.StorageAttachment, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitStorageAttachments", arg0)
	ret0, _ := ret[0].([]state.StorageAttachment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnitStorageAttachments indicates an expected call of UnitStorageAttachments.
func (mr *MockStorageInterfaceMockRecorder) UnitStorageAttachments(arg0 any) *MockStorageInterfaceUnitStorageAttachmentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitStorageAttachments", reflect.TypeOf((*MockStorageInterface)(nil).UnitStorageAttachments), arg0)
	return &MockStorageInterfaceUnitStorageAttachmentsCall{Call: call}
}

// MockStorageInterfaceUnitStorageAttachmentsCall wrap *gomock.Call
type MockStorageInterfaceUnitStorageAttachmentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceUnitStorageAttachmentsCall) Return(arg0 []state.StorageAttachment, arg1 error) *MockStorageInterfaceUnitStorageAttachmentsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceUnitStorageAttachmentsCall) Do(f func(names.UnitTag) ([]state.StorageAttachment, error)) *MockStorageInterfaceUnitStorageAttachmentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceUnitStorageAttachmentsCall) DoAndReturn(f func(names.UnitTag) ([]state.StorageAttachment, error)) *MockStorageInterfaceUnitStorageAttachmentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VolumeAccess mocks base method.
func (m *MockStorageInterface) VolumeAccess() storagecommon.VolumeAccess {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VolumeAccess")
	ret0, _ := ret[0].(storagecommon.VolumeAccess)
	return ret0
}

// VolumeAccess indicates an expected call of VolumeAccess.
func (mr *MockStorageInterfaceMockRecorder) VolumeAccess() *MockStorageInterfaceVolumeAccessCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VolumeAccess", reflect.TypeOf((*MockStorageInterface)(nil).VolumeAccess))
	return &MockStorageInterfaceVolumeAccessCall{Call: call}
}

// MockStorageInterfaceVolumeAccessCall wrap *gomock.Call
type MockStorageInterfaceVolumeAccessCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceVolumeAccessCall) Return(arg0 storagecommon.VolumeAccess) *MockStorageInterfaceVolumeAccessCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceVolumeAccessCall) Do(f func() storagecommon.VolumeAccess) *MockStorageInterfaceVolumeAccessCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceVolumeAccessCall) DoAndReturn(f func() storagecommon.VolumeAccess) *MockStorageInterfaceVolumeAccessCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockBlockChecker is a mock of BlockChecker interface.
type MockBlockChecker struct {
	ctrl     *gomock.Controller
	recorder *MockBlockCheckerMockRecorder
}

// MockBlockCheckerMockRecorder is the mock recorder for MockBlockChecker.
type MockBlockCheckerMockRecorder struct {
	mock *MockBlockChecker
}

// NewMockBlockChecker creates a new mock instance.
func NewMockBlockChecker(ctrl *gomock.Controller) *MockBlockChecker {
	mock := &MockBlockChecker{ctrl: ctrl}
	mock.recorder = &MockBlockCheckerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBlockChecker) EXPECT() *MockBlockCheckerMockRecorder {
	return m.recorder
}

// ChangeAllowed mocks base method.
func (m *MockBlockChecker) ChangeAllowed(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeAllowed", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeAllowed indicates an expected call of ChangeAllowed.
func (mr *MockBlockCheckerMockRecorder) ChangeAllowed(arg0 any) *MockBlockCheckerChangeAllowedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeAllowed", reflect.TypeOf((*MockBlockChecker)(nil).ChangeAllowed), arg0)
	return &MockBlockCheckerChangeAllowedCall{Call: call}
}

// MockBlockCheckerChangeAllowedCall wrap *gomock.Call
type MockBlockCheckerChangeAllowedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBlockCheckerChangeAllowedCall) Return(arg0 error) *MockBlockCheckerChangeAllowedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBlockCheckerChangeAllowedCall) Do(f func(context.Context) error) *MockBlockCheckerChangeAllowedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBlockCheckerChangeAllowedCall) DoAndReturn(f func(context.Context) error) *MockBlockCheckerChangeAllowedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveAllowed mocks base method.
func (m *MockBlockChecker) RemoveAllowed(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAllowed", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveAllowed indicates an expected call of RemoveAllowed.
func (mr *MockBlockCheckerMockRecorder) RemoveAllowed(arg0 any) *MockBlockCheckerRemoveAllowedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAllowed", reflect.TypeOf((*MockBlockChecker)(nil).RemoveAllowed), arg0)
	return &MockBlockCheckerRemoveAllowedCall{Call: call}
}

// MockBlockCheckerRemoveAllowedCall wrap *gomock.Call
type MockBlockCheckerRemoveAllowedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBlockCheckerRemoveAllowedCall) Return(arg0 error) *MockBlockCheckerRemoveAllowedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBlockCheckerRemoveAllowedCall) Do(f func(context.Context) error) *MockBlockCheckerRemoveAllowedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBlockCheckerRemoveAllowedCall) DoAndReturn(f func(context.Context) error) *MockBlockCheckerRemoveAllowedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockModel is a mock of Model interface.
type MockModel struct {
	ctrl     *gomock.Controller
	recorder *MockModelMockRecorder
}

// MockModelMockRecorder is the mock recorder for MockModel.
type MockModelMockRecorder struct {
	mock *MockModel
}

// NewMockModel creates a new mock instance.
func NewMockModel(ctrl *gomock.Controller) *MockModel {
	mock := &MockModel{ctrl: ctrl}
	mock.recorder = &MockModelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModel) EXPECT() *MockModelMockRecorder {
	return m.recorder
}

// AgentVersion mocks base method.
func (m *MockModel) AgentVersion() (version.Number, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AgentVersion")
	ret0, _ := ret[0].(version.Number)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AgentVersion indicates an expected call of AgentVersion.
func (mr *MockModelMockRecorder) AgentVersion() *MockModelAgentVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AgentVersion", reflect.TypeOf((*MockModel)(nil).AgentVersion))
	return &MockModelAgentVersionCall{Call: call}
}

// MockModelAgentVersionCall wrap *gomock.Call
type MockModelAgentVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelAgentVersionCall) Return(arg0 version.Number, arg1 error) *MockModelAgentVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelAgentVersionCall) Do(f func() (version.Number, error)) *MockModelAgentVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelAgentVersionCall) DoAndReturn(f func() (version.Number, error)) *MockModelAgentVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudCredentialTag mocks base method.
func (m *MockModel) CloudCredentialTag() (names.CloudCredentialTag, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudCredentialTag")
	ret0, _ := ret[0].(names.CloudCredentialTag)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CloudCredentialTag indicates an expected call of CloudCredentialTag.
func (mr *MockModelMockRecorder) CloudCredentialTag() *MockModelCloudCredentialTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudCredentialTag", reflect.TypeOf((*MockModel)(nil).CloudCredentialTag))
	return &MockModelCloudCredentialTagCall{Call: call}
}

// MockModelCloudCredentialTagCall wrap *gomock.Call
type MockModelCloudCredentialTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudCredentialTagCall) Return(arg0 names.CloudCredentialTag, arg1 bool) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudCredentialTagCall) Do(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudCredentialTagCall) DoAndReturn(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudName mocks base method.
func (m *MockModel) CloudName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudName")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudName indicates an expected call of CloudName.
func (mr *MockModelMockRecorder) CloudName() *MockModelCloudNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudName", reflect.TypeOf((*MockModel)(nil).CloudName))
	return &MockModelCloudNameCall{Call: call}
}

// MockModelCloudNameCall wrap *gomock.Call
type MockModelCloudNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudNameCall) Return(arg0 string) *MockModelCloudNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudNameCall) Do(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudNameCall) DoAndReturn(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudRegion mocks base method.
func (m *MockModel) CloudRegion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudRegion")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudRegion indicates an expected call of CloudRegion.
func (mr *MockModelMockRecorder) CloudRegion() *MockModelCloudRegionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudRegion", reflect.TypeOf((*MockModel)(nil).CloudRegion))
	return &MockModelCloudRegionCall{Call: call}
}

// MockModelCloudRegionCall wrap *gomock.Call
type MockModelCloudRegionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudRegionCall) Return(arg0 string) *MockModelCloudRegionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudRegionCall) Do(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudRegionCall) DoAndReturn(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockModel) Config() (*config0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*config0.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Config indicates an expected call of Config.
func (mr *MockModelMockRecorder) Config() *MockModelConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockModel)(nil).Config))
	return &MockModelConfigCall{Call: call}
}

// MockModelConfigCall wrap *gomock.Call
type MockModelConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelConfigCall) Return(arg0 *config0.Config, arg1 error) *MockModelConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelConfigCall) Do(f func() (*config0.Config, error)) *MockModelConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelConfigCall) DoAndReturn(f func() (*config0.Config, error)) *MockModelConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ControllerUUID mocks base method.
func (m *MockModel) ControllerUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ControllerUUID indicates an expected call of ControllerUUID.
func (mr *MockModelMockRecorder) ControllerUUID() *MockModelControllerUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerUUID", reflect.TypeOf((*MockModel)(nil).ControllerUUID))
	return &MockModelControllerUUIDCall{Call: call}
}

// MockModelControllerUUIDCall wrap *gomock.Call
type MockModelControllerUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelControllerUUIDCall) Return(arg0 string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelControllerUUIDCall) Do(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelControllerUUIDCall) DoAndReturn(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelConfig mocks base method.
func (m *MockModel) ModelConfig(arg0 context.Context) (*config0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelConfig", arg0)
	ret0, _ := ret[0].(*config0.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelConfig indicates an expected call of ModelConfig.
func (mr *MockModelMockRecorder) ModelConfig(arg0 any) *MockModelModelConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelConfig", reflect.TypeOf((*MockModel)(nil).ModelConfig), arg0)
	return &MockModelModelConfigCall{Call: call}
}

// MockModelModelConfigCall wrap *gomock.Call
type MockModelModelConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelConfigCall) Return(arg0 *config0.Config, arg1 error) *MockModelModelConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelConfigCall) Do(f func(context.Context) (*config0.Config, error)) *MockModelModelConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelConfigCall) DoAndReturn(f func(context.Context) (*config0.Config, error)) *MockModelModelConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelTag mocks base method.
func (m *MockModel) ModelTag() names.ModelTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelTag")
	ret0, _ := ret[0].(names.ModelTag)
	return ret0
}

// ModelTag indicates an expected call of ModelTag.
func (mr *MockModelMockRecorder) ModelTag() *MockModelModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelTag", reflect.TypeOf((*MockModel)(nil).ModelTag))
	return &MockModelModelTagCall{Call: call}
}

// MockModelModelTagCall wrap *gomock.Call
type MockModelModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelTagCall) Return(arg0 names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelTagCall) Do(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelTagCall) DoAndReturn(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockModel) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockModelMockRecorder) Name() *MockModelNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockModel)(nil).Name))
	return &MockModelNameCall{Call: call}
}

// MockModelNameCall wrap *gomock.Call
type MockModelNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelNameCall) Return(arg0 string) *MockModelNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelNameCall) Do(f func() string) *MockModelNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelNameCall) DoAndReturn(f func() string) *MockModelNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenedPortRangesForMachine mocks base method.
func (m *MockModel) OpenedPortRangesForMachine(arg0 string) (state.MachinePortRanges, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenedPortRangesForMachine", arg0)
	ret0, _ := ret[0].(state.MachinePortRanges)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenedPortRangesForMachine indicates an expected call of OpenedPortRangesForMachine.
func (mr *MockModelMockRecorder) OpenedPortRangesForMachine(arg0 any) *MockModelOpenedPortRangesForMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenedPortRangesForMachine", reflect.TypeOf((*MockModel)(nil).OpenedPortRangesForMachine), arg0)
	return &MockModelOpenedPortRangesForMachineCall{Call: call}
}

// MockModelOpenedPortRangesForMachineCall wrap *gomock.Call
type MockModelOpenedPortRangesForMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelOpenedPortRangesForMachineCall) Return(arg0 state.MachinePortRanges, arg1 error) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelOpenedPortRangesForMachineCall) Do(f func(string) (state.MachinePortRanges, error)) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelOpenedPortRangesForMachineCall) DoAndReturn(f func(string) (state.MachinePortRanges, error)) *MockModelOpenedPortRangesForMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Owner mocks base method.
func (m *MockModel) Owner() names.UserTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Owner")
	ret0, _ := ret[0].(names.UserTag)
	return ret0
}

// Owner indicates an expected call of Owner.
func (mr *MockModelMockRecorder) Owner() *MockModelOwnerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Owner", reflect.TypeOf((*MockModel)(nil).Owner))
	return &MockModelOwnerCall{Call: call}
}

// MockModelOwnerCall wrap *gomock.Call
type MockModelOwnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelOwnerCall) Return(arg0 names.UserTag) *MockModelOwnerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelOwnerCall) Do(f func() names.UserTag) *MockModelOwnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelOwnerCall) DoAndReturn(f func() names.UserTag) *MockModelOwnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockModel) Tag() names.Tag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.Tag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockModelMockRecorder) Tag() *MockModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockModel)(nil).Tag))
	return &MockModelTagCall{Call: call}
}

// MockModelTagCall wrap *gomock.Call
type MockModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTagCall) Return(arg0 names.Tag) *MockModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTagCall) Do(f func() names.Tag) *MockModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTagCall) DoAndReturn(f func() names.Tag) *MockModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockModel) Type() state.ModelType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(state.ModelType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockModelMockRecorder) Type() *MockModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockModel)(nil).Type))
	return &MockModelTypeCall{Call: call}
}

// MockModelTypeCall wrap *gomock.Call
type MockModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTypeCall) Return(arg0 state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTypeCall) Do(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTypeCall) DoAndReturn(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UUID mocks base method.
func (m *MockModel) UUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// UUID indicates an expected call of UUID.
func (mr *MockModelMockRecorder) UUID() *MockModelUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UUID", reflect.TypeOf((*MockModel)(nil).UUID))
	return &MockModelUUIDCall{Call: call}
}

// MockModelUUIDCall wrap *gomock.Call
type MockModelUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelUUIDCall) Return(arg0 string) *MockModelUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelUUIDCall) Do(f func() string) *MockModelUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelUUIDCall) DoAndReturn(f func() string) *MockModelUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCaasBrokerInterface is a mock of CaasBrokerInterface interface.
type MockCaasBrokerInterface struct {
	ctrl     *gomock.Controller
	recorder *MockCaasBrokerInterfaceMockRecorder
}

// MockCaasBrokerInterfaceMockRecorder is the mock recorder for MockCaasBrokerInterface.
type MockCaasBrokerInterfaceMockRecorder struct {
	mock *MockCaasBrokerInterface
}

// NewMockCaasBrokerInterface creates a new mock instance.
func NewMockCaasBrokerInterface(ctrl *gomock.Controller) *MockCaasBrokerInterface {
	mock := &MockCaasBrokerInterface{ctrl: ctrl}
	mock.recorder = &MockCaasBrokerInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCaasBrokerInterface) EXPECT() *MockCaasBrokerInterfaceMockRecorder {
	return m.recorder
}

// ValidateStorageClass mocks base method.
func (m *MockCaasBrokerInterface) ValidateStorageClass(arg0 context.Context, arg1 map[string]any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateStorageClass", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateStorageClass indicates an expected call of ValidateStorageClass.
func (mr *MockCaasBrokerInterfaceMockRecorder) ValidateStorageClass(arg0, arg1 any) *MockCaasBrokerInterfaceValidateStorageClassCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateStorageClass", reflect.TypeOf((*MockCaasBrokerInterface)(nil).ValidateStorageClass), arg0, arg1)
	return &MockCaasBrokerInterfaceValidateStorageClassCall{Call: call}
}

// MockCaasBrokerInterfaceValidateStorageClassCall wrap *gomock.Call
type MockCaasBrokerInterfaceValidateStorageClassCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCaasBrokerInterfaceValidateStorageClassCall) Return(arg0 error) *MockCaasBrokerInterfaceValidateStorageClassCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCaasBrokerInterfaceValidateStorageClassCall) Do(f func(context.Context, map[string]any) error) *MockCaasBrokerInterfaceValidateStorageClassCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCaasBrokerInterfaceValidateStorageClassCall) DoAndReturn(f func(context.Context, map[string]any) error) *MockCaasBrokerInterfaceValidateStorageClassCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Version mocks base method.
func (m *MockCaasBrokerInterface) Version() (*version.Number, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Version")
	ret0, _ := ret[0].(*version.Number)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Version indicates an expected call of Version.
func (mr *MockCaasBrokerInterfaceMockRecorder) Version() *MockCaasBrokerInterfaceVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Version", reflect.TypeOf((*MockCaasBrokerInterface)(nil).Version))
	return &MockCaasBrokerInterfaceVersionCall{Call: call}
}

// MockCaasBrokerInterfaceVersionCall wrap *gomock.Call
type MockCaasBrokerInterfaceVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCaasBrokerInterfaceVersionCall) Return(arg0 *version.Number, arg1 error) *MockCaasBrokerInterfaceVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCaasBrokerInterfaceVersionCall) Do(f func() (*version.Number, error)) *MockCaasBrokerInterfaceVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCaasBrokerInterfaceVersionCall) DoAndReturn(f func() (*version.Number, error)) *MockCaasBrokerInterfaceVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockApplication is a mock of Application interface.
type MockApplication struct {
	ctrl     *gomock.Controller
	recorder *MockApplicationMockRecorder
}

// MockApplicationMockRecorder is the mock recorder for MockApplication.
type MockApplicationMockRecorder struct {
	mock *MockApplication
}

// NewMockApplication creates a new mock instance.
func NewMockApplication(ctrl *gomock.Controller) *MockApplication {
	mock := &MockApplication{ctrl: ctrl}
	mock.recorder = &MockApplicationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplication) EXPECT() *MockApplicationMockRecorder {
	return m.recorder
}

// AddUnit mocks base method.
func (m *MockApplication) AddUnit(arg0 state.AddUnitParams) (application.Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddUnit", arg0)
	ret0, _ := ret[0].(application.Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddUnit indicates an expected call of AddUnit.
func (mr *MockApplicationMockRecorder) AddUnit(arg0 any) *MockApplicationAddUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUnit", reflect.TypeOf((*MockApplication)(nil).AddUnit), arg0)
	return &MockApplicationAddUnitCall{Call: call}
}

// MockApplicationAddUnitCall wrap *gomock.Call
type MockApplicationAddUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationAddUnitCall) Return(arg0 application.Unit, arg1 error) *MockApplicationAddUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationAddUnitCall) Do(f func(state.AddUnitParams) (application.Unit, error)) *MockApplicationAddUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationAddUnitCall) DoAndReturn(f func(state.AddUnitParams) (application.Unit, error)) *MockApplicationAddUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AgentTools mocks base method.
func (m *MockApplication) AgentTools() (*tools.Tools, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AgentTools")
	ret0, _ := ret[0].(*tools.Tools)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AgentTools indicates an expected call of AgentTools.
func (mr *MockApplicationMockRecorder) AgentTools() *MockApplicationAgentToolsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AgentTools", reflect.TypeOf((*MockApplication)(nil).AgentTools))
	return &MockApplicationAgentToolsCall{Call: call}
}

// MockApplicationAgentToolsCall wrap *gomock.Call
type MockApplicationAgentToolsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationAgentToolsCall) Return(arg0 *tools.Tools, arg1 error) *MockApplicationAgentToolsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationAgentToolsCall) Do(f func() (*tools.Tools, error)) *MockApplicationAgentToolsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationAgentToolsCall) DoAndReturn(f func() (*tools.Tools, error)) *MockApplicationAgentToolsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AllUnits mocks base method.
func (m *MockApplication) AllUnits() ([]application.Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllUnits")
	ret0, _ := ret[0].([]application.Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllUnits indicates an expected call of AllUnits.
func (mr *MockApplicationMockRecorder) AllUnits() *MockApplicationAllUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllUnits", reflect.TypeOf((*MockApplication)(nil).AllUnits))
	return &MockApplicationAllUnitsCall{Call: call}
}

// MockApplicationAllUnitsCall wrap *gomock.Call
type MockApplicationAllUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationAllUnitsCall) Return(arg0 []application.Unit, arg1 error) *MockApplicationAllUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationAllUnitsCall) Do(f func() ([]application.Unit, error)) *MockApplicationAllUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationAllUnitsCall) DoAndReturn(f func() ([]application.Unit, error)) *MockApplicationAllUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationConfig mocks base method.
func (m *MockApplication) ApplicationConfig() (config.ConfigAttributes, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationConfig")
	ret0, _ := ret[0].(config.ConfigAttributes)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplicationConfig indicates an expected call of ApplicationConfig.
func (mr *MockApplicationMockRecorder) ApplicationConfig() *MockApplicationApplicationConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationConfig", reflect.TypeOf((*MockApplication)(nil).ApplicationConfig))
	return &MockApplicationApplicationConfigCall{Call: call}
}

// MockApplicationApplicationConfigCall wrap *gomock.Call
type MockApplicationApplicationConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationApplicationConfigCall) Return(arg0 config.ConfigAttributes, arg1 error) *MockApplicationApplicationConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationApplicationConfigCall) Do(f func() (config.ConfigAttributes, error)) *MockApplicationApplicationConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationApplicationConfigCall) DoAndReturn(f func() (config.ConfigAttributes, error)) *MockApplicationApplicationConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationTag mocks base method.
func (m *MockApplication) ApplicationTag() names.ApplicationTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationTag")
	ret0, _ := ret[0].(names.ApplicationTag)
	return ret0
}

// ApplicationTag indicates an expected call of ApplicationTag.
func (mr *MockApplicationMockRecorder) ApplicationTag() *MockApplicationApplicationTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationTag", reflect.TypeOf((*MockApplication)(nil).ApplicationTag))
	return &MockApplicationApplicationTagCall{Call: call}
}

// MockApplicationApplicationTagCall wrap *gomock.Call
type MockApplicationApplicationTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationApplicationTagCall) Return(arg0 names.ApplicationTag) *MockApplicationApplicationTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationApplicationTagCall) Do(f func() names.ApplicationTag) *MockApplicationApplicationTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationApplicationTagCall) DoAndReturn(f func() names.ApplicationTag) *MockApplicationApplicationTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ChangeScale mocks base method.
func (m *MockApplication) ChangeScale(arg0 int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeScale", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChangeScale indicates an expected call of ChangeScale.
func (mr *MockApplicationMockRecorder) ChangeScale(arg0 any) *MockApplicationChangeScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeScale", reflect.TypeOf((*MockApplication)(nil).ChangeScale), arg0)
	return &MockApplicationChangeScaleCall{Call: call}
}

// MockApplicationChangeScaleCall wrap *gomock.Call
type MockApplicationChangeScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationChangeScaleCall) Return(arg0 int, arg1 error) *MockApplicationChangeScaleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationChangeScaleCall) Do(f func(int) (int, error)) *MockApplicationChangeScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationChangeScaleCall) DoAndReturn(f func(int) (int, error)) *MockApplicationChangeScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Charm mocks base method.
func (m *MockApplication) Charm() (application.Charm, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm")
	ret0, _ := ret[0].(application.Charm)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Charm indicates an expected call of Charm.
func (mr *MockApplicationMockRecorder) Charm() *MockApplicationCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockApplication)(nil).Charm))
	return &MockApplicationCharmCall{Call: call}
}

// MockApplicationCharmCall wrap *gomock.Call
type MockApplicationCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmCall) Return(arg0 application.Charm, arg1 bool, arg2 error) *MockApplicationCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmCall) Do(f func() (application.Charm, bool, error)) *MockApplicationCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmCall) DoAndReturn(f func() (application.Charm, bool, error)) *MockApplicationCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmConfig mocks base method.
func (m *MockApplication) CharmConfig(arg0 string) (charm.Settings, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmConfig", arg0)
	ret0, _ := ret[0].(charm.Settings)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CharmConfig indicates an expected call of CharmConfig.
func (mr *MockApplicationMockRecorder) CharmConfig(arg0 any) *MockApplicationCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmConfig", reflect.TypeOf((*MockApplication)(nil).CharmConfig), arg0)
	return &MockApplicationCharmConfigCall{Call: call}
}

// MockApplicationCharmConfigCall wrap *gomock.Call
type MockApplicationCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmConfigCall) Return(arg0 charm.Settings, arg1 error) *MockApplicationCharmConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmConfigCall) Do(f func(string) (charm.Settings, error)) *MockApplicationCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmConfigCall) DoAndReturn(f func(string) (charm.Settings, error)) *MockApplicationCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmOrigin mocks base method.
func (m *MockApplication) CharmOrigin() *state.CharmOrigin {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmOrigin")
	ret0, _ := ret[0].(*state.CharmOrigin)
	return ret0
}

// CharmOrigin indicates an expected call of CharmOrigin.
func (mr *MockApplicationMockRecorder) CharmOrigin() *MockApplicationCharmOriginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmOrigin", reflect.TypeOf((*MockApplication)(nil).CharmOrigin))
	return &MockApplicationCharmOriginCall{Call: call}
}

// MockApplicationCharmOriginCall wrap *gomock.Call
type MockApplicationCharmOriginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmOriginCall) Return(arg0 *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmOriginCall) Do(f func() *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmOriginCall) DoAndReturn(f func() *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmURL mocks base method.
func (m *MockApplication) CharmURL() (*string, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmURL")
	ret0, _ := ret[0].(*string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CharmURL indicates an expected call of CharmURL.
func (mr *MockApplicationMockRecorder) CharmURL() *MockApplicationCharmURLCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmURL", reflect.TypeOf((*MockApplication)(nil).CharmURL))
	return &MockApplicationCharmURLCall{Call: call}
}

// MockApplicationCharmURLCall wrap *gomock.Call
type MockApplicationCharmURLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmURLCall) Return(arg0 *string, arg1 bool) *MockApplicationCharmURLCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmURLCall) Do(f func() (*string, bool)) *MockApplicationCharmURLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmURLCall) DoAndReturn(f func() (*string, bool)) *MockApplicationCharmURLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClearExposed mocks base method.
func (m *MockApplication) ClearExposed() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClearExposed")
	ret0, _ := ret[0].(error)
	return ret0
}

// ClearExposed indicates an expected call of ClearExposed.
func (mr *MockApplicationMockRecorder) ClearExposed() *MockApplicationClearExposedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearExposed", reflect.TypeOf((*MockApplication)(nil).ClearExposed))
	return &MockApplicationClearExposedCall{Call: call}
}

// MockApplicationClearExposedCall wrap *gomock.Call
type MockApplicationClearExposedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationClearExposedCall) Return(arg0 error) *MockApplicationClearExposedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationClearExposedCall) Do(f func() error) *MockApplicationClearExposedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationClearExposedCall) DoAndReturn(f func() error) *MockApplicationClearExposedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Constraints mocks base method.
func (m *MockApplication) Constraints() (constraints.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Constraints")
	ret0, _ := ret[0].(constraints.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Constraints indicates an expected call of Constraints.
func (mr *MockApplicationMockRecorder) Constraints() *MockApplicationConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Constraints", reflect.TypeOf((*MockApplication)(nil).Constraints))
	return &MockApplicationConstraintsCall{Call: call}
}

// MockApplicationConstraintsCall wrap *gomock.Call
type MockApplicationConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationConstraintsCall) Return(arg0 constraints.Value, arg1 error) *MockApplicationConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationConstraintsCall) Do(f func() (constraints.Value, error)) *MockApplicationConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationConstraintsCall) DoAndReturn(f func() (constraints.Value, error)) *MockApplicationConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Destroy mocks base method.
func (m *MockApplication) Destroy(arg0 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockApplicationMockRecorder) Destroy(arg0 any) *MockApplicationDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockApplication)(nil).Destroy), arg0)
	return &MockApplicationDestroyCall{Call: call}
}

// MockApplicationDestroyCall wrap *gomock.Call
type MockApplicationDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationDestroyCall) Return(arg0 error) *MockApplicationDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationDestroyCall) Do(f func(objectstore.ObjectStore) error) *MockApplicationDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationDestroyCall) DoAndReturn(f func(objectstore.ObjectStore) error) *MockApplicationDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DestroyOperation mocks base method.
func (m *MockApplication) DestroyOperation(arg0 objectstore.ObjectStore) *state.DestroyApplicationOperation {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyOperation", arg0)
	ret0, _ := ret[0].(*state.DestroyApplicationOperation)
	return ret0
}

// DestroyOperation indicates an expected call of DestroyOperation.
func (mr *MockApplicationMockRecorder) DestroyOperation(arg0 any) *MockApplicationDestroyOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyOperation", reflect.TypeOf((*MockApplication)(nil).DestroyOperation), arg0)
	return &MockApplicationDestroyOperationCall{Call: call}
}

// MockApplicationDestroyOperationCall wrap *gomock.Call
type MockApplicationDestroyOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationDestroyOperationCall) Return(arg0 *state.DestroyApplicationOperation) *MockApplicationDestroyOperationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationDestroyOperationCall) Do(f func(objectstore.ObjectStore) *state.DestroyApplicationOperation) *MockApplicationDestroyOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationDestroyOperationCall) DoAndReturn(f func(objectstore.ObjectStore) *state.DestroyApplicationOperation) *MockApplicationDestroyOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EndpointBindings mocks base method.
func (m *MockApplication) EndpointBindings() (application.Bindings, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EndpointBindings")
	ret0, _ := ret[0].(application.Bindings)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EndpointBindings indicates an expected call of EndpointBindings.
func (mr *MockApplicationMockRecorder) EndpointBindings() *MockApplicationEndpointBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndpointBindings", reflect.TypeOf((*MockApplication)(nil).EndpointBindings))
	return &MockApplicationEndpointBindingsCall{Call: call}
}

// MockApplicationEndpointBindingsCall wrap *gomock.Call
type MockApplicationEndpointBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationEndpointBindingsCall) Return(arg0 application.Bindings, arg1 error) *MockApplicationEndpointBindingsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationEndpointBindingsCall) Do(f func() (application.Bindings, error)) *MockApplicationEndpointBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationEndpointBindingsCall) DoAndReturn(f func() (application.Bindings, error)) *MockApplicationEndpointBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Endpoints mocks base method.
func (m *MockApplication) Endpoints() ([]state.Endpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Endpoints")
	ret0, _ := ret[0].([]state.Endpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Endpoints indicates an expected call of Endpoints.
func (mr *MockApplicationMockRecorder) Endpoints() *MockApplicationEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoints", reflect.TypeOf((*MockApplication)(nil).Endpoints))
	return &MockApplicationEndpointsCall{Call: call}
}

// MockApplicationEndpointsCall wrap *gomock.Call
type MockApplicationEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationEndpointsCall) Return(arg0 []state.Endpoint, arg1 error) *MockApplicationEndpointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationEndpointsCall) Do(f func() ([]state.Endpoint, error)) *MockApplicationEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationEndpointsCall) DoAndReturn(f func() ([]state.Endpoint, error)) *MockApplicationEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExposedEndpoints mocks base method.
func (m *MockApplication) ExposedEndpoints() map[string]state.ExposedEndpoint {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExposedEndpoints")
	ret0, _ := ret[0].(map[string]state.ExposedEndpoint)
	return ret0
}

// ExposedEndpoints indicates an expected call of ExposedEndpoints.
func (mr *MockApplicationMockRecorder) ExposedEndpoints() *MockApplicationExposedEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExposedEndpoints", reflect.TypeOf((*MockApplication)(nil).ExposedEndpoints))
	return &MockApplicationExposedEndpointsCall{Call: call}
}

// MockApplicationExposedEndpointsCall wrap *gomock.Call
type MockApplicationExposedEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationExposedEndpointsCall) Return(arg0 map[string]state.ExposedEndpoint) *MockApplicationExposedEndpointsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationExposedEndpointsCall) Do(f func() map[string]state.ExposedEndpoint) *MockApplicationExposedEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationExposedEndpointsCall) DoAndReturn(f func() map[string]state.ExposedEndpoint) *MockApplicationExposedEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsExposed mocks base method.
func (m *MockApplication) IsExposed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsExposed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsExposed indicates an expected call of IsExposed.
func (mr *MockApplicationMockRecorder) IsExposed() *MockApplicationIsExposedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsExposed", reflect.TypeOf((*MockApplication)(nil).IsExposed))
	return &MockApplicationIsExposedCall{Call: call}
}

// MockApplicationIsExposedCall wrap *gomock.Call
type MockApplicationIsExposedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationIsExposedCall) Return(arg0 bool) *MockApplicationIsExposedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationIsExposedCall) Do(f func() bool) *MockApplicationIsExposedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationIsExposedCall) DoAndReturn(f func() bool) *MockApplicationIsExposedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPrincipal mocks base method.
func (m *MockApplication) IsPrincipal() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPrincipal")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPrincipal indicates an expected call of IsPrincipal.
func (mr *MockApplicationMockRecorder) IsPrincipal() *MockApplicationIsPrincipalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPrincipal", reflect.TypeOf((*MockApplication)(nil).IsPrincipal))
	return &MockApplicationIsPrincipalCall{Call: call}
}

// MockApplicationIsPrincipalCall wrap *gomock.Call
type MockApplicationIsPrincipalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationIsPrincipalCall) Return(arg0 bool) *MockApplicationIsPrincipalCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationIsPrincipalCall) Do(f func() bool) *MockApplicationIsPrincipalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationIsPrincipalCall) DoAndReturn(f func() bool) *MockApplicationIsPrincipalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsRemote mocks base method.
func (m *MockApplication) IsRemote() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRemote")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRemote indicates an expected call of IsRemote.
func (mr *MockApplicationMockRecorder) IsRemote() *MockApplicationIsRemoteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRemote", reflect.TypeOf((*MockApplication)(nil).IsRemote))
	return &MockApplicationIsRemoteCall{Call: call}
}

// MockApplicationIsRemoteCall wrap *gomock.Call
type MockApplicationIsRemoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationIsRemoteCall) Return(arg0 bool) *MockApplicationIsRemoteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationIsRemoteCall) Do(f func() bool) *MockApplicationIsRemoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationIsRemoteCall) DoAndReturn(f func() bool) *MockApplicationIsRemoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Life mocks base method.
func (m *MockApplication) Life() state.Life {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Life")
	ret0, _ := ret[0].(state.Life)
	return ret0
}

// Life indicates an expected call of Life.
func (mr *MockApplicationMockRecorder) Life() *MockApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Life", reflect.TypeOf((*MockApplication)(nil).Life))
	return &MockApplicationLifeCall{Call: call}
}

// MockApplicationLifeCall wrap *gomock.Call
type MockApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationLifeCall) Return(arg0 state.Life) *MockApplicationLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationLifeCall) Do(f func() state.Life) *MockApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationLifeCall) DoAndReturn(f func() state.Life) *MockApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeBindings mocks base method.
func (m *MockApplication) MergeBindings(arg0 *state.Bindings, arg1 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeBindings", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// MergeBindings indicates an expected call of MergeBindings.
func (mr *MockApplicationMockRecorder) MergeBindings(arg0, arg1 any) *MockApplicationMergeBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeBindings", reflect.TypeOf((*MockApplication)(nil).MergeBindings), arg0, arg1)
	return &MockApplicationMergeBindingsCall{Call: call}
}

// MockApplicationMergeBindingsCall wrap *gomock.Call
type MockApplicationMergeBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationMergeBindingsCall) Return(arg0 error) *MockApplicationMergeBindingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationMergeBindingsCall) Do(f func(*state.Bindings, bool) error) *MockApplicationMergeBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationMergeBindingsCall) DoAndReturn(f func(*state.Bindings, bool) error) *MockApplicationMergeBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeExposeSettings mocks base method.
func (m *MockApplication) MergeExposeSettings(arg0 map[string]state.ExposedEndpoint) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeExposeSettings", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// MergeExposeSettings indicates an expected call of MergeExposeSettings.
func (mr *MockApplicationMockRecorder) MergeExposeSettings(arg0 any) *MockApplicationMergeExposeSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeExposeSettings", reflect.TypeOf((*MockApplication)(nil).MergeExposeSettings), arg0)
	return &MockApplicationMergeExposeSettingsCall{Call: call}
}

// MockApplicationMergeExposeSettingsCall wrap *gomock.Call
type MockApplicationMergeExposeSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationMergeExposeSettingsCall) Return(arg0 error) *MockApplicationMergeExposeSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationMergeExposeSettingsCall) Do(f func(map[string]state.ExposedEndpoint) error) *MockApplicationMergeExposeSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationMergeExposeSettingsCall) DoAndReturn(f func(map[string]state.ExposedEndpoint) error) *MockApplicationMergeExposeSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockApplication) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockApplicationMockRecorder) Name() *MockApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockApplication)(nil).Name))
	return &MockApplicationNameCall{Call: call}
}

// MockApplicationNameCall wrap *gomock.Call
type MockApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationNameCall) Return(arg0 string) *MockApplicationNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationNameCall) Do(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationNameCall) DoAndReturn(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Relations mocks base method.
func (m *MockApplication) Relations() ([]application.Relation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Relations")
	ret0, _ := ret[0].([]application.Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Relations indicates an expected call of Relations.
func (mr *MockApplicationMockRecorder) Relations() *MockApplicationRelationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Relations", reflect.TypeOf((*MockApplication)(nil).Relations))
	return &MockApplicationRelationsCall{Call: call}
}

// MockApplicationRelationsCall wrap *gomock.Call
type MockApplicationRelationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationRelationsCall) Return(arg0 []application.Relation, arg1 error) *MockApplicationRelationsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationRelationsCall) Do(f func() ([]application.Relation, error)) *MockApplicationRelationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationRelationsCall) DoAndReturn(f func() ([]application.Relation, error)) *MockApplicationRelationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharm mocks base method.
func (m *MockApplication) SetCharm(arg0 state.SetCharmConfig, arg1 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharm", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCharm indicates an expected call of SetCharm.
func (mr *MockApplicationMockRecorder) SetCharm(arg0, arg1 any) *MockApplicationSetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharm", reflect.TypeOf((*MockApplication)(nil).SetCharm), arg0, arg1)
	return &MockApplicationSetCharmCall{Call: call}
}

// MockApplicationSetCharmCall wrap *gomock.Call
type MockApplicationSetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetCharmCall) Return(arg0 error) *MockApplicationSetCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetCharmCall) Do(f func(state.SetCharmConfig, objectstore.ObjectStore) error) *MockApplicationSetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetCharmCall) DoAndReturn(f func(state.SetCharmConfig, objectstore.ObjectStore) error) *MockApplicationSetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetConstraints mocks base method.
func (m *MockApplication) SetConstraints(arg0 constraints.Value) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetConstraints", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetConstraints indicates an expected call of SetConstraints.
func (mr *MockApplicationMockRecorder) SetConstraints(arg0 any) *MockApplicationSetConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConstraints", reflect.TypeOf((*MockApplication)(nil).SetConstraints), arg0)
	return &MockApplicationSetConstraintsCall{Call: call}
}

// MockApplicationSetConstraintsCall wrap *gomock.Call
type MockApplicationSetConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetConstraintsCall) Return(arg0 error) *MockApplicationSetConstraintsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetConstraintsCall) Do(f func(constraints.Value) error) *MockApplicationSetConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetConstraintsCall) DoAndReturn(f func(constraints.Value) error) *MockApplicationSetConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetMinUnits mocks base method.
func (m *MockApplication) SetMinUnits(arg0 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetMinUnits", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetMinUnits indicates an expected call of SetMinUnits.
func (mr *MockApplicationMockRecorder) SetMinUnits(arg0 any) *MockApplicationSetMinUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMinUnits", reflect.TypeOf((*MockApplication)(nil).SetMinUnits), arg0)
	return &MockApplicationSetMinUnitsCall{Call: call}
}

// MockApplicationSetMinUnitsCall wrap *gomock.Call
type MockApplicationSetMinUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetMinUnitsCall) Return(arg0 error) *MockApplicationSetMinUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetMinUnitsCall) Do(f func(int) error) *MockApplicationSetMinUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetMinUnitsCall) DoAndReturn(f func(int) error) *MockApplicationSetMinUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetScale mocks base method.
func (m *MockApplication) SetScale(arg0 int, arg1 int64, arg2 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetScale", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetScale indicates an expected call of SetScale.
func (mr *MockApplicationMockRecorder) SetScale(arg0, arg1, arg2 any) *MockApplicationSetScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetScale", reflect.TypeOf((*MockApplication)(nil).SetScale), arg0, arg1, arg2)
	return &MockApplicationSetScaleCall{Call: call}
}

// MockApplicationSetScaleCall wrap *gomock.Call
type MockApplicationSetScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationSetScaleCall) Return(arg0 error) *MockApplicationSetScaleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationSetScaleCall) Do(f func(int, int64, bool) error) *MockApplicationSetScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationSetScaleCall) DoAndReturn(f func(int, int64, bool) error) *MockApplicationSetScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsetExposeSettings mocks base method.
func (m *MockApplication) UnsetExposeSettings(arg0 []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnsetExposeSettings", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnsetExposeSettings indicates an expected call of UnsetExposeSettings.
func (mr *MockApplicationMockRecorder) UnsetExposeSettings(arg0 any) *MockApplicationUnsetExposeSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsetExposeSettings", reflect.TypeOf((*MockApplication)(nil).UnsetExposeSettings), arg0)
	return &MockApplicationUnsetExposeSettingsCall{Call: call}
}

// MockApplicationUnsetExposeSettingsCall wrap *gomock.Call
type MockApplicationUnsetExposeSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUnsetExposeSettingsCall) Return(arg0 error) *MockApplicationUnsetExposeSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUnsetExposeSettingsCall) Do(f func([]string) error) *MockApplicationUnsetExposeSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUnsetExposeSettingsCall) DoAndReturn(f func([]string) error) *MockApplicationUnsetExposeSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateApplicationBase mocks base method.
func (m *MockApplication) UpdateApplicationBase(arg0 state.Base, arg1 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateApplicationBase", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateApplicationBase indicates an expected call of UpdateApplicationBase.
func (mr *MockApplicationMockRecorder) UpdateApplicationBase(arg0, arg1 any) *MockApplicationUpdateApplicationBaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateApplicationBase", reflect.TypeOf((*MockApplication)(nil).UpdateApplicationBase), arg0, arg1)
	return &MockApplicationUpdateApplicationBaseCall{Call: call}
}

// MockApplicationUpdateApplicationBaseCall wrap *gomock.Call
type MockApplicationUpdateApplicationBaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUpdateApplicationBaseCall) Return(arg0 error) *MockApplicationUpdateApplicationBaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUpdateApplicationBaseCall) Do(f func(state.Base, bool) error) *MockApplicationUpdateApplicationBaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUpdateApplicationBaseCall) DoAndReturn(f func(state.Base, bool) error) *MockApplicationUpdateApplicationBaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateApplicationConfig mocks base method.
func (m *MockApplication) UpdateApplicationConfig(arg0 config.ConfigAttributes, arg1 []string, arg2 environschema.Fields, arg3 schema.Defaults) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateApplicationConfig", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateApplicationConfig indicates an expected call of UpdateApplicationConfig.
func (mr *MockApplicationMockRecorder) UpdateApplicationConfig(arg0, arg1, arg2, arg3 any) *MockApplicationUpdateApplicationConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateApplicationConfig", reflect.TypeOf((*MockApplication)(nil).UpdateApplicationConfig), arg0, arg1, arg2, arg3)
	return &MockApplicationUpdateApplicationConfigCall{Call: call}
}

// MockApplicationUpdateApplicationConfigCall wrap *gomock.Call
type MockApplicationUpdateApplicationConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUpdateApplicationConfigCall) Return(arg0 error) *MockApplicationUpdateApplicationConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUpdateApplicationConfigCall) Do(f func(config.ConfigAttributes, []string, environschema.Fields, schema.Defaults) error) *MockApplicationUpdateApplicationConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUpdateApplicationConfigCall) DoAndReturn(f func(config.ConfigAttributes, []string, environschema.Fields, schema.Defaults) error) *MockApplicationUpdateApplicationConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateCharmConfig mocks base method.
func (m *MockApplication) UpdateCharmConfig(arg0 string, arg1 charm.Settings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateCharmConfig", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateCharmConfig indicates an expected call of UpdateCharmConfig.
func (mr *MockApplicationMockRecorder) UpdateCharmConfig(arg0, arg1 any) *MockApplicationUpdateCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCharmConfig", reflect.TypeOf((*MockApplication)(nil).UpdateCharmConfig), arg0, arg1)
	return &MockApplicationUpdateCharmConfigCall{Call: call}
}

// MockApplicationUpdateCharmConfigCall wrap *gomock.Call
type MockApplicationUpdateCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationUpdateCharmConfigCall) Return(arg0 error) *MockApplicationUpdateCharmConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationUpdateCharmConfigCall) Do(f func(string, charm.Settings) error) *MockApplicationUpdateCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationUpdateCharmConfigCall) DoAndReturn(f func(string, charm.Settings) error) *MockApplicationUpdateCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRemoteApplication is a mock of RemoteApplication interface.
type MockRemoteApplication struct {
	ctrl     *gomock.Controller
	recorder *MockRemoteApplicationMockRecorder
}

// MockRemoteApplicationMockRecorder is the mock recorder for MockRemoteApplication.
type MockRemoteApplicationMockRecorder struct {
	mock *MockRemoteApplication
}

// NewMockRemoteApplication creates a new mock instance.
func NewMockRemoteApplication(ctrl *gomock.Controller) *MockRemoteApplication {
	mock := &MockRemoteApplication{ctrl: ctrl}
	mock.recorder = &MockRemoteApplicationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRemoteApplication) EXPECT() *MockRemoteApplicationMockRecorder {
	return m.recorder
}

// AddEndpoints mocks base method.
func (m *MockRemoteApplication) AddEndpoints(arg0 []charm.Relation) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddEndpoints", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddEndpoints indicates an expected call of AddEndpoints.
func (mr *MockRemoteApplicationMockRecorder) AddEndpoints(arg0 any) *MockRemoteApplicationAddEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEndpoints", reflect.TypeOf((*MockRemoteApplication)(nil).AddEndpoints), arg0)
	return &MockRemoteApplicationAddEndpointsCall{Call: call}
}

// MockRemoteApplicationAddEndpointsCall wrap *gomock.Call
type MockRemoteApplicationAddEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationAddEndpointsCall) Return(arg0 error) *MockRemoteApplicationAddEndpointsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationAddEndpointsCall) Do(f func([]charm.Relation) error) *MockRemoteApplicationAddEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationAddEndpointsCall) DoAndReturn(f func([]charm.Relation) error) *MockRemoteApplicationAddEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Destroy mocks base method.
func (m *MockRemoteApplication) Destroy() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy")
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockRemoteApplicationMockRecorder) Destroy() *MockRemoteApplicationDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockRemoteApplication)(nil).Destroy))
	return &MockRemoteApplicationDestroyCall{Call: call}
}

// MockRemoteApplicationDestroyCall wrap *gomock.Call
type MockRemoteApplicationDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationDestroyCall) Return(arg0 error) *MockRemoteApplicationDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationDestroyCall) Do(f func() error) *MockRemoteApplicationDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationDestroyCall) DoAndReturn(f func() error) *MockRemoteApplicationDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DestroyOperation mocks base method.
func (m *MockRemoteApplication) DestroyOperation(arg0 bool) *state.DestroyRemoteApplicationOperation {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyOperation", arg0)
	ret0, _ := ret[0].(*state.DestroyRemoteApplicationOperation)
	return ret0
}

// DestroyOperation indicates an expected call of DestroyOperation.
func (mr *MockRemoteApplicationMockRecorder) DestroyOperation(arg0 any) *MockRemoteApplicationDestroyOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyOperation", reflect.TypeOf((*MockRemoteApplication)(nil).DestroyOperation), arg0)
	return &MockRemoteApplicationDestroyOperationCall{Call: call}
}

// MockRemoteApplicationDestroyOperationCall wrap *gomock.Call
type MockRemoteApplicationDestroyOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationDestroyOperationCall) Return(arg0 *state.DestroyRemoteApplicationOperation) *MockRemoteApplicationDestroyOperationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationDestroyOperationCall) Do(f func(bool) *state.DestroyRemoteApplicationOperation) *MockRemoteApplicationDestroyOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationDestroyOperationCall) DoAndReturn(f func(bool) *state.DestroyRemoteApplicationOperation) *MockRemoteApplicationDestroyOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Endpoints mocks base method.
func (m *MockRemoteApplication) Endpoints() ([]state.Endpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Endpoints")
	ret0, _ := ret[0].([]state.Endpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Endpoints indicates an expected call of Endpoints.
func (mr *MockRemoteApplicationMockRecorder) Endpoints() *MockRemoteApplicationEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoints", reflect.TypeOf((*MockRemoteApplication)(nil).Endpoints))
	return &MockRemoteApplicationEndpointsCall{Call: call}
}

// MockRemoteApplicationEndpointsCall wrap *gomock.Call
type MockRemoteApplicationEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationEndpointsCall) Return(arg0 []state.Endpoint, arg1 error) *MockRemoteApplicationEndpointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationEndpointsCall) Do(f func() ([]state.Endpoint, error)) *MockRemoteApplicationEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationEndpointsCall) DoAndReturn(f func() ([]state.Endpoint, error)) *MockRemoteApplicationEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Life mocks base method.
func (m *MockRemoteApplication) Life() state.Life {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Life")
	ret0, _ := ret[0].(state.Life)
	return ret0
}

// Life indicates an expected call of Life.
func (mr *MockRemoteApplicationMockRecorder) Life() *MockRemoteApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Life", reflect.TypeOf((*MockRemoteApplication)(nil).Life))
	return &MockRemoteApplicationLifeCall{Call: call}
}

// MockRemoteApplicationLifeCall wrap *gomock.Call
type MockRemoteApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationLifeCall) Return(arg0 state.Life) *MockRemoteApplicationLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationLifeCall) Do(f func() state.Life) *MockRemoteApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationLifeCall) DoAndReturn(f func() state.Life) *MockRemoteApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockRemoteApplication) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockRemoteApplicationMockRecorder) Name() *MockRemoteApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockRemoteApplication)(nil).Name))
	return &MockRemoteApplicationNameCall{Call: call}
}

// MockRemoteApplicationNameCall wrap *gomock.Call
type MockRemoteApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationNameCall) Return(arg0 string) *MockRemoteApplicationNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationNameCall) Do(f func() string) *MockRemoteApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationNameCall) DoAndReturn(f func() string) *MockRemoteApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SourceModel mocks base method.
func (m *MockRemoteApplication) SourceModel() names.ModelTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SourceModel")
	ret0, _ := ret[0].(names.ModelTag)
	return ret0
}

// SourceModel indicates an expected call of SourceModel.
func (mr *MockRemoteApplicationMockRecorder) SourceModel() *MockRemoteApplicationSourceModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SourceModel", reflect.TypeOf((*MockRemoteApplication)(nil).SourceModel))
	return &MockRemoteApplicationSourceModelCall{Call: call}
}

// MockRemoteApplicationSourceModelCall wrap *gomock.Call
type MockRemoteApplicationSourceModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationSourceModelCall) Return(arg0 names.ModelTag) *MockRemoteApplicationSourceModelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationSourceModelCall) Do(f func() names.ModelTag) *MockRemoteApplicationSourceModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationSourceModelCall) DoAndReturn(f func() names.ModelTag) *MockRemoteApplicationSourceModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockRemoteApplication) Status() (status.StatusInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(status.StatusInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Status indicates an expected call of Status.
func (mr *MockRemoteApplicationMockRecorder) Status() *MockRemoteApplicationStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockRemoteApplication)(nil).Status))
	return &MockRemoteApplicationStatusCall{Call: call}
}

// MockRemoteApplicationStatusCall wrap *gomock.Call
type MockRemoteApplicationStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRemoteApplicationStatusCall) Return(arg0 status.StatusInfo, arg1 error) *MockRemoteApplicationStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRemoteApplicationStatusCall) Do(f func() (status.StatusInfo, error)) *MockRemoteApplicationStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRemoteApplicationStatusCall) DoAndReturn(f func() (status.StatusInfo, error)) *MockRemoteApplicationStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharm is a mock of Charm interface.
type MockCharm struct {
	ctrl     *gomock.Controller
	recorder *MockCharmMockRecorder
}

// MockCharmMockRecorder is the mock recorder for MockCharm.
type MockCharmMockRecorder struct {
	mock *MockCharm
}

// NewMockCharm creates a new mock instance.
func NewMockCharm(ctrl *gomock.Controller) *MockCharm {
	mock := &MockCharm{ctrl: ctrl}
	mock.recorder = &MockCharmMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharm) EXPECT() *MockCharmMockRecorder {
	return m.recorder
}

// Actions mocks base method.
func (m *MockCharm) Actions() *charm.Actions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Actions")
	ret0, _ := ret[0].(*charm.Actions)
	return ret0
}

// Actions indicates an expected call of Actions.
func (mr *MockCharmMockRecorder) Actions() *MockCharmActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Actions", reflect.TypeOf((*MockCharm)(nil).Actions))
	return &MockCharmActionsCall{Call: call}
}

// MockCharmActionsCall wrap *gomock.Call
type MockCharmActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmActionsCall) Return(arg0 *charm.Actions) *MockCharmActionsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmActionsCall) Do(f func() *charm.Actions) *MockCharmActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmActionsCall) DoAndReturn(f func() *charm.Actions) *MockCharmActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockCharm) Config() *charm.Config {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*charm.Config)
	return ret0
}

// Config indicates an expected call of Config.
func (mr *MockCharmMockRecorder) Config() *MockCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockCharm)(nil).Config))
	return &MockCharmConfigCall{Call: call}
}

// MockCharmConfigCall wrap *gomock.Call
type MockCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmConfigCall) Return(arg0 *charm.Config) *MockCharmConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmConfigCall) Do(f func() *charm.Config) *MockCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmConfigCall) DoAndReturn(f func() *charm.Config) *MockCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsUploaded mocks base method.
func (m *MockCharm) IsUploaded() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUploaded")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsUploaded indicates an expected call of IsUploaded.
func (mr *MockCharmMockRecorder) IsUploaded() *MockCharmIsUploadedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUploaded", reflect.TypeOf((*MockCharm)(nil).IsUploaded))
	return &MockCharmIsUploadedCall{Call: call}
}

// MockCharmIsUploadedCall wrap *gomock.Call
type MockCharmIsUploadedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmIsUploadedCall) Return(arg0 bool) *MockCharmIsUploadedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmIsUploadedCall) Do(f func() bool) *MockCharmIsUploadedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmIsUploadedCall) DoAndReturn(f func() bool) *MockCharmIsUploadedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Manifest mocks base method.
func (m *MockCharm) Manifest() *charm.Manifest {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Manifest")
	ret0, _ := ret[0].(*charm.Manifest)
	return ret0
}

// Manifest indicates an expected call of Manifest.
func (mr *MockCharmMockRecorder) Manifest() *MockCharmManifestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Manifest", reflect.TypeOf((*MockCharm)(nil).Manifest))
	return &MockCharmManifestCall{Call: call}
}

// MockCharmManifestCall wrap *gomock.Call
type MockCharmManifestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmManifestCall) Return(arg0 *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmManifestCall) Do(f func() *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmManifestCall) DoAndReturn(f func() *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Meta mocks base method.
func (m *MockCharm) Meta() *charm.Meta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Meta")
	ret0, _ := ret[0].(*charm.Meta)
	return ret0
}

// Meta indicates an expected call of Meta.
func (mr *MockCharmMockRecorder) Meta() *MockCharmMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Meta", reflect.TypeOf((*MockCharm)(nil).Meta))
	return &MockCharmMetaCall{Call: call}
}

// MockCharmMetaCall wrap *gomock.Call
type MockCharmMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmMetaCall) Return(arg0 *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmMetaCall) Do(f func() *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmMetaCall) DoAndReturn(f func() *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Revision mocks base method.
func (m *MockCharm) Revision() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revision")
	ret0, _ := ret[0].(int)
	return ret0
}

// Revision indicates an expected call of Revision.
func (mr *MockCharmMockRecorder) Revision() *MockCharmRevisionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revision", reflect.TypeOf((*MockCharm)(nil).Revision))
	return &MockCharmRevisionCall{Call: call}
}

// MockCharmRevisionCall wrap *gomock.Call
type MockCharmRevisionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmRevisionCall) Return(arg0 int) *MockCharmRevisionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmRevisionCall) Do(f func() int) *MockCharmRevisionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmRevisionCall) DoAndReturn(f func() int) *MockCharmRevisionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRelation is a mock of Relation interface.
type MockRelation struct {
	ctrl     *gomock.Controller
	recorder *MockRelationMockRecorder
}

// MockRelationMockRecorder is the mock recorder for MockRelation.
type MockRelationMockRecorder struct {
	mock *MockRelation
}

// NewMockRelation creates a new mock instance.
func NewMockRelation(ctrl *gomock.Controller) *MockRelation {
	mock := &MockRelation{ctrl: ctrl}
	mock.recorder = &MockRelationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRelation) EXPECT() *MockRelationMockRecorder {
	return m.recorder
}

// AllRemoteUnits mocks base method.
func (m *MockRelation) AllRemoteUnits(arg0 string) ([]application.RelationUnit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllRemoteUnits", arg0)
	ret0, _ := ret[0].([]application.RelationUnit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllRemoteUnits indicates an expected call of AllRemoteUnits.
func (mr *MockRelationMockRecorder) AllRemoteUnits(arg0 any) *MockRelationAllRemoteUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllRemoteUnits", reflect.TypeOf((*MockRelation)(nil).AllRemoteUnits), arg0)
	return &MockRelationAllRemoteUnitsCall{Call: call}
}

// MockRelationAllRemoteUnitsCall wrap *gomock.Call
type MockRelationAllRemoteUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationAllRemoteUnitsCall) Return(arg0 []application.RelationUnit, arg1 error) *MockRelationAllRemoteUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationAllRemoteUnitsCall) Do(f func(string) ([]application.RelationUnit, error)) *MockRelationAllRemoteUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationAllRemoteUnitsCall) DoAndReturn(f func(string) ([]application.RelationUnit, error)) *MockRelationAllRemoteUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationSettings mocks base method.
func (m *MockRelation) ApplicationSettings(arg0 string) (map[string]any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationSettings", arg0)
	ret0, _ := ret[0].(map[string]any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplicationSettings indicates an expected call of ApplicationSettings.
func (mr *MockRelationMockRecorder) ApplicationSettings(arg0 any) *MockRelationApplicationSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationSettings", reflect.TypeOf((*MockRelation)(nil).ApplicationSettings), arg0)
	return &MockRelationApplicationSettingsCall{Call: call}
}

// MockRelationApplicationSettingsCall wrap *gomock.Call
type MockRelationApplicationSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationApplicationSettingsCall) Return(arg0 map[string]any, arg1 error) *MockRelationApplicationSettingsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationApplicationSettingsCall) Do(f func(string) (map[string]any, error)) *MockRelationApplicationSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationApplicationSettingsCall) DoAndReturn(f func(string) (map[string]any, error)) *MockRelationApplicationSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Destroy mocks base method.
func (m *MockRelation) Destroy(arg0 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockRelationMockRecorder) Destroy(arg0 any) *MockRelationDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockRelation)(nil).Destroy), arg0)
	return &MockRelationDestroyCall{Call: call}
}

// MockRelationDestroyCall wrap *gomock.Call
type MockRelationDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationDestroyCall) Return(arg0 error) *MockRelationDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationDestroyCall) Do(f func(objectstore.ObjectStore) error) *MockRelationDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationDestroyCall) DoAndReturn(f func(objectstore.ObjectStore) error) *MockRelationDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DestroyWithForce mocks base method.
func (m *MockRelation) DestroyWithForce(arg0 bool, arg1 time.Duration) ([]error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyWithForce", arg0, arg1)
	ret0, _ := ret[0].([]error)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DestroyWithForce indicates an expected call of DestroyWithForce.
func (mr *MockRelationMockRecorder) DestroyWithForce(arg0, arg1 any) *MockRelationDestroyWithForceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyWithForce", reflect.TypeOf((*MockRelation)(nil).DestroyWithForce), arg0, arg1)
	return &MockRelationDestroyWithForceCall{Call: call}
}

// MockRelationDestroyWithForceCall wrap *gomock.Call
type MockRelationDestroyWithForceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationDestroyWithForceCall) Return(arg0 []error, arg1 error) *MockRelationDestroyWithForceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationDestroyWithForceCall) Do(f func(bool, time.Duration) ([]error, error)) *MockRelationDestroyWithForceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationDestroyWithForceCall) DoAndReturn(f func(bool, time.Duration) ([]error, error)) *MockRelationDestroyWithForceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Endpoint mocks base method.
func (m *MockRelation) Endpoint(arg0 string) (state.Endpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Endpoint", arg0)
	ret0, _ := ret[0].(state.Endpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Endpoint indicates an expected call of Endpoint.
func (mr *MockRelationMockRecorder) Endpoint(arg0 any) *MockRelationEndpointCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoint", reflect.TypeOf((*MockRelation)(nil).Endpoint), arg0)
	return &MockRelationEndpointCall{Call: call}
}

// MockRelationEndpointCall wrap *gomock.Call
type MockRelationEndpointCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationEndpointCall) Return(arg0 state.Endpoint, arg1 error) *MockRelationEndpointCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationEndpointCall) Do(f func(string) (state.Endpoint, error)) *MockRelationEndpointCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationEndpointCall) DoAndReturn(f func(string) (state.Endpoint, error)) *MockRelationEndpointCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Endpoints mocks base method.
func (m *MockRelation) Endpoints() []state.Endpoint {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Endpoints")
	ret0, _ := ret[0].([]state.Endpoint)
	return ret0
}

// Endpoints indicates an expected call of Endpoints.
func (mr *MockRelationMockRecorder) Endpoints() *MockRelationEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoints", reflect.TypeOf((*MockRelation)(nil).Endpoints))
	return &MockRelationEndpointsCall{Call: call}
}

// MockRelationEndpointsCall wrap *gomock.Call
type MockRelationEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationEndpointsCall) Return(arg0 []state.Endpoint) *MockRelationEndpointsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationEndpointsCall) Do(f func() []state.Endpoint) *MockRelationEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationEndpointsCall) DoAndReturn(f func() []state.Endpoint) *MockRelationEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Id mocks base method.
func (m *MockRelation) Id() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Id")
	ret0, _ := ret[0].(int)
	return ret0
}

// Id indicates an expected call of Id.
func (mr *MockRelationMockRecorder) Id() *MockRelationIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Id", reflect.TypeOf((*MockRelation)(nil).Id))
	return &MockRelationIdCall{Call: call}
}

// MockRelationIdCall wrap *gomock.Call
type MockRelationIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationIdCall) Return(arg0 int) *MockRelationIdCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationIdCall) Do(f func() int) *MockRelationIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationIdCall) DoAndReturn(f func() int) *MockRelationIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RelatedEndpoints mocks base method.
func (m *MockRelation) RelatedEndpoints(arg0 string) ([]state.Endpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RelatedEndpoints", arg0)
	ret0, _ := ret[0].([]state.Endpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RelatedEndpoints indicates an expected call of RelatedEndpoints.
func (mr *MockRelationMockRecorder) RelatedEndpoints(arg0 any) *MockRelationRelatedEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RelatedEndpoints", reflect.TypeOf((*MockRelation)(nil).RelatedEndpoints), arg0)
	return &MockRelationRelatedEndpointsCall{Call: call}
}

// MockRelationRelatedEndpointsCall wrap *gomock.Call
type MockRelationRelatedEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationRelatedEndpointsCall) Return(arg0 []state.Endpoint, arg1 error) *MockRelationRelatedEndpointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationRelatedEndpointsCall) Do(f func(string) ([]state.Endpoint, error)) *MockRelationRelatedEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationRelatedEndpointsCall) DoAndReturn(f func(string) ([]state.Endpoint, error)) *MockRelationRelatedEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetStatus mocks base method.
func (m *MockRelation) SetStatus(arg0 status.StatusInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetStatus", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetStatus indicates an expected call of SetStatus.
func (mr *MockRelationMockRecorder) SetStatus(arg0 any) *MockRelationSetStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatus", reflect.TypeOf((*MockRelation)(nil).SetStatus), arg0)
	return &MockRelationSetStatusCall{Call: call}
}

// MockRelationSetStatusCall wrap *gomock.Call
type MockRelationSetStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationSetStatusCall) Return(arg0 error) *MockRelationSetStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationSetStatusCall) Do(f func(status.StatusInfo) error) *MockRelationSetStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationSetStatusCall) DoAndReturn(f func(status.StatusInfo) error) *MockRelationSetStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetSuspended mocks base method.
func (m *MockRelation) SetSuspended(arg0 bool, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSuspended", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetSuspended indicates an expected call of SetSuspended.
func (mr *MockRelationMockRecorder) SetSuspended(arg0, arg1 any) *MockRelationSetSuspendedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSuspended", reflect.TypeOf((*MockRelation)(nil).SetSuspended), arg0, arg1)
	return &MockRelationSetSuspendedCall{Call: call}
}

// MockRelationSetSuspendedCall wrap *gomock.Call
type MockRelationSetSuspendedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationSetSuspendedCall) Return(arg0 error) *MockRelationSetSuspendedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationSetSuspendedCall) Do(f func(bool, string) error) *MockRelationSetSuspendedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationSetSuspendedCall) DoAndReturn(f func(bool, string) error) *MockRelationSetSuspendedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suspended mocks base method.
func (m *MockRelation) Suspended() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suspended")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suspended indicates an expected call of Suspended.
func (mr *MockRelationMockRecorder) Suspended() *MockRelationSuspendedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suspended", reflect.TypeOf((*MockRelation)(nil).Suspended))
	return &MockRelationSuspendedCall{Call: call}
}

// MockRelationSuspendedCall wrap *gomock.Call
type MockRelationSuspendedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationSuspendedCall) Return(arg0 bool) *MockRelationSuspendedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationSuspendedCall) Do(f func() bool) *MockRelationSuspendedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationSuspendedCall) DoAndReturn(f func() bool) *MockRelationSuspendedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SuspendedReason mocks base method.
func (m *MockRelation) SuspendedReason() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SuspendedReason")
	ret0, _ := ret[0].(string)
	return ret0
}

// SuspendedReason indicates an expected call of SuspendedReason.
func (mr *MockRelationMockRecorder) SuspendedReason() *MockRelationSuspendedReasonCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SuspendedReason", reflect.TypeOf((*MockRelation)(nil).SuspendedReason))
	return &MockRelationSuspendedReasonCall{Call: call}
}

// MockRelationSuspendedReasonCall wrap *gomock.Call
type MockRelationSuspendedReasonCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationSuspendedReasonCall) Return(arg0 string) *MockRelationSuspendedReasonCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationSuspendedReasonCall) Do(f func() string) *MockRelationSuspendedReasonCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationSuspendedReasonCall) DoAndReturn(f func() string) *MockRelationSuspendedReasonCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockRelation) Tag() names.Tag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.Tag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockRelationMockRecorder) Tag() *MockRelationTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockRelation)(nil).Tag))
	return &MockRelationTagCall{Call: call}
}

// MockRelationTagCall wrap *gomock.Call
type MockRelationTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationTagCall) Return(arg0 names.Tag) *MockRelationTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationTagCall) Do(f func() names.Tag) *MockRelationTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationTagCall) DoAndReturn(f func() names.Tag) *MockRelationTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unit mocks base method.
func (m *MockRelation) Unit(arg0 string) (application.RelationUnit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unit", arg0)
	ret0, _ := ret[0].(application.RelationUnit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unit indicates an expected call of Unit.
func (mr *MockRelationMockRecorder) Unit(arg0 any) *MockRelationUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unit", reflect.TypeOf((*MockRelation)(nil).Unit), arg0)
	return &MockRelationUnitCall{Call: call}
}

// MockRelationUnitCall wrap *gomock.Call
type MockRelationUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationUnitCall) Return(arg0 application.RelationUnit, arg1 error) *MockRelationUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationUnitCall) Do(f func(string) (application.RelationUnit, error)) *MockRelationUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationUnitCall) DoAndReturn(f func(string) (application.RelationUnit, error)) *MockRelationUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUnit is a mock of Unit interface.
type MockUnit struct {
	ctrl     *gomock.Controller
	recorder *MockUnitMockRecorder
}

// MockUnitMockRecorder is the mock recorder for MockUnit.
type MockUnitMockRecorder struct {
	mock *MockUnit
}

// NewMockUnit creates a new mock instance.
func NewMockUnit(ctrl *gomock.Controller) *MockUnit {
	mock := &MockUnit{ctrl: ctrl}
	mock.recorder = &MockUnitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnit) EXPECT() *MockUnitMockRecorder {
	return m.recorder
}

// AgentTools mocks base method.
func (m *MockUnit) AgentTools() (*tools.Tools, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AgentTools")
	ret0, _ := ret[0].(*tools.Tools)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AgentTools indicates an expected call of AgentTools.
func (mr *MockUnitMockRecorder) AgentTools() *MockUnitAgentToolsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AgentTools", reflect.TypeOf((*MockUnit)(nil).AgentTools))
	return &MockUnitAgentToolsCall{Call: call}
}

// MockUnitAgentToolsCall wrap *gomock.Call
type MockUnitAgentToolsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitAgentToolsCall) Return(arg0 *tools.Tools, arg1 error) *MockUnitAgentToolsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitAgentToolsCall) Do(f func() (*tools.Tools, error)) *MockUnitAgentToolsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitAgentToolsCall) DoAndReturn(f func() (*tools.Tools, error)) *MockUnitAgentToolsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplicationName mocks base method.
func (m *MockUnit) ApplicationName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationName")
	ret0, _ := ret[0].(string)
	return ret0
}

// ApplicationName indicates an expected call of ApplicationName.
func (mr *MockUnitMockRecorder) ApplicationName() *MockUnitApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationName", reflect.TypeOf((*MockUnit)(nil).ApplicationName))
	return &MockUnitApplicationNameCall{Call: call}
}

// MockUnitApplicationNameCall wrap *gomock.Call
type MockUnitApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitApplicationNameCall) Return(arg0 string) *MockUnitApplicationNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitApplicationNameCall) Do(f func() string) *MockUnitApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitApplicationNameCall) DoAndReturn(f func() string) *MockUnitApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AssignWithPlacement mocks base method.
func (m *MockUnit) AssignWithPlacement(arg0 *instance.Placement, arg1 network.SpaceInfos) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignWithPlacement", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// AssignWithPlacement indicates an expected call of AssignWithPlacement.
func (mr *MockUnitMockRecorder) AssignWithPlacement(arg0, arg1 any) *MockUnitAssignWithPlacementCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignWithPlacement", reflect.TypeOf((*MockUnit)(nil).AssignWithPlacement), arg0, arg1)
	return &MockUnitAssignWithPlacementCall{Call: call}
}

// MockUnitAssignWithPlacementCall wrap *gomock.Call
type MockUnitAssignWithPlacementCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitAssignWithPlacementCall) Return(arg0 error) *MockUnitAssignWithPlacementCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitAssignWithPlacementCall) Do(f func(*instance.Placement, network.SpaceInfos) error) *MockUnitAssignWithPlacementCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitAssignWithPlacementCall) DoAndReturn(f func(*instance.Placement, network.SpaceInfos) error) *MockUnitAssignWithPlacementCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AssignWithPolicy mocks base method.
func (m *MockUnit) AssignWithPolicy(arg0 state.AssignmentPolicy) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignWithPolicy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// AssignWithPolicy indicates an expected call of AssignWithPolicy.
func (mr *MockUnitMockRecorder) AssignWithPolicy(arg0 any) *MockUnitAssignWithPolicyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignWithPolicy", reflect.TypeOf((*MockUnit)(nil).AssignWithPolicy), arg0)
	return &MockUnitAssignWithPolicyCall{Call: call}
}

// MockUnitAssignWithPolicyCall wrap *gomock.Call
type MockUnitAssignWithPolicyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitAssignWithPolicyCall) Return(arg0 error) *MockUnitAssignWithPolicyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitAssignWithPolicyCall) Do(f func(state.AssignmentPolicy) error) *MockUnitAssignWithPolicyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitAssignWithPolicyCall) DoAndReturn(f func(state.AssignmentPolicy) error) *MockUnitAssignWithPolicyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AssignedMachineId mocks base method.
func (m *MockUnit) AssignedMachineId() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignedMachineId")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AssignedMachineId indicates an expected call of AssignedMachineId.
func (mr *MockUnitMockRecorder) AssignedMachineId() *MockUnitAssignedMachineIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignedMachineId", reflect.TypeOf((*MockUnit)(nil).AssignedMachineId))
	return &MockUnitAssignedMachineIdCall{Call: call}
}

// MockUnitAssignedMachineIdCall wrap *gomock.Call
type MockUnitAssignedMachineIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitAssignedMachineIdCall) Return(arg0 string, arg1 error) *MockUnitAssignedMachineIdCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitAssignedMachineIdCall) Do(f func() (string, error)) *MockUnitAssignedMachineIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitAssignedMachineIdCall) DoAndReturn(f func() (string, error)) *MockUnitAssignedMachineIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ContainerInfo mocks base method.
func (m *MockUnit) ContainerInfo() (state.CloudContainer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ContainerInfo")
	ret0, _ := ret[0].(state.CloudContainer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ContainerInfo indicates an expected call of ContainerInfo.
func (mr *MockUnitMockRecorder) ContainerInfo() *MockUnitContainerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ContainerInfo", reflect.TypeOf((*MockUnit)(nil).ContainerInfo))
	return &MockUnitContainerInfoCall{Call: call}
}

// MockUnitContainerInfoCall wrap *gomock.Call
type MockUnitContainerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitContainerInfoCall) Return(arg0 state.CloudContainer, arg1 error) *MockUnitContainerInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitContainerInfoCall) Do(f func() (state.CloudContainer, error)) *MockUnitContainerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitContainerInfoCall) DoAndReturn(f func() (state.CloudContainer, error)) *MockUnitContainerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Destroy mocks base method.
func (m *MockUnit) Destroy(arg0 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockUnitMockRecorder) Destroy(arg0 any) *MockUnitDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockUnit)(nil).Destroy), arg0)
	return &MockUnitDestroyCall{Call: call}
}

// MockUnitDestroyCall wrap *gomock.Call
type MockUnitDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitDestroyCall) Return(arg0 error) *MockUnitDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitDestroyCall) Do(f func(objectstore.ObjectStore) error) *MockUnitDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitDestroyCall) DoAndReturn(f func(objectstore.ObjectStore) error) *MockUnitDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DestroyOperation mocks base method.
func (m *MockUnit) DestroyOperation(arg0 objectstore.ObjectStore) *state.DestroyUnitOperation {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyOperation", arg0)
	ret0, _ := ret[0].(*state.DestroyUnitOperation)
	return ret0
}

// DestroyOperation indicates an expected call of DestroyOperation.
func (mr *MockUnitMockRecorder) DestroyOperation(arg0 any) *MockUnitDestroyOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyOperation", reflect.TypeOf((*MockUnit)(nil).DestroyOperation), arg0)
	return &MockUnitDestroyOperationCall{Call: call}
}

// MockUnitDestroyOperationCall wrap *gomock.Call
type MockUnitDestroyOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitDestroyOperationCall) Return(arg0 *state.DestroyUnitOperation) *MockUnitDestroyOperationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitDestroyOperationCall) Do(f func(objectstore.ObjectStore) *state.DestroyUnitOperation) *MockUnitDestroyOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitDestroyOperationCall) DoAndReturn(f func(objectstore.ObjectStore) *state.DestroyUnitOperation) *MockUnitDestroyOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPrincipal mocks base method.
func (m *MockUnit) IsPrincipal() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPrincipal")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPrincipal indicates an expected call of IsPrincipal.
func (mr *MockUnitMockRecorder) IsPrincipal() *MockUnitIsPrincipalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPrincipal", reflect.TypeOf((*MockUnit)(nil).IsPrincipal))
	return &MockUnitIsPrincipalCall{Call: call}
}

// MockUnitIsPrincipalCall wrap *gomock.Call
type MockUnitIsPrincipalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitIsPrincipalCall) Return(arg0 bool) *MockUnitIsPrincipalCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitIsPrincipalCall) Do(f func() bool) *MockUnitIsPrincipalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitIsPrincipalCall) DoAndReturn(f func() bool) *MockUnitIsPrincipalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Life mocks base method.
func (m *MockUnit) Life() state.Life {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Life")
	ret0, _ := ret[0].(state.Life)
	return ret0
}

// Life indicates an expected call of Life.
func (mr *MockUnitMockRecorder) Life() *MockUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Life", reflect.TypeOf((*MockUnit)(nil).Life))
	return &MockUnitLifeCall{Call: call}
}

// MockUnitLifeCall wrap *gomock.Call
type MockUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitLifeCall) Return(arg0 state.Life) *MockUnitLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitLifeCall) Do(f func() state.Life) *MockUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitLifeCall) DoAndReturn(f func() state.Life) *MockUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockUnit) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockUnitMockRecorder) Name() *MockUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockUnit)(nil).Name))
	return &MockUnitNameCall{Call: call}
}

// MockUnitNameCall wrap *gomock.Call
type MockUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitNameCall) Return(arg0 string) *MockUnitNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitNameCall) Do(f func() string) *MockUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitNameCall) DoAndReturn(f func() string) *MockUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Resolve mocks base method.
func (m *MockUnit) Resolve(arg0 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Resolve indicates an expected call of Resolve.
func (mr *MockUnitMockRecorder) Resolve(arg0 any) *MockUnitResolveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockUnit)(nil).Resolve), arg0)
	return &MockUnitResolveCall{Call: call}
}

// MockUnitResolveCall wrap *gomock.Call
type MockUnitResolveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitResolveCall) Return(arg0 error) *MockUnitResolveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitResolveCall) Do(f func(bool) error) *MockUnitResolveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitResolveCall) DoAndReturn(f func(bool) error) *MockUnitResolveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockUnit) Tag() names.Tag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.Tag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockUnitMockRecorder) Tag() *MockUnitTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockUnit)(nil).Tag))
	return &MockUnitTagCall{Call: call}
}

// MockUnitTagCall wrap *gomock.Call
type MockUnitTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitTagCall) Return(arg0 names.Tag) *MockUnitTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitTagCall) Do(f func() names.Tag) *MockUnitTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitTagCall) DoAndReturn(f func() names.Tag) *MockUnitTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitTag mocks base method.
func (m *MockUnit) UnitTag() names.UnitTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitTag")
	ret0, _ := ret[0].(names.UnitTag)
	return ret0
}

// UnitTag indicates an expected call of UnitTag.
func (mr *MockUnitMockRecorder) UnitTag() *MockUnitUnitTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitTag", reflect.TypeOf((*MockUnit)(nil).UnitTag))
	return &MockUnitUnitTagCall{Call: call}
}

// MockUnitUnitTagCall wrap *gomock.Call
type MockUnitUnitTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitUnitTagCall) Return(arg0 names.UnitTag) *MockUnitUnitTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitUnitTagCall) Do(f func() names.UnitTag) *MockUnitUnitTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitUnitTagCall) DoAndReturn(f func() names.UnitTag) *MockUnitUnitTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WorkloadVersion mocks base method.
func (m *MockUnit) WorkloadVersion() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkloadVersion")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WorkloadVersion indicates an expected call of WorkloadVersion.
func (mr *MockUnitMockRecorder) WorkloadVersion() *MockUnitWorkloadVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkloadVersion", reflect.TypeOf((*MockUnit)(nil).WorkloadVersion))
	return &MockUnitWorkloadVersionCall{Call: call}
}

// MockUnitWorkloadVersionCall wrap *gomock.Call
type MockUnitWorkloadVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitWorkloadVersionCall) Return(arg0 string, arg1 error) *MockUnitWorkloadVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitWorkloadVersionCall) Do(f func() (string, error)) *MockUnitWorkloadVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitWorkloadVersionCall) DoAndReturn(f func() (string, error)) *MockUnitWorkloadVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRelationUnit is a mock of RelationUnit interface.
type MockRelationUnit struct {
	ctrl     *gomock.Controller
	recorder *MockRelationUnitMockRecorder
}

// MockRelationUnitMockRecorder is the mock recorder for MockRelationUnit.
type MockRelationUnitMockRecorder struct {
	mock *MockRelationUnit
}

// NewMockRelationUnit creates a new mock instance.
func NewMockRelationUnit(ctrl *gomock.Controller) *MockRelationUnit {
	mock := &MockRelationUnit{ctrl: ctrl}
	mock.recorder = &MockRelationUnitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRelationUnit) EXPECT() *MockRelationUnitMockRecorder {
	return m.recorder
}

// InScope mocks base method.
func (m *MockRelationUnit) InScope() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InScope")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InScope indicates an expected call of InScope.
func (mr *MockRelationUnitMockRecorder) InScope() *MockRelationUnitInScopeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InScope", reflect.TypeOf((*MockRelationUnit)(nil).InScope))
	return &MockRelationUnitInScopeCall{Call: call}
}

// MockRelationUnitInScopeCall wrap *gomock.Call
type MockRelationUnitInScopeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationUnitInScopeCall) Return(arg0 bool, arg1 error) *MockRelationUnitInScopeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationUnitInScopeCall) Do(f func() (bool, error)) *MockRelationUnitInScopeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationUnitInScopeCall) DoAndReturn(f func() (bool, error)) *MockRelationUnitInScopeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Settings mocks base method.
func (m *MockRelationUnit) Settings() (map[string]any, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Settings")
	ret0, _ := ret[0].(map[string]any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Settings indicates an expected call of Settings.
func (mr *MockRelationUnitMockRecorder) Settings() *MockRelationUnitSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Settings", reflect.TypeOf((*MockRelationUnit)(nil).Settings))
	return &MockRelationUnitSettingsCall{Call: call}
}

// MockRelationUnitSettingsCall wrap *gomock.Call
type MockRelationUnitSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationUnitSettingsCall) Return(arg0 map[string]any, arg1 error) *MockRelationUnitSettingsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationUnitSettingsCall) Do(f func() (map[string]any, error)) *MockRelationUnitSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationUnitSettingsCall) DoAndReturn(f func() (map[string]any, error)) *MockRelationUnitSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitName mocks base method.
func (m *MockRelationUnit) UnitName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitName")
	ret0, _ := ret[0].(string)
	return ret0
}

// UnitName indicates an expected call of UnitName.
func (mr *MockRelationUnitMockRecorder) UnitName() *MockRelationUnitUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitName", reflect.TypeOf((*MockRelationUnit)(nil).UnitName))
	return &MockRelationUnitUnitNameCall{Call: call}
}

// MockRelationUnitUnitNameCall wrap *gomock.Call
type MockRelationUnitUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRelationUnitUnitNameCall) Return(arg0 string) *MockRelationUnitUnitNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRelationUnitUnitNameCall) Do(f func() string) *MockRelationUnitUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRelationUnitUnitNameCall) DoAndReturn(f func() string) *MockRelationUnitUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockMachine is a mock of Machine interface.
type MockMachine struct {
	ctrl     *gomock.Controller
	recorder *MockMachineMockRecorder
}

// MockMachineMockRecorder is the mock recorder for MockMachine.
type MockMachineMockRecorder struct {
	mock *MockMachine
}

// NewMockMachine creates a new mock instance.
func NewMockMachine(ctrl *gomock.Controller) *MockMachine {
	mock := &MockMachine{ctrl: ctrl}
	mock.recorder = &MockMachineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachine) EXPECT() *MockMachineMockRecorder {
	return m.recorder
}

// Base mocks base method.
func (m *MockMachine) Base() state.Base {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Base")
	ret0, _ := ret[0].(state.Base)
	return ret0
}

// Base indicates an expected call of Base.
func (mr *MockMachineMockRecorder) Base() *MockMachineBaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Base", reflect.TypeOf((*MockMachine)(nil).Base))
	return &MockMachineBaseCall{Call: call}
}

// MockMachineBaseCall wrap *gomock.Call
type MockMachineBaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineBaseCall) Return(arg0 state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineBaseCall) Do(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineBaseCall) DoAndReturn(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HardwareCharacteristics mocks base method.
func (m *MockMachine) HardwareCharacteristics() (*instance.HardwareCharacteristics, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HardwareCharacteristics")
	ret0, _ := ret[0].(*instance.HardwareCharacteristics)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HardwareCharacteristics indicates an expected call of HardwareCharacteristics.
func (mr *MockMachineMockRecorder) HardwareCharacteristics() *MockMachineHardwareCharacteristicsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HardwareCharacteristics", reflect.TypeOf((*MockMachine)(nil).HardwareCharacteristics))
	return &MockMachineHardwareCharacteristicsCall{Call: call}
}

// MockMachineHardwareCharacteristicsCall wrap *gomock.Call
type MockMachineHardwareCharacteristicsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineHardwareCharacteristicsCall) Return(arg0 *instance.HardwareCharacteristics, arg1 error) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineHardwareCharacteristicsCall) Do(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineHardwareCharacteristicsCall) DoAndReturn(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsLockedForSeriesUpgrade mocks base method.
func (m *MockMachine) IsLockedForSeriesUpgrade() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLockedForSeriesUpgrade")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLockedForSeriesUpgrade indicates an expected call of IsLockedForSeriesUpgrade.
func (mr *MockMachineMockRecorder) IsLockedForSeriesUpgrade() *MockMachineIsLockedForSeriesUpgradeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLockedForSeriesUpgrade", reflect.TypeOf((*MockMachine)(nil).IsLockedForSeriesUpgrade))
	return &MockMachineIsLockedForSeriesUpgradeCall{Call: call}
}

// MockMachineIsLockedForSeriesUpgradeCall wrap *gomock.Call
type MockMachineIsLockedForSeriesUpgradeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsLockedForSeriesUpgradeCall) Return(arg0 bool, arg1 error) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsLockedForSeriesUpgradeCall) Do(f func() (bool, error)) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsLockedForSeriesUpgradeCall) DoAndReturn(f func() (bool, error)) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsParentLockedForSeriesUpgrade mocks base method.
func (m *MockMachine) IsParentLockedForSeriesUpgrade() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsParentLockedForSeriesUpgrade")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsParentLockedForSeriesUpgrade indicates an expected call of IsParentLockedForSeriesUpgrade.
func (mr *MockMachineMockRecorder) IsParentLockedForSeriesUpgrade() *MockMachineIsParentLockedForSeriesUpgradeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsParentLockedForSeriesUpgrade", reflect.TypeOf((*MockMachine)(nil).IsParentLockedForSeriesUpgrade))
	return &MockMachineIsParentLockedForSeriesUpgradeCall{Call: call}
}

// MockMachineIsParentLockedForSeriesUpgradeCall wrap *gomock.Call
type MockMachineIsParentLockedForSeriesUpgradeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsParentLockedForSeriesUpgradeCall) Return(arg0 bool, arg1 error) *MockMachineIsParentLockedForSeriesUpgradeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsParentLockedForSeriesUpgradeCall) Do(f func() (bool, error)) *MockMachineIsParentLockedForSeriesUpgradeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsParentLockedForSeriesUpgradeCall) DoAndReturn(f func() (bool, error)) *MockMachineIsParentLockedForSeriesUpgradeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PublicAddress mocks base method.
func (m *MockMachine) PublicAddress() (network.SpaceAddress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublicAddress")
	ret0, _ := ret[0].(network.SpaceAddress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublicAddress indicates an expected call of PublicAddress.
func (mr *MockMachineMockRecorder) PublicAddress() *MockMachinePublicAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublicAddress", reflect.TypeOf((*MockMachine)(nil).PublicAddress))
	return &MockMachinePublicAddressCall{Call: call}
}

// MockMachinePublicAddressCall wrap *gomock.Call
type MockMachinePublicAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachinePublicAddressCall) Return(arg0 network.SpaceAddress, arg1 error) *MockMachinePublicAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachinePublicAddressCall) Do(f func() (network.SpaceAddress, error)) *MockMachinePublicAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachinePublicAddressCall) DoAndReturn(f func() (network.SpaceAddress, error)) *MockMachinePublicAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockGeneration is a mock of Generation interface.
type MockGeneration struct {
	ctrl     *gomock.Controller
	recorder *MockGenerationMockRecorder
}

// MockGenerationMockRecorder is the mock recorder for MockGeneration.
type MockGenerationMockRecorder struct {
	mock *MockGeneration
}

// NewMockGeneration creates a new mock instance.
func NewMockGeneration(ctrl *gomock.Controller) *MockGeneration {
	mock := &MockGeneration{ctrl: ctrl}
	mock.recorder = &MockGenerationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGeneration) EXPECT() *MockGenerationMockRecorder {
	return m.recorder
}

// AssignApplication mocks base method.
func (m *MockGeneration) AssignApplication(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignApplication", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// AssignApplication indicates an expected call of AssignApplication.
func (mr *MockGenerationMockRecorder) AssignApplication(arg0 any) *MockGenerationAssignApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignApplication", reflect.TypeOf((*MockGeneration)(nil).AssignApplication), arg0)
	return &MockGenerationAssignApplicationCall{Call: call}
}

// MockGenerationAssignApplicationCall wrap *gomock.Call
type MockGenerationAssignApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGenerationAssignApplicationCall) Return(arg0 error) *MockGenerationAssignApplicationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGenerationAssignApplicationCall) Do(f func(string) error) *MockGenerationAssignApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGenerationAssignApplicationCall) DoAndReturn(f func(string) error) *MockGenerationAssignApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockBindings is a mock of Bindings interface.
type MockBindings struct {
	ctrl     *gomock.Controller
	recorder *MockBindingsMockRecorder
}

// MockBindingsMockRecorder is the mock recorder for MockBindings.
type MockBindingsMockRecorder struct {
	mock *MockBindings
}

// NewMockBindings creates a new mock instance.
func NewMockBindings(ctrl *gomock.Controller) *MockBindings {
	mock := &MockBindings{ctrl: ctrl}
	mock.recorder = &MockBindingsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBindings) EXPECT() *MockBindingsMockRecorder {
	return m.recorder
}

// Map mocks base method.
func (m *MockBindings) Map() map[string]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Map")
	ret0, _ := ret[0].(map[string]string)
	return ret0
}

// Map indicates an expected call of Map.
func (mr *MockBindingsMockRecorder) Map() *MockBindingsMapCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Map", reflect.TypeOf((*MockBindings)(nil).Map))
	return &MockBindingsMapCall{Call: call}
}

// MockBindingsMapCall wrap *gomock.Call
type MockBindingsMapCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBindingsMapCall) Return(arg0 map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBindingsMapCall) Do(f func() map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBindingsMapCall) DoAndReturn(f func() map[string]string) *MockBindingsMapCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MapWithSpaceNames mocks base method.
func (m *MockBindings) MapWithSpaceNames(arg0 network.SpaceInfos) (map[string]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapWithSpaceNames", arg0)
	ret0, _ := ret[0].(map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MapWithSpaceNames indicates an expected call of MapWithSpaceNames.
func (mr *MockBindingsMockRecorder) MapWithSpaceNames(arg0 any) *MockBindingsMapWithSpaceNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapWithSpaceNames", reflect.TypeOf((*MockBindings)(nil).MapWithSpaceNames), arg0)
	return &MockBindingsMapWithSpaceNamesCall{Call: call}
}

// MockBindingsMapWithSpaceNamesCall wrap *gomock.Call
type MockBindingsMapWithSpaceNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBindingsMapWithSpaceNamesCall) Return(arg0 map[string]string, arg1 error) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBindingsMapWithSpaceNamesCall) Do(f func(network.SpaceInfos) (map[string]string, error)) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBindingsMapWithSpaceNamesCall) DoAndReturn(f func(network.SpaceInfos) (map[string]string, error)) *MockBindingsMapWithSpaceNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockResources is a mock of Resources interface.
type MockResources struct {
	ctrl     *gomock.Controller
	recorder *MockResourcesMockRecorder
}

// MockResourcesMockRecorder is the mock recorder for MockResources.
type MockResourcesMockRecorder struct {
	mock *MockResources
}

// NewMockResources creates a new mock instance.
func NewMockResources(ctrl *gomock.Controller) *MockResources {
	mock := &MockResources{ctrl: ctrl}
	mock.recorder = &MockResourcesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResources) EXPECT() *MockResourcesMockRecorder {
	return m.recorder
}

// RemovePendingAppResources mocks base method.
func (m *MockResources) RemovePendingAppResources(arg0 string, arg1 map[string]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemovePendingAppResources", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemovePendingAppResources indicates an expected call of RemovePendingAppResources.
func (mr *MockResourcesMockRecorder) RemovePendingAppResources(arg0, arg1 any) *MockResourcesRemovePendingAppResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePendingAppResources", reflect.TypeOf((*MockResources)(nil).RemovePendingAppResources), arg0, arg1)
	return &MockResourcesRemovePendingAppResourcesCall{Call: call}
}

// MockResourcesRemovePendingAppResourcesCall wrap *gomock.Call
type MockResourcesRemovePendingAppResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourcesRemovePendingAppResourcesCall) Return(arg0 error) *MockResourcesRemovePendingAppResourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourcesRemovePendingAppResourcesCall) Do(f func(string, map[string]string) error) *MockResourcesRemovePendingAppResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourcesRemovePendingAppResourcesCall) DoAndReturn(f func(string, map[string]string) error) *MockResourcesRemovePendingAppResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

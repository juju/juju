// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/apiserver/facades/client/machinemanager (interfaces: Leadership,Authorizer,UpgradeSeries,UpgradeSeriesState,UpgradeBaseValidator,ControllerBackend,InstanceConfigBackend,Backend,StorageInterface,Pool,Model,Machine,Application,Unit,Charm,CharmhubClient,ControllerConfigService,MachineService,NetworkService)
//
// Generated by this command:
//
//	mockgen -typed -package machinemanager_test -destination package_mock_test.go github.com/juju/juju/apiserver/facades/client/machinemanager Leadership,Authorizer,UpgradeSeries,UpgradeSeriesState,UpgradeBaseValidator,ControllerBackend,InstanceConfigBackend,Backend,StorageInterface,Pool,Model,Machine,Application,Unit,Charm,CharmhubClient,ControllerConfigService,MachineService,NetworkService
//

// Package machinemanager_test is a generated GoMock package.
package machinemanager_test

import (
	context "context"
	reflect "reflect"
	time "time"

	charm "github.com/juju/charm/v13"
	storagecommon "github.com/juju/juju/apiserver/common/storagecommon"
	machinemanager "github.com/juju/juju/apiserver/facades/client/machinemanager"
	controller "github.com/juju/juju/controller"
	base "github.com/juju/juju/core/base"
	instance "github.com/juju/juju/core/instance"
	model "github.com/juju/juju/core/model"
	network "github.com/juju/juju/core/network"
	objectstore "github.com/juju/juju/core/objectstore"
	status "github.com/juju/juju/core/status"
	config "github.com/juju/juju/environs/config"
	charmhub "github.com/juju/juju/internal/charmhub"
	transport "github.com/juju/juju/internal/charmhub/transport"
	params "github.com/juju/juju/rpc/params"
	state "github.com/juju/juju/state"
	binarystorage "github.com/juju/juju/state/binarystorage"
	names "github.com/juju/names/v5"
	gomock "go.uber.org/mock/gomock"
)

// MockLeadership is a mock of Leadership interface.
type MockLeadership struct {
	ctrl     *gomock.Controller
	recorder *MockLeadershipMockRecorder
}

// MockLeadershipMockRecorder is the mock recorder for MockLeadership.
type MockLeadershipMockRecorder struct {
	mock *MockLeadership
}

// NewMockLeadership creates a new mock instance.
func NewMockLeadership(ctrl *gomock.Controller) *MockLeadership {
	mock := &MockLeadership{ctrl: ctrl}
	mock.recorder = &MockLeadershipMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLeadership) EXPECT() *MockLeadershipMockRecorder {
	return m.recorder
}

// GetMachineApplicationNames mocks base method.
func (m *MockLeadership) GetMachineApplicationNames(arg0 context.Context, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMachineApplicationNames", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMachineApplicationNames indicates an expected call of GetMachineApplicationNames.
func (mr *MockLeadershipMockRecorder) GetMachineApplicationNames(arg0, arg1 any) *MockLeadershipGetMachineApplicationNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMachineApplicationNames", reflect.TypeOf((*MockLeadership)(nil).GetMachineApplicationNames), arg0, arg1)
	return &MockLeadershipGetMachineApplicationNamesCall{Call: call}
}

// MockLeadershipGetMachineApplicationNamesCall wrap *gomock.Call
type MockLeadershipGetMachineApplicationNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLeadershipGetMachineApplicationNamesCall) Return(arg0 []string, arg1 error) *MockLeadershipGetMachineApplicationNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLeadershipGetMachineApplicationNamesCall) Do(f func(context.Context, string) ([]string, error)) *MockLeadershipGetMachineApplicationNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLeadershipGetMachineApplicationNamesCall) DoAndReturn(f func(context.Context, string) ([]string, error)) *MockLeadershipGetMachineApplicationNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnpinApplicationLeadersByName mocks base method.
func (m *MockLeadership) UnpinApplicationLeadersByName(arg0 context.Context, arg1 names.Tag, arg2 []string) (params.PinApplicationsResults, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnpinApplicationLeadersByName", arg0, arg1, arg2)
	ret0, _ := ret[0].(params.PinApplicationsResults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnpinApplicationLeadersByName indicates an expected call of UnpinApplicationLeadersByName.
func (mr *MockLeadershipMockRecorder) UnpinApplicationLeadersByName(arg0, arg1, arg2 any) *MockLeadershipUnpinApplicationLeadersByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnpinApplicationLeadersByName", reflect.TypeOf((*MockLeadership)(nil).UnpinApplicationLeadersByName), arg0, arg1, arg2)
	return &MockLeadershipUnpinApplicationLeadersByNameCall{Call: call}
}

// MockLeadershipUnpinApplicationLeadersByNameCall wrap *gomock.Call
type MockLeadershipUnpinApplicationLeadersByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLeadershipUnpinApplicationLeadersByNameCall) Return(arg0 params.PinApplicationsResults, arg1 error) *MockLeadershipUnpinApplicationLeadersByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLeadershipUnpinApplicationLeadersByNameCall) Do(f func(context.Context, names.Tag, []string) (params.PinApplicationsResults, error)) *MockLeadershipUnpinApplicationLeadersByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLeadershipUnpinApplicationLeadersByNameCall) DoAndReturn(f func(context.Context, names.Tag, []string) (params.PinApplicationsResults, error)) *MockLeadershipUnpinApplicationLeadersByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockAuthorizer is a mock of Authorizer interface.
type MockAuthorizer struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizerMockRecorder
}

// MockAuthorizerMockRecorder is the mock recorder for MockAuthorizer.
type MockAuthorizerMockRecorder struct {
	mock *MockAuthorizer
}

// NewMockAuthorizer creates a new mock instance.
func NewMockAuthorizer(ctrl *gomock.Controller) *MockAuthorizer {
	mock := &MockAuthorizer{ctrl: ctrl}
	mock.recorder = &MockAuthorizerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizer) EXPECT() *MockAuthorizerMockRecorder {
	return m.recorder
}

// AuthClient mocks base method.
func (m *MockAuthorizer) AuthClient() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AuthClient")
	ret0, _ := ret[0].(bool)
	return ret0
}

// AuthClient indicates an expected call of AuthClient.
func (mr *MockAuthorizerMockRecorder) AuthClient() *MockAuthorizerAuthClientCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthClient", reflect.TypeOf((*MockAuthorizer)(nil).AuthClient))
	return &MockAuthorizerAuthClientCall{Call: call}
}

// MockAuthorizerAuthClientCall wrap *gomock.Call
type MockAuthorizerAuthClientCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorizerAuthClientCall) Return(arg0 bool) *MockAuthorizerAuthClientCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorizerAuthClientCall) Do(f func() bool) *MockAuthorizerAuthClientCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorizerAuthClientCall) DoAndReturn(f func() bool) *MockAuthorizerAuthClientCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CanRead mocks base method.
func (m *MockAuthorizer) CanRead() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanRead")
	ret0, _ := ret[0].(error)
	return ret0
}

// CanRead indicates an expected call of CanRead.
func (mr *MockAuthorizerMockRecorder) CanRead() *MockAuthorizerCanReadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanRead", reflect.TypeOf((*MockAuthorizer)(nil).CanRead))
	return &MockAuthorizerCanReadCall{Call: call}
}

// MockAuthorizerCanReadCall wrap *gomock.Call
type MockAuthorizerCanReadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorizerCanReadCall) Return(arg0 error) *MockAuthorizerCanReadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorizerCanReadCall) Do(f func() error) *MockAuthorizerCanReadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorizerCanReadCall) DoAndReturn(f func() error) *MockAuthorizerCanReadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CanWrite mocks base method.
func (m *MockAuthorizer) CanWrite() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanWrite")
	ret0, _ := ret[0].(error)
	return ret0
}

// CanWrite indicates an expected call of CanWrite.
func (mr *MockAuthorizerMockRecorder) CanWrite() *MockAuthorizerCanWriteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanWrite", reflect.TypeOf((*MockAuthorizer)(nil).CanWrite))
	return &MockAuthorizerCanWriteCall{Call: call}
}

// MockAuthorizerCanWriteCall wrap *gomock.Call
type MockAuthorizerCanWriteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAuthorizerCanWriteCall) Return(arg0 error) *MockAuthorizerCanWriteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAuthorizerCanWriteCall) Do(f func() error) *MockAuthorizerCanWriteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAuthorizerCanWriteCall) DoAndReturn(f func() error) *MockAuthorizerCanWriteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUpgradeSeries is a mock of UpgradeSeries interface.
type MockUpgradeSeries struct {
	ctrl     *gomock.Controller
	recorder *MockUpgradeSeriesMockRecorder
}

// MockUpgradeSeriesMockRecorder is the mock recorder for MockUpgradeSeries.
type MockUpgradeSeriesMockRecorder struct {
	mock *MockUpgradeSeries
}

// NewMockUpgradeSeries creates a new mock instance.
func NewMockUpgradeSeries(ctrl *gomock.Controller) *MockUpgradeSeries {
	mock := &MockUpgradeSeries{ctrl: ctrl}
	mock.recorder = &MockUpgradeSeriesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpgradeSeries) EXPECT() *MockUpgradeSeriesMockRecorder {
	return m.recorder
}

// Complete mocks base method.
func (m *MockUpgradeSeries) Complete(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Complete", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Complete indicates an expected call of Complete.
func (mr *MockUpgradeSeriesMockRecorder) Complete(arg0 any) *MockUpgradeSeriesCompleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Complete", reflect.TypeOf((*MockUpgradeSeries)(nil).Complete), arg0)
	return &MockUpgradeSeriesCompleteCall{Call: call}
}

// MockUpgradeSeriesCompleteCall wrap *gomock.Call
type MockUpgradeSeriesCompleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeSeriesCompleteCall) Return(arg0 error) *MockUpgradeSeriesCompleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeSeriesCompleteCall) Do(f func(string) error) *MockUpgradeSeriesCompleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeSeriesCompleteCall) DoAndReturn(f func(string) error) *MockUpgradeSeriesCompleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prepare mocks base method.
func (m *MockUpgradeSeries) Prepare(arg0 context.Context, arg1, arg2 string, arg3 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prepare indicates an expected call of Prepare.
func (mr *MockUpgradeSeriesMockRecorder) Prepare(arg0, arg1, arg2, arg3 any) *MockUpgradeSeriesPrepareCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockUpgradeSeries)(nil).Prepare), arg0, arg1, arg2, arg3)
	return &MockUpgradeSeriesPrepareCall{Call: call}
}

// MockUpgradeSeriesPrepareCall wrap *gomock.Call
type MockUpgradeSeriesPrepareCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeSeriesPrepareCall) Return(arg0 error) *MockUpgradeSeriesPrepareCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeSeriesPrepareCall) Do(f func(context.Context, string, string, bool) error) *MockUpgradeSeriesPrepareCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeSeriesPrepareCall) DoAndReturn(f func(context.Context, string, string, bool) error) *MockUpgradeSeriesPrepareCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Validate mocks base method.
func (m *MockUpgradeSeries) Validate(arg0 context.Context, arg1 []machinemanager.ValidationEntity) ([]machinemanager.ValidationResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate", arg0, arg1)
	ret0, _ := ret[0].([]machinemanager.ValidationResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Validate indicates an expected call of Validate.
func (mr *MockUpgradeSeriesMockRecorder) Validate(arg0, arg1 any) *MockUpgradeSeriesValidateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockUpgradeSeries)(nil).Validate), arg0, arg1)
	return &MockUpgradeSeriesValidateCall{Call: call}
}

// MockUpgradeSeriesValidateCall wrap *gomock.Call
type MockUpgradeSeriesValidateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeSeriesValidateCall) Return(arg0 []machinemanager.ValidationResult, arg1 error) *MockUpgradeSeriesValidateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeSeriesValidateCall) Do(f func(context.Context, []machinemanager.ValidationEntity) ([]machinemanager.ValidationResult, error)) *MockUpgradeSeriesValidateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeSeriesValidateCall) DoAndReturn(f func(context.Context, []machinemanager.ValidationEntity) ([]machinemanager.ValidationResult, error)) *MockUpgradeSeriesValidateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUpgradeSeriesState is a mock of UpgradeSeriesState interface.
type MockUpgradeSeriesState struct {
	ctrl     *gomock.Controller
	recorder *MockUpgradeSeriesStateMockRecorder
}

// MockUpgradeSeriesStateMockRecorder is the mock recorder for MockUpgradeSeriesState.
type MockUpgradeSeriesStateMockRecorder struct {
	mock *MockUpgradeSeriesState
}

// NewMockUpgradeSeriesState creates a new mock instance.
func NewMockUpgradeSeriesState(ctrl *gomock.Controller) *MockUpgradeSeriesState {
	mock := &MockUpgradeSeriesState{ctrl: ctrl}
	mock.recorder = &MockUpgradeSeriesStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpgradeSeriesState) EXPECT() *MockUpgradeSeriesStateMockRecorder {
	return m.recorder
}

// ApplicationsFromMachine mocks base method.
func (m *MockUpgradeSeriesState) ApplicationsFromMachine(arg0 machinemanager.Machine) ([]machinemanager.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationsFromMachine", arg0)
	ret0, _ := ret[0].([]machinemanager.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplicationsFromMachine indicates an expected call of ApplicationsFromMachine.
func (mr *MockUpgradeSeriesStateMockRecorder) ApplicationsFromMachine(arg0 any) *MockUpgradeSeriesStateApplicationsFromMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationsFromMachine", reflect.TypeOf((*MockUpgradeSeriesState)(nil).ApplicationsFromMachine), arg0)
	return &MockUpgradeSeriesStateApplicationsFromMachineCall{Call: call}
}

// MockUpgradeSeriesStateApplicationsFromMachineCall wrap *gomock.Call
type MockUpgradeSeriesStateApplicationsFromMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeSeriesStateApplicationsFromMachineCall) Return(arg0 []machinemanager.Application, arg1 error) *MockUpgradeSeriesStateApplicationsFromMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeSeriesStateApplicationsFromMachineCall) Do(f func(machinemanager.Machine) ([]machinemanager.Application, error)) *MockUpgradeSeriesStateApplicationsFromMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeSeriesStateApplicationsFromMachineCall) DoAndReturn(f func(machinemanager.Machine) ([]machinemanager.Application, error)) *MockUpgradeSeriesStateApplicationsFromMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MachineFromTag mocks base method.
func (m *MockUpgradeSeriesState) MachineFromTag(arg0 string) (machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MachineFromTag", arg0)
	ret0, _ := ret[0].(machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MachineFromTag indicates an expected call of MachineFromTag.
func (mr *MockUpgradeSeriesStateMockRecorder) MachineFromTag(arg0 any) *MockUpgradeSeriesStateMachineFromTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MachineFromTag", reflect.TypeOf((*MockUpgradeSeriesState)(nil).MachineFromTag), arg0)
	return &MockUpgradeSeriesStateMachineFromTagCall{Call: call}
}

// MockUpgradeSeriesStateMachineFromTagCall wrap *gomock.Call
type MockUpgradeSeriesStateMachineFromTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeSeriesStateMachineFromTagCall) Return(arg0 machinemanager.Machine, arg1 error) *MockUpgradeSeriesStateMachineFromTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeSeriesStateMachineFromTagCall) Do(f func(string) (machinemanager.Machine, error)) *MockUpgradeSeriesStateMachineFromTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeSeriesStateMachineFromTagCall) DoAndReturn(f func(string) (machinemanager.Machine, error)) *MockUpgradeSeriesStateMachineFromTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUpgradeBaseValidator is a mock of UpgradeBaseValidator interface.
type MockUpgradeBaseValidator struct {
	ctrl     *gomock.Controller
	recorder *MockUpgradeBaseValidatorMockRecorder
}

// MockUpgradeBaseValidatorMockRecorder is the mock recorder for MockUpgradeBaseValidator.
type MockUpgradeBaseValidatorMockRecorder struct {
	mock *MockUpgradeBaseValidator
}

// NewMockUpgradeBaseValidator creates a new mock instance.
func NewMockUpgradeBaseValidator(ctrl *gomock.Controller) *MockUpgradeBaseValidator {
	mock := &MockUpgradeBaseValidator{ctrl: ctrl}
	mock.recorder = &MockUpgradeBaseValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpgradeBaseValidator) EXPECT() *MockUpgradeBaseValidatorMockRecorder {
	return m.recorder
}

// ValidateApplications mocks base method.
func (m *MockUpgradeBaseValidator) ValidateApplications(arg0 context.Context, arg1 []machinemanager.Application, arg2 base.Base, arg3 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateApplications", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateApplications indicates an expected call of ValidateApplications.
func (mr *MockUpgradeBaseValidatorMockRecorder) ValidateApplications(arg0, arg1, arg2, arg3 any) *MockUpgradeBaseValidatorValidateApplicationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateApplications", reflect.TypeOf((*MockUpgradeBaseValidator)(nil).ValidateApplications), arg0, arg1, arg2, arg3)
	return &MockUpgradeBaseValidatorValidateApplicationsCall{Call: call}
}

// MockUpgradeBaseValidatorValidateApplicationsCall wrap *gomock.Call
type MockUpgradeBaseValidatorValidateApplicationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeBaseValidatorValidateApplicationsCall) Return(arg0 error) *MockUpgradeBaseValidatorValidateApplicationsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeBaseValidatorValidateApplicationsCall) Do(f func(context.Context, []machinemanager.Application, base.Base, bool) error) *MockUpgradeBaseValidatorValidateApplicationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeBaseValidatorValidateApplicationsCall) DoAndReturn(f func(context.Context, []machinemanager.Application, base.Base, bool) error) *MockUpgradeBaseValidatorValidateApplicationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ValidateBase mocks base method.
func (m *MockUpgradeBaseValidator) ValidateBase(arg0, arg1 base.Base, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateBase", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateBase indicates an expected call of ValidateBase.
func (mr *MockUpgradeBaseValidatorMockRecorder) ValidateBase(arg0, arg1, arg2 any) *MockUpgradeBaseValidatorValidateBaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateBase", reflect.TypeOf((*MockUpgradeBaseValidator)(nil).ValidateBase), arg0, arg1, arg2)
	return &MockUpgradeBaseValidatorValidateBaseCall{Call: call}
}

// MockUpgradeBaseValidatorValidateBaseCall wrap *gomock.Call
type MockUpgradeBaseValidatorValidateBaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeBaseValidatorValidateBaseCall) Return(arg0 error) *MockUpgradeBaseValidatorValidateBaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeBaseValidatorValidateBaseCall) Do(f func(base.Base, base.Base, string) error) *MockUpgradeBaseValidatorValidateBaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeBaseValidatorValidateBaseCall) DoAndReturn(f func(base.Base, base.Base, string) error) *MockUpgradeBaseValidatorValidateBaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ValidateMachine mocks base method.
func (m *MockUpgradeBaseValidator) ValidateMachine(arg0 machinemanager.Machine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateMachine", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateMachine indicates an expected call of ValidateMachine.
func (mr *MockUpgradeBaseValidatorMockRecorder) ValidateMachine(arg0 any) *MockUpgradeBaseValidatorValidateMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateMachine", reflect.TypeOf((*MockUpgradeBaseValidator)(nil).ValidateMachine), arg0)
	return &MockUpgradeBaseValidatorValidateMachineCall{Call: call}
}

// MockUpgradeBaseValidatorValidateMachineCall wrap *gomock.Call
type MockUpgradeBaseValidatorValidateMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeBaseValidatorValidateMachineCall) Return(arg0 error) *MockUpgradeBaseValidatorValidateMachineCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeBaseValidatorValidateMachineCall) Do(f func(machinemanager.Machine) error) *MockUpgradeBaseValidatorValidateMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeBaseValidatorValidateMachineCall) DoAndReturn(f func(machinemanager.Machine) error) *MockUpgradeBaseValidatorValidateMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ValidateUnits mocks base method.
func (m *MockUpgradeBaseValidator) ValidateUnits(arg0 []machinemanager.Unit) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateUnits", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateUnits indicates an expected call of ValidateUnits.
func (mr *MockUpgradeBaseValidatorMockRecorder) ValidateUnits(arg0 any) *MockUpgradeBaseValidatorValidateUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateUnits", reflect.TypeOf((*MockUpgradeBaseValidator)(nil).ValidateUnits), arg0)
	return &MockUpgradeBaseValidatorValidateUnitsCall{Call: call}
}

// MockUpgradeBaseValidatorValidateUnitsCall wrap *gomock.Call
type MockUpgradeBaseValidatorValidateUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgradeBaseValidatorValidateUnitsCall) Return(arg0 error) *MockUpgradeBaseValidatorValidateUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgradeBaseValidatorValidateUnitsCall) Do(f func([]machinemanager.Unit) error) *MockUpgradeBaseValidatorValidateUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgradeBaseValidatorValidateUnitsCall) DoAndReturn(f func([]machinemanager.Unit) error) *MockUpgradeBaseValidatorValidateUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockControllerBackend is a mock of ControllerBackend interface.
type MockControllerBackend struct {
	ctrl     *gomock.Controller
	recorder *MockControllerBackendMockRecorder
}

// MockControllerBackendMockRecorder is the mock recorder for MockControllerBackend.
type MockControllerBackendMockRecorder struct {
	mock *MockControllerBackend
}

// NewMockControllerBackend creates a new mock instance.
func NewMockControllerBackend(ctrl *gomock.Controller) *MockControllerBackend {
	mock := &MockControllerBackend{ctrl: ctrl}
	mock.recorder = &MockControllerBackendMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockControllerBackend) EXPECT() *MockControllerBackendMockRecorder {
	return m.recorder
}

// APIHostPortsForAgents mocks base method.
func (m *MockControllerBackend) APIHostPortsForAgents(arg0 controller.Config) ([]network.SpaceHostPorts, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "APIHostPortsForAgents", arg0)
	ret0, _ := ret[0].([]network.SpaceHostPorts)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// APIHostPortsForAgents indicates an expected call of APIHostPortsForAgents.
func (mr *MockControllerBackendMockRecorder) APIHostPortsForAgents(arg0 any) *MockControllerBackendAPIHostPortsForAgentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "APIHostPortsForAgents", reflect.TypeOf((*MockControllerBackend)(nil).APIHostPortsForAgents), arg0)
	return &MockControllerBackendAPIHostPortsForAgentsCall{Call: call}
}

// MockControllerBackendAPIHostPortsForAgentsCall wrap *gomock.Call
type MockControllerBackendAPIHostPortsForAgentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerBackendAPIHostPortsForAgentsCall) Return(arg0 []network.SpaceHostPorts, arg1 error) *MockControllerBackendAPIHostPortsForAgentsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerBackendAPIHostPortsForAgentsCall) Do(f func(controller.Config) ([]network.SpaceHostPorts, error)) *MockControllerBackendAPIHostPortsForAgentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerBackendAPIHostPortsForAgentsCall) DoAndReturn(f func(controller.Config) ([]network.SpaceHostPorts, error)) *MockControllerBackendAPIHostPortsForAgentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ControllerTag mocks base method.
func (m *MockControllerBackend) ControllerTag() names.ControllerTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerTag")
	ret0, _ := ret[0].(names.ControllerTag)
	return ret0
}

// ControllerTag indicates an expected call of ControllerTag.
func (mr *MockControllerBackendMockRecorder) ControllerTag() *MockControllerBackendControllerTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerTag", reflect.TypeOf((*MockControllerBackend)(nil).ControllerTag))
	return &MockControllerBackendControllerTagCall{Call: call}
}

// MockControllerBackendControllerTagCall wrap *gomock.Call
type MockControllerBackendControllerTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerBackendControllerTagCall) Return(arg0 names.ControllerTag) *MockControllerBackendControllerTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerBackendControllerTagCall) Do(f func() names.ControllerTag) *MockControllerBackendControllerTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerBackendControllerTagCall) DoAndReturn(f func() names.ControllerTag) *MockControllerBackendControllerTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockInstanceConfigBackend is a mock of InstanceConfigBackend interface.
type MockInstanceConfigBackend struct {
	ctrl     *gomock.Controller
	recorder *MockInstanceConfigBackendMockRecorder
}

// MockInstanceConfigBackendMockRecorder is the mock recorder for MockInstanceConfigBackend.
type MockInstanceConfigBackendMockRecorder struct {
	mock *MockInstanceConfigBackend
}

// NewMockInstanceConfigBackend creates a new mock instance.
func NewMockInstanceConfigBackend(ctrl *gomock.Controller) *MockInstanceConfigBackend {
	mock := &MockInstanceConfigBackend{ctrl: ctrl}
	mock.recorder = &MockInstanceConfigBackendMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstanceConfigBackend) EXPECT() *MockInstanceConfigBackendMockRecorder {
	return m.recorder
}

// Machine mocks base method.
func (m *MockInstanceConfigBackend) Machine(arg0 string) (machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Machine", arg0)
	ret0, _ := ret[0].(machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Machine indicates an expected call of Machine.
func (mr *MockInstanceConfigBackendMockRecorder) Machine(arg0 any) *MockInstanceConfigBackendMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Machine", reflect.TypeOf((*MockInstanceConfigBackend)(nil).Machine), arg0)
	return &MockInstanceConfigBackendMachineCall{Call: call}
}

// MockInstanceConfigBackendMachineCall wrap *gomock.Call
type MockInstanceConfigBackendMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInstanceConfigBackendMachineCall) Return(arg0 machinemanager.Machine, arg1 error) *MockInstanceConfigBackendMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInstanceConfigBackendMachineCall) Do(f func(string) (machinemanager.Machine, error)) *MockInstanceConfigBackendMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInstanceConfigBackendMachineCall) DoAndReturn(f func(string) (machinemanager.Machine, error)) *MockInstanceConfigBackendMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Model mocks base method.
func (m *MockInstanceConfigBackend) Model() (machinemanager.Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Model")
	ret0, _ := ret[0].(machinemanager.Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Model indicates an expected call of Model.
func (mr *MockInstanceConfigBackendMockRecorder) Model() *MockInstanceConfigBackendModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Model", reflect.TypeOf((*MockInstanceConfigBackend)(nil).Model))
	return &MockInstanceConfigBackendModelCall{Call: call}
}

// MockInstanceConfigBackendModelCall wrap *gomock.Call
type MockInstanceConfigBackendModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInstanceConfigBackendModelCall) Return(arg0 machinemanager.Model, arg1 error) *MockInstanceConfigBackendModelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInstanceConfigBackendModelCall) Do(f func() (machinemanager.Model, error)) *MockInstanceConfigBackendModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInstanceConfigBackendModelCall) DoAndReturn(f func() (machinemanager.Model, error)) *MockInstanceConfigBackendModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ToolsStorage mocks base method.
func (m *MockInstanceConfigBackend) ToolsStorage(arg0 objectstore.ObjectStore) (binarystorage.StorageCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToolsStorage", arg0)
	ret0, _ := ret[0].(binarystorage.StorageCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ToolsStorage indicates an expected call of ToolsStorage.
func (mr *MockInstanceConfigBackendMockRecorder) ToolsStorage(arg0 any) *MockInstanceConfigBackendToolsStorageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToolsStorage", reflect.TypeOf((*MockInstanceConfigBackend)(nil).ToolsStorage), arg0)
	return &MockInstanceConfigBackendToolsStorageCall{Call: call}
}

// MockInstanceConfigBackendToolsStorageCall wrap *gomock.Call
type MockInstanceConfigBackendToolsStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInstanceConfigBackendToolsStorageCall) Return(arg0 binarystorage.StorageCloser, arg1 error) *MockInstanceConfigBackendToolsStorageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInstanceConfigBackendToolsStorageCall) Do(f func(objectstore.ObjectStore) (binarystorage.StorageCloser, error)) *MockInstanceConfigBackendToolsStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInstanceConfigBackendToolsStorageCall) DoAndReturn(f func(objectstore.ObjectStore) (binarystorage.StorageCloser, error)) *MockInstanceConfigBackendToolsStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockBackend is a mock of Backend interface.
type MockBackend struct {
	ctrl     *gomock.Controller
	recorder *MockBackendMockRecorder
}

// MockBackendMockRecorder is the mock recorder for MockBackend.
type MockBackendMockRecorder struct {
	mock *MockBackend
}

// NewMockBackend creates a new mock instance.
func NewMockBackend(ctrl *gomock.Controller) *MockBackend {
	mock := &MockBackend{ctrl: ctrl}
	mock.recorder = &MockBackendMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackend) EXPECT() *MockBackendMockRecorder {
	return m.recorder
}

// AddMachineInsideMachine mocks base method.
func (m *MockBackend) AddMachineInsideMachine(arg0 state.MachineTemplate, arg1 string, arg2 instance.ContainerType) (machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddMachineInsideMachine", arg0, arg1, arg2)
	ret0, _ := ret[0].(machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddMachineInsideMachine indicates an expected call of AddMachineInsideMachine.
func (mr *MockBackendMockRecorder) AddMachineInsideMachine(arg0, arg1, arg2 any) *MockBackendAddMachineInsideMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddMachineInsideMachine", reflect.TypeOf((*MockBackend)(nil).AddMachineInsideMachine), arg0, arg1, arg2)
	return &MockBackendAddMachineInsideMachineCall{Call: call}
}

// MockBackendAddMachineInsideMachineCall wrap *gomock.Call
type MockBackendAddMachineInsideMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddMachineInsideMachineCall) Return(arg0 machinemanager.Machine, arg1 error) *MockBackendAddMachineInsideMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddMachineInsideMachineCall) Do(f func(state.MachineTemplate, string, instance.ContainerType) (machinemanager.Machine, error)) *MockBackendAddMachineInsideMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddMachineInsideMachineCall) DoAndReturn(f func(state.MachineTemplate, string, instance.ContainerType) (machinemanager.Machine, error)) *MockBackendAddMachineInsideMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddMachineInsideNewMachine mocks base method.
func (m *MockBackend) AddMachineInsideNewMachine(arg0, arg1 state.MachineTemplate, arg2 instance.ContainerType) (machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddMachineInsideNewMachine", arg0, arg1, arg2)
	ret0, _ := ret[0].(machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddMachineInsideNewMachine indicates an expected call of AddMachineInsideNewMachine.
func (mr *MockBackendMockRecorder) AddMachineInsideNewMachine(arg0, arg1, arg2 any) *MockBackendAddMachineInsideNewMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddMachineInsideNewMachine", reflect.TypeOf((*MockBackend)(nil).AddMachineInsideNewMachine), arg0, arg1, arg2)
	return &MockBackendAddMachineInsideNewMachineCall{Call: call}
}

// MockBackendAddMachineInsideNewMachineCall wrap *gomock.Call
type MockBackendAddMachineInsideNewMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddMachineInsideNewMachineCall) Return(arg0 machinemanager.Machine, arg1 error) *MockBackendAddMachineInsideNewMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddMachineInsideNewMachineCall) Do(f func(state.MachineTemplate, state.MachineTemplate, instance.ContainerType) (machinemanager.Machine, error)) *MockBackendAddMachineInsideNewMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddMachineInsideNewMachineCall) DoAndReturn(f func(state.MachineTemplate, state.MachineTemplate, instance.ContainerType) (machinemanager.Machine, error)) *MockBackendAddMachineInsideNewMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddOneMachine mocks base method.
func (m *MockBackend) AddOneMachine(arg0 state.MachineTemplate) (machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddOneMachine", arg0)
	ret0, _ := ret[0].(machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddOneMachine indicates an expected call of AddOneMachine.
func (mr *MockBackendMockRecorder) AddOneMachine(arg0 any) *MockBackendAddOneMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddOneMachine", reflect.TypeOf((*MockBackend)(nil).AddOneMachine), arg0)
	return &MockBackendAddOneMachineCall{Call: call}
}

// MockBackendAddOneMachineCall wrap *gomock.Call
type MockBackendAddOneMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAddOneMachineCall) Return(arg0 machinemanager.Machine, arg1 error) *MockBackendAddOneMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAddOneMachineCall) Do(f func(state.MachineTemplate) (machinemanager.Machine, error)) *MockBackendAddOneMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAddOneMachineCall) DoAndReturn(f func(state.MachineTemplate) (machinemanager.Machine, error)) *MockBackendAddOneMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AllMachines mocks base method.
func (m *MockBackend) AllMachines() ([]machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllMachines")
	ret0, _ := ret[0].([]machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllMachines indicates an expected call of AllMachines.
func (mr *MockBackendMockRecorder) AllMachines() *MockBackendAllMachinesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllMachines", reflect.TypeOf((*MockBackend)(nil).AllMachines))
	return &MockBackendAllMachinesCall{Call: call}
}

// MockBackendAllMachinesCall wrap *gomock.Call
type MockBackendAllMachinesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendAllMachinesCall) Return(arg0 []machinemanager.Machine, arg1 error) *MockBackendAllMachinesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendAllMachinesCall) Do(f func() ([]machinemanager.Machine, error)) *MockBackendAllMachinesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendAllMachinesCall) DoAndReturn(f func() ([]machinemanager.Machine, error)) *MockBackendAllMachinesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Application mocks base method.
func (m *MockBackend) Application(arg0 string) (machinemanager.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Application", arg0)
	ret0, _ := ret[0].(machinemanager.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Application indicates an expected call of Application.
func (mr *MockBackendMockRecorder) Application(arg0 any) *MockBackendApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Application", reflect.TypeOf((*MockBackend)(nil).Application), arg0)
	return &MockBackendApplicationCall{Call: call}
}

// MockBackendApplicationCall wrap *gomock.Call
type MockBackendApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendApplicationCall) Return(arg0 machinemanager.Application, arg1 error) *MockBackendApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendApplicationCall) Do(f func(string) (machinemanager.Application, error)) *MockBackendApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendApplicationCall) DoAndReturn(f func(string) (machinemanager.Application, error)) *MockBackendApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockForType mocks base method.
func (m *MockBackend) GetBlockForType(arg0 state.BlockType) (state.Block, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockForType", arg0)
	ret0, _ := ret[0].(state.Block)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetBlockForType indicates an expected call of GetBlockForType.
func (mr *MockBackendMockRecorder) GetBlockForType(arg0 any) *MockBackendGetBlockForTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockForType", reflect.TypeOf((*MockBackend)(nil).GetBlockForType), arg0)
	return &MockBackendGetBlockForTypeCall{Call: call}
}

// MockBackendGetBlockForTypeCall wrap *gomock.Call
type MockBackendGetBlockForTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendGetBlockForTypeCall) Return(arg0 state.Block, arg1 bool, arg2 error) *MockBackendGetBlockForTypeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendGetBlockForTypeCall) Do(f func(state.BlockType) (state.Block, bool, error)) *MockBackendGetBlockForTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendGetBlockForTypeCall) DoAndReturn(f func(state.BlockType) (state.Block, bool, error)) *MockBackendGetBlockForTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Machine mocks base method.
func (m *MockBackend) Machine(arg0 string) (machinemanager.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Machine", arg0)
	ret0, _ := ret[0].(machinemanager.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Machine indicates an expected call of Machine.
func (mr *MockBackendMockRecorder) Machine(arg0 any) *MockBackendMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Machine", reflect.TypeOf((*MockBackend)(nil).Machine), arg0)
	return &MockBackendMachineCall{Call: call}
}

// MockBackendMachineCall wrap *gomock.Call
type MockBackendMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendMachineCall) Return(arg0 machinemanager.Machine, arg1 error) *MockBackendMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendMachineCall) Do(f func(string) (machinemanager.Machine, error)) *MockBackendMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendMachineCall) DoAndReturn(f func(string) (machinemanager.Machine, error)) *MockBackendMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Model mocks base method.
func (m *MockBackend) Model() (machinemanager.Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Model")
	ret0, _ := ret[0].(machinemanager.Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Model indicates an expected call of Model.
func (mr *MockBackendMockRecorder) Model() *MockBackendModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Model", reflect.TypeOf((*MockBackend)(nil).Model))
	return &MockBackendModelCall{Call: call}
}

// MockBackendModelCall wrap *gomock.Call
type MockBackendModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendModelCall) Return(arg0 machinemanager.Model, arg1 error) *MockBackendModelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendModelCall) Do(f func() (machinemanager.Model, error)) *MockBackendModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendModelCall) DoAndReturn(f func() (machinemanager.Model, error)) *MockBackendModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ToolsStorage mocks base method.
func (m *MockBackend) ToolsStorage(arg0 objectstore.ObjectStore) (binarystorage.StorageCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToolsStorage", arg0)
	ret0, _ := ret[0].(binarystorage.StorageCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ToolsStorage indicates an expected call of ToolsStorage.
func (mr *MockBackendMockRecorder) ToolsStorage(arg0 any) *MockBackendToolsStorageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToolsStorage", reflect.TypeOf((*MockBackend)(nil).ToolsStorage), arg0)
	return &MockBackendToolsStorageCall{Call: call}
}

// MockBackendToolsStorageCall wrap *gomock.Call
type MockBackendToolsStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendToolsStorageCall) Return(arg0 binarystorage.StorageCloser, arg1 error) *MockBackendToolsStorageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendToolsStorageCall) Do(f func(objectstore.ObjectStore) (binarystorage.StorageCloser, error)) *MockBackendToolsStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendToolsStorageCall) DoAndReturn(f func(objectstore.ObjectStore) (binarystorage.StorageCloser, error)) *MockBackendToolsStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unit mocks base method.
func (m *MockBackend) Unit(arg0 string) (machinemanager.Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unit", arg0)
	ret0, _ := ret[0].(machinemanager.Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unit indicates an expected call of Unit.
func (mr *MockBackendMockRecorder) Unit(arg0 any) *MockBackendUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unit", reflect.TypeOf((*MockBackend)(nil).Unit), arg0)
	return &MockBackendUnitCall{Call: call}
}

// MockBackendUnitCall wrap *gomock.Call
type MockBackendUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBackendUnitCall) Return(arg0 machinemanager.Unit, arg1 error) *MockBackendUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBackendUnitCall) Do(f func(string) (machinemanager.Unit, error)) *MockBackendUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBackendUnitCall) DoAndReturn(f func(string) (machinemanager.Unit, error)) *MockBackendUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStorageInterface is a mock of StorageInterface interface.
type MockStorageInterface struct {
	ctrl     *gomock.Controller
	recorder *MockStorageInterfaceMockRecorder
}

// MockStorageInterfaceMockRecorder is the mock recorder for MockStorageInterface.
type MockStorageInterfaceMockRecorder struct {
	mock *MockStorageInterface
}

// NewMockStorageInterface creates a new mock instance.
func NewMockStorageInterface(ctrl *gomock.Controller) *MockStorageInterface {
	mock := &MockStorageInterface{ctrl: ctrl}
	mock.recorder = &MockStorageInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorageInterface) EXPECT() *MockStorageInterfaceMockRecorder {
	return m.recorder
}

// FilesystemAccess mocks base method.
func (m *MockStorageInterface) FilesystemAccess() storagecommon.FilesystemAccess {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilesystemAccess")
	ret0, _ := ret[0].(storagecommon.FilesystemAccess)
	return ret0
}

// FilesystemAccess indicates an expected call of FilesystemAccess.
func (mr *MockStorageInterfaceMockRecorder) FilesystemAccess() *MockStorageInterfaceFilesystemAccessCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilesystemAccess", reflect.TypeOf((*MockStorageInterface)(nil).FilesystemAccess))
	return &MockStorageInterfaceFilesystemAccessCall{Call: call}
}

// MockStorageInterfaceFilesystemAccessCall wrap *gomock.Call
type MockStorageInterfaceFilesystemAccessCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceFilesystemAccessCall) Return(arg0 storagecommon.FilesystemAccess) *MockStorageInterfaceFilesystemAccessCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceFilesystemAccessCall) Do(f func() storagecommon.FilesystemAccess) *MockStorageInterfaceFilesystemAccessCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceFilesystemAccessCall) DoAndReturn(f func() storagecommon.FilesystemAccess) *MockStorageInterfaceFilesystemAccessCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageInstance mocks base method.
func (m *MockStorageInterface) StorageInstance(arg0 names.StorageTag) (state.StorageInstance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageInstance", arg0)
	ret0, _ := ret[0].(state.StorageInstance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageInstance indicates an expected call of StorageInstance.
func (mr *MockStorageInterfaceMockRecorder) StorageInstance(arg0 any) *MockStorageInterfaceStorageInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageInstance", reflect.TypeOf((*MockStorageInterface)(nil).StorageInstance), arg0)
	return &MockStorageInterfaceStorageInstanceCall{Call: call}
}

// MockStorageInterfaceStorageInstanceCall wrap *gomock.Call
type MockStorageInterfaceStorageInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceStorageInstanceCall) Return(arg0 state.StorageInstance, arg1 error) *MockStorageInterfaceStorageInstanceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceStorageInstanceCall) Do(f func(names.StorageTag) (state.StorageInstance, error)) *MockStorageInterfaceStorageInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceStorageInstanceCall) DoAndReturn(f func(names.StorageTag) (state.StorageInstance, error)) *MockStorageInterfaceStorageInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitStorageAttachments mocks base method.
func (m *MockStorageInterface) UnitStorageAttachments(arg0 names.UnitTag) ([]state.StorageAttachment, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitStorageAttachments", arg0)
	ret0, _ := ret[0].([]state.StorageAttachment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnitStorageAttachments indicates an expected call of UnitStorageAttachments.
func (mr *MockStorageInterfaceMockRecorder) UnitStorageAttachments(arg0 any) *MockStorageInterfaceUnitStorageAttachmentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitStorageAttachments", reflect.TypeOf((*MockStorageInterface)(nil).UnitStorageAttachments), arg0)
	return &MockStorageInterfaceUnitStorageAttachmentsCall{Call: call}
}

// MockStorageInterfaceUnitStorageAttachmentsCall wrap *gomock.Call
type MockStorageInterfaceUnitStorageAttachmentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceUnitStorageAttachmentsCall) Return(arg0 []state.StorageAttachment, arg1 error) *MockStorageInterfaceUnitStorageAttachmentsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceUnitStorageAttachmentsCall) Do(f func(names.UnitTag) ([]state.StorageAttachment, error)) *MockStorageInterfaceUnitStorageAttachmentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceUnitStorageAttachmentsCall) DoAndReturn(f func(names.UnitTag) ([]state.StorageAttachment, error)) *MockStorageInterfaceUnitStorageAttachmentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VolumeAccess mocks base method.
func (m *MockStorageInterface) VolumeAccess() storagecommon.VolumeAccess {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VolumeAccess")
	ret0, _ := ret[0].(storagecommon.VolumeAccess)
	return ret0
}

// VolumeAccess indicates an expected call of VolumeAccess.
func (mr *MockStorageInterfaceMockRecorder) VolumeAccess() *MockStorageInterfaceVolumeAccessCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VolumeAccess", reflect.TypeOf((*MockStorageInterface)(nil).VolumeAccess))
	return &MockStorageInterfaceVolumeAccessCall{Call: call}
}

// MockStorageInterfaceVolumeAccessCall wrap *gomock.Call
type MockStorageInterfaceVolumeAccessCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStorageInterfaceVolumeAccessCall) Return(arg0 storagecommon.VolumeAccess) *MockStorageInterfaceVolumeAccessCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStorageInterfaceVolumeAccessCall) Do(f func() storagecommon.VolumeAccess) *MockStorageInterfaceVolumeAccessCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStorageInterfaceVolumeAccessCall) DoAndReturn(f func() storagecommon.VolumeAccess) *MockStorageInterfaceVolumeAccessCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockPool is a mock of Pool interface.
type MockPool struct {
	ctrl     *gomock.Controller
	recorder *MockPoolMockRecorder
}

// MockPoolMockRecorder is the mock recorder for MockPool.
type MockPoolMockRecorder struct {
	mock *MockPool
}

// NewMockPool creates a new mock instance.
func NewMockPool(ctrl *gomock.Controller) *MockPool {
	mock := &MockPool{ctrl: ctrl}
	mock.recorder = &MockPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPool) EXPECT() *MockPoolMockRecorder {
	return m.recorder
}

// GetModel mocks base method.
func (m *MockPool) GetModel(arg0 string) (machinemanager.Model, func(), error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModel", arg0)
	ret0, _ := ret[0].(machinemanager.Model)
	ret1, _ := ret[1].(func())
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetModel indicates an expected call of GetModel.
func (mr *MockPoolMockRecorder) GetModel(arg0 any) *MockPoolGetModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModel", reflect.TypeOf((*MockPool)(nil).GetModel), arg0)
	return &MockPoolGetModelCall{Call: call}
}

// MockPoolGetModelCall wrap *gomock.Call
type MockPoolGetModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolGetModelCall) Return(arg0 machinemanager.Model, arg1 func(), arg2 error) *MockPoolGetModelCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolGetModelCall) Do(f func(string) (machinemanager.Model, func(), error)) *MockPoolGetModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolGetModelCall) DoAndReturn(f func(string) (machinemanager.Model, func(), error)) *MockPoolGetModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SystemState mocks base method.
func (m *MockPool) SystemState() (machinemanager.ControllerBackend, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SystemState")
	ret0, _ := ret[0].(machinemanager.ControllerBackend)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SystemState indicates an expected call of SystemState.
func (mr *MockPoolMockRecorder) SystemState() *MockPoolSystemStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SystemState", reflect.TypeOf((*MockPool)(nil).SystemState))
	return &MockPoolSystemStateCall{Call: call}
}

// MockPoolSystemStateCall wrap *gomock.Call
type MockPoolSystemStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolSystemStateCall) Return(arg0 machinemanager.ControllerBackend, arg1 error) *MockPoolSystemStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolSystemStateCall) Do(f func() (machinemanager.ControllerBackend, error)) *MockPoolSystemStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolSystemStateCall) DoAndReturn(f func() (machinemanager.ControllerBackend, error)) *MockPoolSystemStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockModel is a mock of Model interface.
type MockModel struct {
	ctrl     *gomock.Controller
	recorder *MockModelMockRecorder
}

// MockModelMockRecorder is the mock recorder for MockModel.
type MockModelMockRecorder struct {
	mock *MockModel
}

// NewMockModel creates a new mock instance.
func NewMockModel(ctrl *gomock.Controller) *MockModel {
	mock := &MockModel{ctrl: ctrl}
	mock.recorder = &MockModelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModel) EXPECT() *MockModelMockRecorder {
	return m.recorder
}

// CloudCredentialTag mocks base method.
func (m *MockModel) CloudCredentialTag() (names.CloudCredentialTag, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudCredentialTag")
	ret0, _ := ret[0].(names.CloudCredentialTag)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// CloudCredentialTag indicates an expected call of CloudCredentialTag.
func (mr *MockModelMockRecorder) CloudCredentialTag() *MockModelCloudCredentialTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudCredentialTag", reflect.TypeOf((*MockModel)(nil).CloudCredentialTag))
	return &MockModelCloudCredentialTagCall{Call: call}
}

// MockModelCloudCredentialTagCall wrap *gomock.Call
type MockModelCloudCredentialTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudCredentialTagCall) Return(arg0 names.CloudCredentialTag, arg1 bool) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudCredentialTagCall) Do(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudCredentialTagCall) DoAndReturn(f func() (names.CloudCredentialTag, bool)) *MockModelCloudCredentialTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudName mocks base method.
func (m *MockModel) CloudName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudName")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudName indicates an expected call of CloudName.
func (mr *MockModelMockRecorder) CloudName() *MockModelCloudNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudName", reflect.TypeOf((*MockModel)(nil).CloudName))
	return &MockModelCloudNameCall{Call: call}
}

// MockModelCloudNameCall wrap *gomock.Call
type MockModelCloudNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudNameCall) Return(arg0 string) *MockModelCloudNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudNameCall) Do(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudNameCall) DoAndReturn(f func() string) *MockModelCloudNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudRegion mocks base method.
func (m *MockModel) CloudRegion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudRegion")
	ret0, _ := ret[0].(string)
	return ret0
}

// CloudRegion indicates an expected call of CloudRegion.
func (mr *MockModelMockRecorder) CloudRegion() *MockModelCloudRegionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudRegion", reflect.TypeOf((*MockModel)(nil).CloudRegion))
	return &MockModelCloudRegionCall{Call: call}
}

// MockModelCloudRegionCall wrap *gomock.Call
type MockModelCloudRegionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelCloudRegionCall) Return(arg0 string) *MockModelCloudRegionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelCloudRegionCall) Do(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelCloudRegionCall) DoAndReturn(f func() string) *MockModelCloudRegionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockModel) Config() (*config.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*config.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Config indicates an expected call of Config.
func (mr *MockModelMockRecorder) Config() *MockModelConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockModel)(nil).Config))
	return &MockModelConfigCall{Call: call}
}

// MockModelConfigCall wrap *gomock.Call
type MockModelConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelConfigCall) Return(arg0 *config.Config, arg1 error) *MockModelConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelConfigCall) Do(f func() (*config.Config, error)) *MockModelConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelConfigCall) DoAndReturn(f func() (*config.Config, error)) *MockModelConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ControllerUUID mocks base method.
func (m *MockModel) ControllerUUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerUUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ControllerUUID indicates an expected call of ControllerUUID.
func (mr *MockModelMockRecorder) ControllerUUID() *MockModelControllerUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerUUID", reflect.TypeOf((*MockModel)(nil).ControllerUUID))
	return &MockModelControllerUUIDCall{Call: call}
}

// MockModelControllerUUIDCall wrap *gomock.Call
type MockModelControllerUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelControllerUUIDCall) Return(arg0 string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelControllerUUIDCall) Do(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelControllerUUIDCall) DoAndReturn(f func() string) *MockModelControllerUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelTag mocks base method.
func (m *MockModel) ModelTag() names.ModelTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelTag")
	ret0, _ := ret[0].(names.ModelTag)
	return ret0
}

// ModelTag indicates an expected call of ModelTag.
func (mr *MockModelMockRecorder) ModelTag() *MockModelModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelTag", reflect.TypeOf((*MockModel)(nil).ModelTag))
	return &MockModelModelTagCall{Call: call}
}

// MockModelModelTagCall wrap *gomock.Call
type MockModelModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelTagCall) Return(arg0 names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelTagCall) Do(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelTagCall) DoAndReturn(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockModel) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockModelMockRecorder) Name() *MockModelNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockModel)(nil).Name))
	return &MockModelNameCall{Call: call}
}

// MockModelNameCall wrap *gomock.Call
type MockModelNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelNameCall) Return(arg0 string) *MockModelNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelNameCall) Do(f func() string) *MockModelNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelNameCall) DoAndReturn(f func() string) *MockModelNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockModel) Type() state.ModelType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(state.ModelType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockModelMockRecorder) Type() *MockModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockModel)(nil).Type))
	return &MockModelTypeCall{Call: call}
}

// MockModelTypeCall wrap *gomock.Call
type MockModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTypeCall) Return(arg0 state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTypeCall) Do(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTypeCall) DoAndReturn(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UUID mocks base method.
func (m *MockModel) UUID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UUID")
	ret0, _ := ret[0].(string)
	return ret0
}

// UUID indicates an expected call of UUID.
func (mr *MockModelMockRecorder) UUID() *MockModelUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UUID", reflect.TypeOf((*MockModel)(nil).UUID))
	return &MockModelUUIDCall{Call: call}
}

// MockModelUUIDCall wrap *gomock.Call
type MockModelUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelUUIDCall) Return(arg0 string) *MockModelUUIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelUUIDCall) Do(f func() string) *MockModelUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelUUIDCall) DoAndReturn(f func() string) *MockModelUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockMachine is a mock of Machine interface.
type MockMachine struct {
	ctrl     *gomock.Controller
	recorder *MockMachineMockRecorder
}

// MockMachineMockRecorder is the mock recorder for MockMachine.
type MockMachineMockRecorder struct {
	mock *MockMachine
}

// NewMockMachine creates a new mock instance.
func NewMockMachine(ctrl *gomock.Controller) *MockMachine {
	mock := &MockMachine{ctrl: ctrl}
	mock.recorder = &MockMachineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachine) EXPECT() *MockMachineMockRecorder {
	return m.recorder
}

// ApplicationNames mocks base method.
func (m *MockMachine) ApplicationNames() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplicationNames")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplicationNames indicates an expected call of ApplicationNames.
func (mr *MockMachineMockRecorder) ApplicationNames() *MockMachineApplicationNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplicationNames", reflect.TypeOf((*MockMachine)(nil).ApplicationNames))
	return &MockMachineApplicationNamesCall{Call: call}
}

// MockMachineApplicationNamesCall wrap *gomock.Call
type MockMachineApplicationNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineApplicationNamesCall) Return(arg0 []string, arg1 error) *MockMachineApplicationNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineApplicationNamesCall) Do(f func() ([]string, error)) *MockMachineApplicationNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineApplicationNamesCall) DoAndReturn(f func() ([]string, error)) *MockMachineApplicationNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Base mocks base method.
func (m *MockMachine) Base() state.Base {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Base")
	ret0, _ := ret[0].(state.Base)
	return ret0
}

// Base indicates an expected call of Base.
func (mr *MockMachineMockRecorder) Base() *MockMachineBaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Base", reflect.TypeOf((*MockMachine)(nil).Base))
	return &MockMachineBaseCall{Call: call}
}

// MockMachineBaseCall wrap *gomock.Call
type MockMachineBaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineBaseCall) Return(arg0 state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineBaseCall) Do(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineBaseCall) DoAndReturn(f func() state.Base) *MockMachineBaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CompleteUpgradeSeries mocks base method.
func (m *MockMachine) CompleteUpgradeSeries() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompleteUpgradeSeries")
	ret0, _ := ret[0].(error)
	return ret0
}

// CompleteUpgradeSeries indicates an expected call of CompleteUpgradeSeries.
func (mr *MockMachineMockRecorder) CompleteUpgradeSeries() *MockMachineCompleteUpgradeSeriesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompleteUpgradeSeries", reflect.TypeOf((*MockMachine)(nil).CompleteUpgradeSeries))
	return &MockMachineCompleteUpgradeSeriesCall{Call: call}
}

// MockMachineCompleteUpgradeSeriesCall wrap *gomock.Call
type MockMachineCompleteUpgradeSeriesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineCompleteUpgradeSeriesCall) Return(arg0 error) *MockMachineCompleteUpgradeSeriesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineCompleteUpgradeSeriesCall) Do(f func() error) *MockMachineCompleteUpgradeSeriesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineCompleteUpgradeSeriesCall) DoAndReturn(f func() error) *MockMachineCompleteUpgradeSeriesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Containers mocks base method.
func (m *MockMachine) Containers() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Containers")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Containers indicates an expected call of Containers.
func (mr *MockMachineMockRecorder) Containers() *MockMachineContainersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Containers", reflect.TypeOf((*MockMachine)(nil).Containers))
	return &MockMachineContainersCall{Call: call}
}

// MockMachineContainersCall wrap *gomock.Call
type MockMachineContainersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineContainersCall) Return(arg0 []string, arg1 error) *MockMachineContainersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineContainersCall) Do(f func() ([]string, error)) *MockMachineContainersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineContainersCall) DoAndReturn(f func() ([]string, error)) *MockMachineContainersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateUpgradeSeriesLock mocks base method.
func (m *MockMachine) CreateUpgradeSeriesLock(arg0 []string, arg1 state.Base) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUpgradeSeriesLock", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUpgradeSeriesLock indicates an expected call of CreateUpgradeSeriesLock.
func (mr *MockMachineMockRecorder) CreateUpgradeSeriesLock(arg0, arg1 any) *MockMachineCreateUpgradeSeriesLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUpgradeSeriesLock", reflect.TypeOf((*MockMachine)(nil).CreateUpgradeSeriesLock), arg0, arg1)
	return &MockMachineCreateUpgradeSeriesLockCall{Call: call}
}

// MockMachineCreateUpgradeSeriesLockCall wrap *gomock.Call
type MockMachineCreateUpgradeSeriesLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineCreateUpgradeSeriesLockCall) Return(arg0 error) *MockMachineCreateUpgradeSeriesLockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineCreateUpgradeSeriesLockCall) Do(f func([]string, state.Base) error) *MockMachineCreateUpgradeSeriesLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineCreateUpgradeSeriesLockCall) DoAndReturn(f func([]string, state.Base) error) *MockMachineCreateUpgradeSeriesLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Destroy mocks base method.
func (m *MockMachine) Destroy(arg0 objectstore.ObjectStore) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockMachineMockRecorder) Destroy(arg0 any) *MockMachineDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockMachine)(nil).Destroy), arg0)
	return &MockMachineDestroyCall{Call: call}
}

// MockMachineDestroyCall wrap *gomock.Call
type MockMachineDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineDestroyCall) Return(arg0 error) *MockMachineDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineDestroyCall) Do(f func(objectstore.ObjectStore) error) *MockMachineDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineDestroyCall) DoAndReturn(f func(objectstore.ObjectStore) error) *MockMachineDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ForceDestroy mocks base method.
func (m *MockMachine) ForceDestroy(arg0 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForceDestroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ForceDestroy indicates an expected call of ForceDestroy.
func (mr *MockMachineMockRecorder) ForceDestroy(arg0 any) *MockMachineForceDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForceDestroy", reflect.TypeOf((*MockMachine)(nil).ForceDestroy), arg0)
	return &MockMachineForceDestroyCall{Call: call}
}

// MockMachineForceDestroyCall wrap *gomock.Call
type MockMachineForceDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineForceDestroyCall) Return(arg0 error) *MockMachineForceDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineForceDestroyCall) Do(f func(time.Duration) error) *MockMachineForceDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineForceDestroyCall) DoAndReturn(f func(time.Duration) error) *MockMachineForceDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUpgradeSeriesMessages mocks base method.
func (m *MockMachine) GetUpgradeSeriesMessages() ([]string, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUpgradeSeriesMessages")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUpgradeSeriesMessages indicates an expected call of GetUpgradeSeriesMessages.
func (mr *MockMachineMockRecorder) GetUpgradeSeriesMessages() *MockMachineGetUpgradeSeriesMessagesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUpgradeSeriesMessages", reflect.TypeOf((*MockMachine)(nil).GetUpgradeSeriesMessages))
	return &MockMachineGetUpgradeSeriesMessagesCall{Call: call}
}

// MockMachineGetUpgradeSeriesMessagesCall wrap *gomock.Call
type MockMachineGetUpgradeSeriesMessagesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineGetUpgradeSeriesMessagesCall) Return(arg0 []string, arg1 bool, arg2 error) *MockMachineGetUpgradeSeriesMessagesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineGetUpgradeSeriesMessagesCall) Do(f func() ([]string, bool, error)) *MockMachineGetUpgradeSeriesMessagesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineGetUpgradeSeriesMessagesCall) DoAndReturn(f func() ([]string, bool, error)) *MockMachineGetUpgradeSeriesMessagesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HardwareCharacteristics mocks base method.
func (m *MockMachine) HardwareCharacteristics() (*instance.HardwareCharacteristics, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HardwareCharacteristics")
	ret0, _ := ret[0].(*instance.HardwareCharacteristics)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HardwareCharacteristics indicates an expected call of HardwareCharacteristics.
func (mr *MockMachineMockRecorder) HardwareCharacteristics() *MockMachineHardwareCharacteristicsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HardwareCharacteristics", reflect.TypeOf((*MockMachine)(nil).HardwareCharacteristics))
	return &MockMachineHardwareCharacteristicsCall{Call: call}
}

// MockMachineHardwareCharacteristicsCall wrap *gomock.Call
type MockMachineHardwareCharacteristicsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineHardwareCharacteristicsCall) Return(arg0 *instance.HardwareCharacteristics, arg1 error) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineHardwareCharacteristicsCall) Do(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineHardwareCharacteristicsCall) DoAndReturn(f func() (*instance.HardwareCharacteristics, error)) *MockMachineHardwareCharacteristicsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Id mocks base method.
func (m *MockMachine) Id() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Id")
	ret0, _ := ret[0].(string)
	return ret0
}

// Id indicates an expected call of Id.
func (mr *MockMachineMockRecorder) Id() *MockMachineIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Id", reflect.TypeOf((*MockMachine)(nil).Id))
	return &MockMachineIdCall{Call: call}
}

// MockMachineIdCall wrap *gomock.Call
type MockMachineIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIdCall) Return(arg0 string) *MockMachineIdCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIdCall) Do(f func() string) *MockMachineIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIdCall) DoAndReturn(f func() string) *MockMachineIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceStatus mocks base method.
func (m *MockMachine) InstanceStatus() (status.StatusInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceStatus")
	ret0, _ := ret[0].(status.StatusInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InstanceStatus indicates an expected call of InstanceStatus.
func (mr *MockMachineMockRecorder) InstanceStatus() *MockMachineInstanceStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceStatus", reflect.TypeOf((*MockMachine)(nil).InstanceStatus))
	return &MockMachineInstanceStatusCall{Call: call}
}

// MockMachineInstanceStatusCall wrap *gomock.Call
type MockMachineInstanceStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineInstanceStatusCall) Return(arg0 status.StatusInfo, arg1 error) *MockMachineInstanceStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineInstanceStatusCall) Do(f func() (status.StatusInfo, error)) *MockMachineInstanceStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineInstanceStatusCall) DoAndReturn(f func() (status.StatusInfo, error)) *MockMachineInstanceStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsLockedForSeriesUpgrade mocks base method.
func (m *MockMachine) IsLockedForSeriesUpgrade() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLockedForSeriesUpgrade")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLockedForSeriesUpgrade indicates an expected call of IsLockedForSeriesUpgrade.
func (mr *MockMachineMockRecorder) IsLockedForSeriesUpgrade() *MockMachineIsLockedForSeriesUpgradeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLockedForSeriesUpgrade", reflect.TypeOf((*MockMachine)(nil).IsLockedForSeriesUpgrade))
	return &MockMachineIsLockedForSeriesUpgradeCall{Call: call}
}

// MockMachineIsLockedForSeriesUpgradeCall wrap *gomock.Call
type MockMachineIsLockedForSeriesUpgradeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsLockedForSeriesUpgradeCall) Return(arg0 bool, arg1 error) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsLockedForSeriesUpgradeCall) Do(f func() (bool, error)) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsLockedForSeriesUpgradeCall) DoAndReturn(f func() (bool, error)) *MockMachineIsLockedForSeriesUpgradeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsManager mocks base method.
func (m *MockMachine) IsManager() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsManager")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsManager indicates an expected call of IsManager.
func (mr *MockMachineMockRecorder) IsManager() *MockMachineIsManagerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsManager", reflect.TypeOf((*MockMachine)(nil).IsManager))
	return &MockMachineIsManagerCall{Call: call}
}

// MockMachineIsManagerCall wrap *gomock.Call
type MockMachineIsManagerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsManagerCall) Return(arg0 bool) *MockMachineIsManagerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsManagerCall) Do(f func() bool) *MockMachineIsManagerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsManagerCall) DoAndReturn(f func() bool) *MockMachineIsManagerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Principals mocks base method.
func (m *MockMachine) Principals() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Principals")
	ret0, _ := ret[0].([]string)
	return ret0
}

// Principals indicates an expected call of Principals.
func (mr *MockMachineMockRecorder) Principals() *MockMachinePrincipalsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Principals", reflect.TypeOf((*MockMachine)(nil).Principals))
	return &MockMachinePrincipalsCall{Call: call}
}

// MockMachinePrincipalsCall wrap *gomock.Call
type MockMachinePrincipalsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachinePrincipalsCall) Return(arg0 []string) *MockMachinePrincipalsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachinePrincipalsCall) Do(f func() []string) *MockMachinePrincipalsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachinePrincipalsCall) DoAndReturn(f func() []string) *MockMachinePrincipalsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveUpgradeSeriesLock mocks base method.
func (m *MockMachine) RemoveUpgradeSeriesLock() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveUpgradeSeriesLock")
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveUpgradeSeriesLock indicates an expected call of RemoveUpgradeSeriesLock.
func (mr *MockMachineMockRecorder) RemoveUpgradeSeriesLock() *MockMachineRemoveUpgradeSeriesLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveUpgradeSeriesLock", reflect.TypeOf((*MockMachine)(nil).RemoveUpgradeSeriesLock))
	return &MockMachineRemoveUpgradeSeriesLockCall{Call: call}
}

// MockMachineRemoveUpgradeSeriesLockCall wrap *gomock.Call
type MockMachineRemoveUpgradeSeriesLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineRemoveUpgradeSeriesLockCall) Return(arg0 error) *MockMachineRemoveUpgradeSeriesLockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineRemoveUpgradeSeriesLockCall) Do(f func() error) *MockMachineRemoveUpgradeSeriesLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineRemoveUpgradeSeriesLockCall) DoAndReturn(f func() error) *MockMachineRemoveUpgradeSeriesLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetInstanceStatus mocks base method.
func (m *MockMachine) SetInstanceStatus(arg0 status.StatusInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetInstanceStatus", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetInstanceStatus indicates an expected call of SetInstanceStatus.
func (mr *MockMachineMockRecorder) SetInstanceStatus(arg0 any) *MockMachineSetInstanceStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetInstanceStatus", reflect.TypeOf((*MockMachine)(nil).SetInstanceStatus), arg0)
	return &MockMachineSetInstanceStatusCall{Call: call}
}

// MockMachineSetInstanceStatusCall wrap *gomock.Call
type MockMachineSetInstanceStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineSetInstanceStatusCall) Return(arg0 error) *MockMachineSetInstanceStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineSetInstanceStatusCall) Do(f func(status.StatusInfo) error) *MockMachineSetInstanceStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineSetInstanceStatusCall) DoAndReturn(f func(status.StatusInfo) error) *MockMachineSetInstanceStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetKeepInstance mocks base method.
func (m *MockMachine) SetKeepInstance(arg0 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetKeepInstance", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetKeepInstance indicates an expected call of SetKeepInstance.
func (mr *MockMachineMockRecorder) SetKeepInstance(arg0 any) *MockMachineSetKeepInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetKeepInstance", reflect.TypeOf((*MockMachine)(nil).SetKeepInstance), arg0)
	return &MockMachineSetKeepInstanceCall{Call: call}
}

// MockMachineSetKeepInstanceCall wrap *gomock.Call
type MockMachineSetKeepInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineSetKeepInstanceCall) Return(arg0 error) *MockMachineSetKeepInstanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineSetKeepInstanceCall) Do(f func(bool) error) *MockMachineSetKeepInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineSetKeepInstanceCall) DoAndReturn(f func(bool) error) *MockMachineSetKeepInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetPassword mocks base method.
func (m *MockMachine) SetPassword(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetPassword", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetPassword indicates an expected call of SetPassword.
func (mr *MockMachineMockRecorder) SetPassword(arg0 any) *MockMachineSetPasswordCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPassword", reflect.TypeOf((*MockMachine)(nil).SetPassword), arg0)
	return &MockMachineSetPasswordCall{Call: call}
}

// MockMachineSetPasswordCall wrap *gomock.Call
type MockMachineSetPasswordCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineSetPasswordCall) Return(arg0 error) *MockMachineSetPasswordCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineSetPasswordCall) Do(f func(string) error) *MockMachineSetPasswordCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineSetPasswordCall) DoAndReturn(f func(string) error) *MockMachineSetPasswordCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUpgradeSeriesStatus mocks base method.
func (m *MockMachine) SetUpgradeSeriesStatus(arg0 model.UpgradeSeriesStatus, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUpgradeSeriesStatus", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUpgradeSeriesStatus indicates an expected call of SetUpgradeSeriesStatus.
func (mr *MockMachineMockRecorder) SetUpgradeSeriesStatus(arg0, arg1 any) *MockMachineSetUpgradeSeriesStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUpgradeSeriesStatus", reflect.TypeOf((*MockMachine)(nil).SetUpgradeSeriesStatus), arg0, arg1)
	return &MockMachineSetUpgradeSeriesStatusCall{Call: call}
}

// MockMachineSetUpgradeSeriesStatusCall wrap *gomock.Call
type MockMachineSetUpgradeSeriesStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineSetUpgradeSeriesStatusCall) Return(arg0 error) *MockMachineSetUpgradeSeriesStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineSetUpgradeSeriesStatusCall) Do(f func(model.UpgradeSeriesStatus, string) error) *MockMachineSetUpgradeSeriesStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineSetUpgradeSeriesStatusCall) DoAndReturn(f func(model.UpgradeSeriesStatus, string) error) *MockMachineSetUpgradeSeriesStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockMachine) Tag() names.Tag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.Tag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockMachineMockRecorder) Tag() *MockMachineTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockMachine)(nil).Tag))
	return &MockMachineTagCall{Call: call}
}

// MockMachineTagCall wrap *gomock.Call
type MockMachineTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineTagCall) Return(arg0 names.Tag) *MockMachineTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineTagCall) Do(f func() names.Tag) *MockMachineTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineTagCall) DoAndReturn(f func() names.Tag) *MockMachineTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Units mocks base method.
func (m *MockMachine) Units() ([]machinemanager.Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Units")
	ret0, _ := ret[0].([]machinemanager.Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Units indicates an expected call of Units.
func (mr *MockMachineMockRecorder) Units() *MockMachineUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Units", reflect.TypeOf((*MockMachine)(nil).Units))
	return &MockMachineUnitsCall{Call: call}
}

// MockMachineUnitsCall wrap *gomock.Call
type MockMachineUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUnitsCall) Return(arg0 []machinemanager.Unit, arg1 error) *MockMachineUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUnitsCall) Do(f func() ([]machinemanager.Unit, error)) *MockMachineUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUnitsCall) DoAndReturn(f func() ([]machinemanager.Unit, error)) *MockMachineUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpgradeSeriesStatus mocks base method.
func (m *MockMachine) UpgradeSeriesStatus() (model.UpgradeSeriesStatus, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpgradeSeriesStatus")
	ret0, _ := ret[0].(model.UpgradeSeriesStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpgradeSeriesStatus indicates an expected call of UpgradeSeriesStatus.
func (mr *MockMachineMockRecorder) UpgradeSeriesStatus() *MockMachineUpgradeSeriesStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpgradeSeriesStatus", reflect.TypeOf((*MockMachine)(nil).UpgradeSeriesStatus))
	return &MockMachineUpgradeSeriesStatusCall{Call: call}
}

// MockMachineUpgradeSeriesStatusCall wrap *gomock.Call
type MockMachineUpgradeSeriesStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUpgradeSeriesStatusCall) Return(arg0 model.UpgradeSeriesStatus, arg1 error) *MockMachineUpgradeSeriesStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUpgradeSeriesStatusCall) Do(f func() (model.UpgradeSeriesStatus, error)) *MockMachineUpgradeSeriesStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUpgradeSeriesStatusCall) DoAndReturn(f func() (model.UpgradeSeriesStatus, error)) *MockMachineUpgradeSeriesStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WatchUpgradeSeriesNotifications mocks base method.
func (m *MockMachine) WatchUpgradeSeriesNotifications() (state.NotifyWatcher, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WatchUpgradeSeriesNotifications")
	ret0, _ := ret[0].(state.NotifyWatcher)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchUpgradeSeriesNotifications indicates an expected call of WatchUpgradeSeriesNotifications.
func (mr *MockMachineMockRecorder) WatchUpgradeSeriesNotifications() *MockMachineWatchUpgradeSeriesNotificationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchUpgradeSeriesNotifications", reflect.TypeOf((*MockMachine)(nil).WatchUpgradeSeriesNotifications))
	return &MockMachineWatchUpgradeSeriesNotificationsCall{Call: call}
}

// MockMachineWatchUpgradeSeriesNotificationsCall wrap *gomock.Call
type MockMachineWatchUpgradeSeriesNotificationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineWatchUpgradeSeriesNotificationsCall) Return(arg0 state.NotifyWatcher, arg1 error) *MockMachineWatchUpgradeSeriesNotificationsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineWatchUpgradeSeriesNotificationsCall) Do(f func() (state.NotifyWatcher, error)) *MockMachineWatchUpgradeSeriesNotificationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineWatchUpgradeSeriesNotificationsCall) DoAndReturn(f func() (state.NotifyWatcher, error)) *MockMachineWatchUpgradeSeriesNotificationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockApplication is a mock of Application interface.
type MockApplication struct {
	ctrl     *gomock.Controller
	recorder *MockApplicationMockRecorder
}

// MockApplicationMockRecorder is the mock recorder for MockApplication.
type MockApplicationMockRecorder struct {
	mock *MockApplication
}

// NewMockApplication creates a new mock instance.
func NewMockApplication(ctrl *gomock.Controller) *MockApplication {
	mock := &MockApplication{ctrl: ctrl}
	mock.recorder = &MockApplicationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplication) EXPECT() *MockApplicationMockRecorder {
	return m.recorder
}

// Charm mocks base method.
func (m *MockApplication) Charm() (machinemanager.Charm, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm")
	ret0, _ := ret[0].(machinemanager.Charm)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Charm indicates an expected call of Charm.
func (mr *MockApplicationMockRecorder) Charm() *MockApplicationCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockApplication)(nil).Charm))
	return &MockApplicationCharmCall{Call: call}
}

// MockApplicationCharmCall wrap *gomock.Call
type MockApplicationCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmCall) Return(arg0 machinemanager.Charm, arg1 bool, arg2 error) *MockApplicationCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmCall) Do(f func() (machinemanager.Charm, bool, error)) *MockApplicationCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmCall) DoAndReturn(f func() (machinemanager.Charm, bool, error)) *MockApplicationCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CharmOrigin mocks base method.
func (m *MockApplication) CharmOrigin() *state.CharmOrigin {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CharmOrigin")
	ret0, _ := ret[0].(*state.CharmOrigin)
	return ret0
}

// CharmOrigin indicates an expected call of CharmOrigin.
func (mr *MockApplicationMockRecorder) CharmOrigin() *MockApplicationCharmOriginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CharmOrigin", reflect.TypeOf((*MockApplication)(nil).CharmOrigin))
	return &MockApplicationCharmOriginCall{Call: call}
}

// MockApplicationCharmOriginCall wrap *gomock.Call
type MockApplicationCharmOriginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationCharmOriginCall) Return(arg0 *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationCharmOriginCall) Do(f func() *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationCharmOriginCall) DoAndReturn(f func() *state.CharmOrigin) *MockApplicationCharmOriginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockApplication) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockApplicationMockRecorder) Name() *MockApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockApplication)(nil).Name))
	return &MockApplicationNameCall{Call: call}
}

// MockApplicationNameCall wrap *gomock.Call
type MockApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationNameCall) Return(arg0 string) *MockApplicationNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationNameCall) Do(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationNameCall) DoAndReturn(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUnit is a mock of Unit interface.
type MockUnit struct {
	ctrl     *gomock.Controller
	recorder *MockUnitMockRecorder
}

// MockUnitMockRecorder is the mock recorder for MockUnit.
type MockUnitMockRecorder struct {
	mock *MockUnit
}

// NewMockUnit creates a new mock instance.
func NewMockUnit(ctrl *gomock.Controller) *MockUnit {
	mock := &MockUnit{ctrl: ctrl}
	mock.recorder = &MockUnitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnit) EXPECT() *MockUnitMockRecorder {
	return m.recorder
}

// AgentStatus mocks base method.
func (m *MockUnit) AgentStatus() (status.StatusInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AgentStatus")
	ret0, _ := ret[0].(status.StatusInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AgentStatus indicates an expected call of AgentStatus.
func (mr *MockUnitMockRecorder) AgentStatus() *MockUnitAgentStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AgentStatus", reflect.TypeOf((*MockUnit)(nil).AgentStatus))
	return &MockUnitAgentStatusCall{Call: call}
}

// MockUnitAgentStatusCall wrap *gomock.Call
type MockUnitAgentStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitAgentStatusCall) Return(arg0 status.StatusInfo, arg1 error) *MockUnitAgentStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitAgentStatusCall) Do(f func() (status.StatusInfo, error)) *MockUnitAgentStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitAgentStatusCall) DoAndReturn(f func() (status.StatusInfo, error)) *MockUnitAgentStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockUnit) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockUnitMockRecorder) Name() *MockUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockUnit)(nil).Name))
	return &MockUnitNameCall{Call: call}
}

// MockUnitNameCall wrap *gomock.Call
type MockUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitNameCall) Return(arg0 string) *MockUnitNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitNameCall) Do(f func() string) *MockUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitNameCall) DoAndReturn(f func() string) *MockUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockUnit) Status() (status.StatusInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(status.StatusInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Status indicates an expected call of Status.
func (mr *MockUnitMockRecorder) Status() *MockUnitStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockUnit)(nil).Status))
	return &MockUnitStatusCall{Call: call}
}

// MockUnitStatusCall wrap *gomock.Call
type MockUnitStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitStatusCall) Return(arg0 status.StatusInfo, arg1 error) *MockUnitStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitStatusCall) Do(f func() (status.StatusInfo, error)) *MockUnitStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitStatusCall) DoAndReturn(f func() (status.StatusInfo, error)) *MockUnitStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitTag mocks base method.
func (m *MockUnit) UnitTag() names.UnitTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitTag")
	ret0, _ := ret[0].(names.UnitTag)
	return ret0
}

// UnitTag indicates an expected call of UnitTag.
func (mr *MockUnitMockRecorder) UnitTag() *MockUnitUnitTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitTag", reflect.TypeOf((*MockUnit)(nil).UnitTag))
	return &MockUnitUnitTagCall{Call: call}
}

// MockUnitUnitTagCall wrap *gomock.Call
type MockUnitUnitTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitUnitTagCall) Return(arg0 names.UnitTag) *MockUnitUnitTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitUnitTagCall) Do(f func() names.UnitTag) *MockUnitUnitTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitUnitTagCall) DoAndReturn(f func() names.UnitTag) *MockUnitUnitTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharm is a mock of Charm interface.
type MockCharm struct {
	ctrl     *gomock.Controller
	recorder *MockCharmMockRecorder
}

// MockCharmMockRecorder is the mock recorder for MockCharm.
type MockCharmMockRecorder struct {
	mock *MockCharm
}

// NewMockCharm creates a new mock instance.
func NewMockCharm(ctrl *gomock.Controller) *MockCharm {
	mock := &MockCharm{ctrl: ctrl}
	mock.recorder = &MockCharmMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharm) EXPECT() *MockCharmMockRecorder {
	return m.recorder
}

// Manifest mocks base method.
func (m *MockCharm) Manifest() *charm.Manifest {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Manifest")
	ret0, _ := ret[0].(*charm.Manifest)
	return ret0
}

// Manifest indicates an expected call of Manifest.
func (mr *MockCharmMockRecorder) Manifest() *MockCharmManifestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Manifest", reflect.TypeOf((*MockCharm)(nil).Manifest))
	return &MockCharmManifestCall{Call: call}
}

// MockCharmManifestCall wrap *gomock.Call
type MockCharmManifestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmManifestCall) Return(arg0 *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmManifestCall) Do(f func() *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmManifestCall) DoAndReturn(f func() *charm.Manifest) *MockCharmManifestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Meta mocks base method.
func (m *MockCharm) Meta() *charm.Meta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Meta")
	ret0, _ := ret[0].(*charm.Meta)
	return ret0
}

// Meta indicates an expected call of Meta.
func (mr *MockCharmMockRecorder) Meta() *MockCharmMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Meta", reflect.TypeOf((*MockCharm)(nil).Meta))
	return &MockCharmMetaCall{Call: call}
}

// MockCharmMetaCall wrap *gomock.Call
type MockCharmMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmMetaCall) Return(arg0 *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmMetaCall) Do(f func() *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmMetaCall) DoAndReturn(f func() *charm.Meta) *MockCharmMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharmhubClient is a mock of CharmhubClient interface.
type MockCharmhubClient struct {
	ctrl     *gomock.Controller
	recorder *MockCharmhubClientMockRecorder
}

// MockCharmhubClientMockRecorder is the mock recorder for MockCharmhubClient.
type MockCharmhubClientMockRecorder struct {
	mock *MockCharmhubClient
}

// NewMockCharmhubClient creates a new mock instance.
func NewMockCharmhubClient(ctrl *gomock.Controller) *MockCharmhubClient {
	mock := &MockCharmhubClient{ctrl: ctrl}
	mock.recorder = &MockCharmhubClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharmhubClient) EXPECT() *MockCharmhubClientMockRecorder {
	return m.recorder
}

// Refresh mocks base method.
func (m *MockCharmhubClient) Refresh(arg0 context.Context, arg1 charmhub.RefreshConfig) ([]transport.RefreshResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Refresh", arg0, arg1)
	ret0, _ := ret[0].([]transport.RefreshResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Refresh indicates an expected call of Refresh.
func (mr *MockCharmhubClientMockRecorder) Refresh(arg0, arg1 any) *MockCharmhubClientRefreshCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Refresh", reflect.TypeOf((*MockCharmhubClient)(nil).Refresh), arg0, arg1)
	return &MockCharmhubClientRefreshCall{Call: call}
}

// MockCharmhubClientRefreshCall wrap *gomock.Call
type MockCharmhubClientRefreshCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmhubClientRefreshCall) Return(arg0 []transport.RefreshResponse, arg1 error) *MockCharmhubClientRefreshCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmhubClientRefreshCall) Do(f func(context.Context, charmhub.RefreshConfig) ([]transport.RefreshResponse, error)) *MockCharmhubClientRefreshCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmhubClientRefreshCall) DoAndReturn(f func(context.Context, charmhub.RefreshConfig) ([]transport.RefreshResponse, error)) *MockCharmhubClientRefreshCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockControllerConfigService is a mock of ControllerConfigService interface.
type MockControllerConfigService struct {
	ctrl     *gomock.Controller
	recorder *MockControllerConfigServiceMockRecorder
}

// MockControllerConfigServiceMockRecorder is the mock recorder for MockControllerConfigService.
type MockControllerConfigServiceMockRecorder struct {
	mock *MockControllerConfigService
}

// NewMockControllerConfigService creates a new mock instance.
func NewMockControllerConfigService(ctrl *gomock.Controller) *MockControllerConfigService {
	mock := &MockControllerConfigService{ctrl: ctrl}
	mock.recorder = &MockControllerConfigServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockControllerConfigService) EXPECT() *MockControllerConfigServiceMockRecorder {
	return m.recorder
}

// ControllerConfig mocks base method.
func (m *MockControllerConfigService) ControllerConfig(arg0 context.Context) (controller.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ControllerConfig", arg0)
	ret0, _ := ret[0].(controller.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ControllerConfig indicates an expected call of ControllerConfig.
func (mr *MockControllerConfigServiceMockRecorder) ControllerConfig(arg0 any) *MockControllerConfigServiceControllerConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ControllerConfig", reflect.TypeOf((*MockControllerConfigService)(nil).ControllerConfig), arg0)
	return &MockControllerConfigServiceControllerConfigCall{Call: call}
}

// MockControllerConfigServiceControllerConfigCall wrap *gomock.Call
type MockControllerConfigServiceControllerConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerConfigServiceControllerConfigCall) Return(arg0 controller.Config, arg1 error) *MockControllerConfigServiceControllerConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerConfigServiceControllerConfigCall) Do(f func(context.Context) (controller.Config, error)) *MockControllerConfigServiceControllerConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerConfigServiceControllerConfigCall) DoAndReturn(f func(context.Context) (controller.Config, error)) *MockControllerConfigServiceControllerConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockMachineService is a mock of MachineService interface.
type MockMachineService struct {
	ctrl     *gomock.Controller
	recorder *MockMachineServiceMockRecorder
}

// MockMachineServiceMockRecorder is the mock recorder for MockMachineService.
type MockMachineServiceMockRecorder struct {
	mock *MockMachineService
}

// NewMockMachineService creates a new mock instance.
func NewMockMachineService(ctrl *gomock.Controller) *MockMachineService {
	mock := &MockMachineService{ctrl: ctrl}
	mock.recorder = &MockMachineServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachineService) EXPECT() *MockMachineServiceMockRecorder {
	return m.recorder
}

// CreateMachine mocks base method.
func (m *MockMachineService) CreateMachine(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateMachine", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateMachine indicates an expected call of CreateMachine.
func (mr *MockMachineServiceMockRecorder) CreateMachine(arg0, arg1 any) *MockMachineServiceCreateMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMachine", reflect.TypeOf((*MockMachineService)(nil).CreateMachine), arg0, arg1)
	return &MockMachineServiceCreateMachineCall{Call: call}
}

// MockMachineServiceCreateMachineCall wrap *gomock.Call
type MockMachineServiceCreateMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineServiceCreateMachineCall) Return(arg0 error) *MockMachineServiceCreateMachineCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineServiceCreateMachineCall) Do(f func(context.Context, string) error) *MockMachineServiceCreateMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineServiceCreateMachineCall) DoAndReturn(f func(context.Context, string) error) *MockMachineServiceCreateMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteMachine mocks base method.
func (m *MockMachineService) DeleteMachine(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteMachine", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteMachine indicates an expected call of DeleteMachine.
func (mr *MockMachineServiceMockRecorder) DeleteMachine(arg0, arg1 any) *MockMachineServiceDeleteMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMachine", reflect.TypeOf((*MockMachineService)(nil).DeleteMachine), arg0, arg1)
	return &MockMachineServiceDeleteMachineCall{Call: call}
}

// MockMachineServiceDeleteMachineCall wrap *gomock.Call
type MockMachineServiceDeleteMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineServiceDeleteMachineCall) Return(arg0 error) *MockMachineServiceDeleteMachineCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineServiceDeleteMachineCall) Do(f func(context.Context, string) error) *MockMachineServiceDeleteMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineServiceDeleteMachineCall) DoAndReturn(f func(context.Context, string) error) *MockMachineServiceDeleteMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockNetworkService is a mock of NetworkService interface.
type MockNetworkService struct {
	ctrl     *gomock.Controller
	recorder *MockNetworkServiceMockRecorder
}

// MockNetworkServiceMockRecorder is the mock recorder for MockNetworkService.
type MockNetworkServiceMockRecorder struct {
	mock *MockNetworkService
}

// NewMockNetworkService creates a new mock instance.
func NewMockNetworkService(ctrl *gomock.Controller) *MockNetworkService {
	mock := &MockNetworkService{ctrl: ctrl}
	mock.recorder = &MockNetworkServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNetworkService) EXPECT() *MockNetworkServiceMockRecorder {
	return m.recorder
}

// GetAllSpaces mocks base method.
func (m *MockNetworkService) GetAllSpaces(arg0 context.Context) (network.SpaceInfos, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllSpaces", arg0)
	ret0, _ := ret[0].(network.SpaceInfos)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllSpaces indicates an expected call of GetAllSpaces.
func (mr *MockNetworkServiceMockRecorder) GetAllSpaces(arg0 any) *MockNetworkServiceGetAllSpacesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllSpaces", reflect.TypeOf((*MockNetworkService)(nil).GetAllSpaces), arg0)
	return &MockNetworkServiceGetAllSpacesCall{Call: call}
}

// MockNetworkServiceGetAllSpacesCall wrap *gomock.Call
type MockNetworkServiceGetAllSpacesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNetworkServiceGetAllSpacesCall) Return(arg0 network.SpaceInfos, arg1 error) *MockNetworkServiceGetAllSpacesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNetworkServiceGetAllSpacesCall) Do(f func(context.Context) (network.SpaceInfos, error)) *MockNetworkServiceGetAllSpacesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNetworkServiceGetAllSpacesCall) DoAndReturn(f func(context.Context) (network.SpaceInfos, error)) *MockNetworkServiceGetAllSpacesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

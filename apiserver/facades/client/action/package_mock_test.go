// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/apiserver/facades/client/action (interfaces: State,Model,ApplicationService)
//
// Generated by this command:
//
//	mockgen -typed -package action -destination package_mock_test.go github.com/juju/juju/apiserver/facades/client/action State,Model,ApplicationService
//

// Package action is a generated GoMock package.
package action

import (
	context "context"
	reflect "reflect"

	charm "github.com/juju/juju/domain/application/charm"
	charm0 "github.com/juju/juju/internal/charm"
	state "github.com/juju/juju/state"
	names "github.com/juju/names/v6"
	gomock "go.uber.org/mock/gomock"
)

// MockState is a mock of State interface.
type MockState struct {
	ctrl     *gomock.Controller
	recorder *MockStateMockRecorder
}

// MockStateMockRecorder is the mock recorder for MockState.
type MockStateMockRecorder struct {
	mock *MockState
}

// NewMockState creates a new mock instance.
func NewMockState(ctrl *gomock.Controller) *MockState {
	mock := &MockState{ctrl: ctrl}
	mock.recorder = &MockStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockState) EXPECT() *MockStateMockRecorder {
	return m.recorder
}

// ActionByTag mocks base method.
func (m *MockState) ActionByTag(arg0 names.ActionTag) (state.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActionByTag", arg0)
	ret0, _ := ret[0].(state.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ActionByTag indicates an expected call of ActionByTag.
func (mr *MockStateMockRecorder) ActionByTag(arg0 any) *MockStateActionByTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActionByTag", reflect.TypeOf((*MockState)(nil).ActionByTag), arg0)
	return &MockStateActionByTagCall{Call: call}
}

// MockStateActionByTagCall wrap *gomock.Call
type MockStateActionByTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateActionByTagCall) Return(arg0 state.Action, arg1 error) *MockStateActionByTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateActionByTagCall) Do(f func(names.ActionTag) (state.Action, error)) *MockStateActionByTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateActionByTagCall) DoAndReturn(f func(names.ActionTag) (state.Action, error)) *MockStateActionByTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AllApplications mocks base method.
func (m *MockState) AllApplications() ([]*state.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllApplications")
	ret0, _ := ret[0].([]*state.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllApplications indicates an expected call of AllApplications.
func (mr *MockStateMockRecorder) AllApplications() *MockStateAllApplicationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllApplications", reflect.TypeOf((*MockState)(nil).AllApplications))
	return &MockStateAllApplicationsCall{Call: call}
}

// MockStateAllApplicationsCall wrap *gomock.Call
type MockStateAllApplicationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAllApplicationsCall) Return(arg0 []*state.Application, arg1 error) *MockStateAllApplicationsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAllApplicationsCall) Do(f func() ([]*state.Application, error)) *MockStateAllApplicationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAllApplicationsCall) DoAndReturn(f func() ([]*state.Application, error)) *MockStateAllApplicationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AllMachines mocks base method.
func (m *MockState) AllMachines() ([]*state.Machine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllMachines")
	ret0, _ := ret[0].([]*state.Machine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllMachines indicates an expected call of AllMachines.
func (mr *MockStateMockRecorder) AllMachines() *MockStateAllMachinesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllMachines", reflect.TypeOf((*MockState)(nil).AllMachines))
	return &MockStateAllMachinesCall{Call: call}
}

// MockStateAllMachinesCall wrap *gomock.Call
type MockStateAllMachinesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAllMachinesCall) Return(arg0 []*state.Machine, arg1 error) *MockStateAllMachinesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAllMachinesCall) Do(f func() ([]*state.Machine, error)) *MockStateAllMachinesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAllMachinesCall) DoAndReturn(f func() ([]*state.Machine, error)) *MockStateAllMachinesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Application mocks base method.
func (m *MockState) Application(arg0 string) (*state.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Application", arg0)
	ret0, _ := ret[0].(*state.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Application indicates an expected call of Application.
func (mr *MockStateMockRecorder) Application(arg0 any) *MockStateApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Application", reflect.TypeOf((*MockState)(nil).Application), arg0)
	return &MockStateApplicationCall{Call: call}
}

// MockStateApplicationCall wrap *gomock.Call
type MockStateApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateApplicationCall) Return(arg0 *state.Application, arg1 error) *MockStateApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateApplicationCall) Do(f func(string) (*state.Application, error)) *MockStateApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateApplicationCall) DoAndReturn(f func(string) (*state.Application, error)) *MockStateApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindEntity mocks base method.
func (m *MockState) FindEntity(arg0 names.Tag) (state.Entity, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindEntity", arg0)
	ret0, _ := ret[0].(state.Entity)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindEntity indicates an expected call of FindEntity.
func (mr *MockStateMockRecorder) FindEntity(arg0 any) *MockStateFindEntityCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindEntity", reflect.TypeOf((*MockState)(nil).FindEntity), arg0)
	return &MockStateFindEntityCall{Call: call}
}

// MockStateFindEntityCall wrap *gomock.Call
type MockStateFindEntityCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateFindEntityCall) Return(arg0 state.Entity, arg1 error) *MockStateFindEntityCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateFindEntityCall) Do(f func(names.Tag) (state.Entity, error)) *MockStateFindEntityCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateFindEntityCall) DoAndReturn(f func(names.Tag) (state.Entity, error)) *MockStateFindEntityCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Model mocks base method.
func (m *MockState) Model() (Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Model")
	ret0, _ := ret[0].(Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Model indicates an expected call of Model.
func (mr *MockStateMockRecorder) Model() *MockStateModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Model", reflect.TypeOf((*MockState)(nil).Model))
	return &MockStateModelCall{Call: call}
}

// MockStateModelCall wrap *gomock.Call
type MockStateModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateModelCall) Return(arg0 Model, arg1 error) *MockStateModelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateModelCall) Do(f func() (Model, error)) *MockStateModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateModelCall) DoAndReturn(f func() (Model, error)) *MockStateModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WatchActionLogs mocks base method.
func (m *MockState) WatchActionLogs(arg0 string) state.StringsWatcher {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WatchActionLogs", arg0)
	ret0, _ := ret[0].(state.StringsWatcher)
	return ret0
}

// WatchActionLogs indicates an expected call of WatchActionLogs.
func (mr *MockStateMockRecorder) WatchActionLogs(arg0 any) *MockStateWatchActionLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchActionLogs", reflect.TypeOf((*MockState)(nil).WatchActionLogs), arg0)
	return &MockStateWatchActionLogsCall{Call: call}
}

// MockStateWatchActionLogsCall wrap *gomock.Call
type MockStateWatchActionLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateWatchActionLogsCall) Return(arg0 state.StringsWatcher) *MockStateWatchActionLogsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateWatchActionLogsCall) Do(f func(string) state.StringsWatcher) *MockStateWatchActionLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateWatchActionLogsCall) DoAndReturn(f func(string) state.StringsWatcher) *MockStateWatchActionLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockModel is a mock of Model interface.
type MockModel struct {
	ctrl     *gomock.Controller
	recorder *MockModelMockRecorder
}

// MockModelMockRecorder is the mock recorder for MockModel.
type MockModelMockRecorder struct {
	mock *MockModel
}

// NewMockModel creates a new mock instance.
func NewMockModel(ctrl *gomock.Controller) *MockModel {
	mock := &MockModel{ctrl: ctrl}
	mock.recorder = &MockModelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModel) EXPECT() *MockModelMockRecorder {
	return m.recorder
}

// AddAction mocks base method.
func (m *MockModel) AddAction(arg0 state.ActionReceiver, arg1, arg2 string, arg3 map[string]any, arg4 *bool, arg5 *string) (state.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddAction", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(state.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddAction indicates an expected call of AddAction.
func (mr *MockModelMockRecorder) AddAction(arg0, arg1, arg2, arg3, arg4, arg5 any) *MockModelAddActionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAction", reflect.TypeOf((*MockModel)(nil).AddAction), arg0, arg1, arg2, arg3, arg4, arg5)
	return &MockModelAddActionCall{Call: call}
}

// MockModelAddActionCall wrap *gomock.Call
type MockModelAddActionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelAddActionCall) Return(arg0 state.Action, arg1 error) *MockModelAddActionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelAddActionCall) Do(f func(state.ActionReceiver, string, string, map[string]any, *bool, *string) (state.Action, error)) *MockModelAddActionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelAddActionCall) DoAndReturn(f func(state.ActionReceiver, string, string, map[string]any, *bool, *string) (state.Action, error)) *MockModelAddActionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnqueueOperation mocks base method.
func (m *MockModel) EnqueueOperation(arg0 string, arg1 int) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnqueueOperation", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EnqueueOperation indicates an expected call of EnqueueOperation.
func (mr *MockModelMockRecorder) EnqueueOperation(arg0, arg1 any) *MockModelEnqueueOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnqueueOperation", reflect.TypeOf((*MockModel)(nil).EnqueueOperation), arg0, arg1)
	return &MockModelEnqueueOperationCall{Call: call}
}

// MockModelEnqueueOperationCall wrap *gomock.Call
type MockModelEnqueueOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelEnqueueOperationCall) Return(arg0 string, arg1 error) *MockModelEnqueueOperationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelEnqueueOperationCall) Do(f func(string, int) (string, error)) *MockModelEnqueueOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelEnqueueOperationCall) DoAndReturn(f func(string, int) (string, error)) *MockModelEnqueueOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FailOperationEnqueuing mocks base method.
func (m *MockModel) FailOperationEnqueuing(arg0, arg1 string, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FailOperationEnqueuing", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// FailOperationEnqueuing indicates an expected call of FailOperationEnqueuing.
func (mr *MockModelMockRecorder) FailOperationEnqueuing(arg0, arg1, arg2 any) *MockModelFailOperationEnqueuingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FailOperationEnqueuing", reflect.TypeOf((*MockModel)(nil).FailOperationEnqueuing), arg0, arg1, arg2)
	return &MockModelFailOperationEnqueuingCall{Call: call}
}

// MockModelFailOperationEnqueuingCall wrap *gomock.Call
type MockModelFailOperationEnqueuingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelFailOperationEnqueuingCall) Return(arg0 error) *MockModelFailOperationEnqueuingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelFailOperationEnqueuingCall) Do(f func(string, string, int) error) *MockModelFailOperationEnqueuingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelFailOperationEnqueuingCall) DoAndReturn(f func(string, string, int) error) *MockModelFailOperationEnqueuingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindActionsByName mocks base method.
func (m *MockModel) FindActionsByName(arg0 string) ([]state.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindActionsByName", arg0)
	ret0, _ := ret[0].([]state.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindActionsByName indicates an expected call of FindActionsByName.
func (mr *MockModelMockRecorder) FindActionsByName(arg0 any) *MockModelFindActionsByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindActionsByName", reflect.TypeOf((*MockModel)(nil).FindActionsByName), arg0)
	return &MockModelFindActionsByNameCall{Call: call}
}

// MockModelFindActionsByNameCall wrap *gomock.Call
type MockModelFindActionsByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelFindActionsByNameCall) Return(arg0 []state.Action, arg1 error) *MockModelFindActionsByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelFindActionsByNameCall) Do(f func(string) ([]state.Action, error)) *MockModelFindActionsByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelFindActionsByNameCall) DoAndReturn(f func(string) ([]state.Action, error)) *MockModelFindActionsByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListOperations mocks base method.
func (m *MockModel) ListOperations(arg0 []string, arg1 []names.Tag, arg2 []state.ActionStatus, arg3, arg4 int) ([]state.OperationInfo, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListOperations", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].([]state.OperationInfo)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListOperations indicates an expected call of ListOperations.
func (mr *MockModelMockRecorder) ListOperations(arg0, arg1, arg2, arg3, arg4 any) *MockModelListOperationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOperations", reflect.TypeOf((*MockModel)(nil).ListOperations), arg0, arg1, arg2, arg3, arg4)
	return &MockModelListOperationsCall{Call: call}
}

// MockModelListOperationsCall wrap *gomock.Call
type MockModelListOperationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelListOperationsCall) Return(arg0 []state.OperationInfo, arg1 bool, arg2 error) *MockModelListOperationsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelListOperationsCall) Do(f func([]string, []names.Tag, []state.ActionStatus, int, int) ([]state.OperationInfo, bool, error)) *MockModelListOperationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelListOperationsCall) DoAndReturn(f func([]string, []names.Tag, []state.ActionStatus, int, int) ([]state.OperationInfo, bool, error)) *MockModelListOperationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelTag mocks base method.
func (m *MockModel) ModelTag() names.ModelTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelTag")
	ret0, _ := ret[0].(names.ModelTag)
	return ret0
}

// ModelTag indicates an expected call of ModelTag.
func (mr *MockModelMockRecorder) ModelTag() *MockModelModelTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelTag", reflect.TypeOf((*MockModel)(nil).ModelTag))
	return &MockModelModelTagCall{Call: call}
}

// MockModelModelTagCall wrap *gomock.Call
type MockModelModelTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelModelTagCall) Return(arg0 names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelModelTagCall) Do(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelModelTagCall) DoAndReturn(f func() names.ModelTag) *MockModelModelTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OperationWithActions mocks base method.
func (m *MockModel) OperationWithActions(arg0 string) (*state.OperationInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OperationWithActions", arg0)
	ret0, _ := ret[0].(*state.OperationInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OperationWithActions indicates an expected call of OperationWithActions.
func (mr *MockModelMockRecorder) OperationWithActions(arg0 any) *MockModelOperationWithActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OperationWithActions", reflect.TypeOf((*MockModel)(nil).OperationWithActions), arg0)
	return &MockModelOperationWithActionsCall{Call: call}
}

// MockModelOperationWithActionsCall wrap *gomock.Call
type MockModelOperationWithActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelOperationWithActionsCall) Return(arg0 *state.OperationInfo, arg1 error) *MockModelOperationWithActionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelOperationWithActionsCall) Do(f func(string) (*state.OperationInfo, error)) *MockModelOperationWithActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelOperationWithActionsCall) DoAndReturn(f func(string) (*state.OperationInfo, error)) *MockModelOperationWithActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockModel) Type() state.ModelType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(state.ModelType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockModelMockRecorder) Type() *MockModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockModel)(nil).Type))
	return &MockModelTypeCall{Call: call}
}

// MockModelTypeCall wrap *gomock.Call
type MockModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelTypeCall) Return(arg0 state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelTypeCall) Do(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelTypeCall) DoAndReturn(f func() state.ModelType) *MockModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockApplicationService is a mock of ApplicationService interface.
type MockApplicationService struct {
	ctrl     *gomock.Controller
	recorder *MockApplicationServiceMockRecorder
}

// MockApplicationServiceMockRecorder is the mock recorder for MockApplicationService.
type MockApplicationServiceMockRecorder struct {
	mock *MockApplicationService
}

// NewMockApplicationService creates a new mock instance.
func NewMockApplicationService(ctrl *gomock.Controller) *MockApplicationService {
	mock := &MockApplicationService{ctrl: ctrl}
	mock.recorder = &MockApplicationServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplicationService) EXPECT() *MockApplicationServiceMockRecorder {
	return m.recorder
}

// GetCharmActions mocks base method.
func (m *MockApplicationService) GetCharmActions(arg0 context.Context, arg1 charm.CharmLocator) (charm0.Actions, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmActions", arg0, arg1)
	ret0, _ := ret[0].(charm0.Actions)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmActions indicates an expected call of GetCharmActions.
func (mr *MockApplicationServiceMockRecorder) GetCharmActions(arg0, arg1 any) *MockApplicationServiceGetCharmActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmActions", reflect.TypeOf((*MockApplicationService)(nil).GetCharmActions), arg0, arg1)
	return &MockApplicationServiceGetCharmActionsCall{Call: call}
}

// MockApplicationServiceGetCharmActionsCall wrap *gomock.Call
type MockApplicationServiceGetCharmActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationServiceGetCharmActionsCall) Return(arg0 charm0.Actions, arg1 error) *MockApplicationServiceGetCharmActionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationServiceGetCharmActionsCall) Do(f func(context.Context, charm.CharmLocator) (charm0.Actions, error)) *MockApplicationServiceGetCharmActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationServiceGetCharmActionsCall) DoAndReturn(f func(context.Context, charm.CharmLocator) (charm0.Actions, error)) *MockApplicationServiceGetCharmActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmLocatorByApplicationName mocks base method.
func (m *MockApplicationService) GetCharmLocatorByApplicationName(arg0 context.Context, arg1 string) (charm.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmLocatorByApplicationName", arg0, arg1)
	ret0, _ := ret[0].(charm.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmLocatorByApplicationName indicates an expected call of GetCharmLocatorByApplicationName.
func (mr *MockApplicationServiceMockRecorder) GetCharmLocatorByApplicationName(arg0, arg1 any) *MockApplicationServiceGetCharmLocatorByApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmLocatorByApplicationName", reflect.TypeOf((*MockApplicationService)(nil).GetCharmLocatorByApplicationName), arg0, arg1)
	return &MockApplicationServiceGetCharmLocatorByApplicationNameCall{Call: call}
}

// MockApplicationServiceGetCharmLocatorByApplicationNameCall wrap *gomock.Call
type MockApplicationServiceGetCharmLocatorByApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationServiceGetCharmLocatorByApplicationNameCall) Return(arg0 charm.CharmLocator, arg1 error) *MockApplicationServiceGetCharmLocatorByApplicationNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationServiceGetCharmLocatorByApplicationNameCall) Do(f func(context.Context, string) (charm.CharmLocator, error)) *MockApplicationServiceGetCharmLocatorByApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationServiceGetCharmLocatorByApplicationNameCall) DoAndReturn(f func(context.Context, string) (charm.CharmLocator, error)) *MockApplicationServiceGetCharmLocatorByApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

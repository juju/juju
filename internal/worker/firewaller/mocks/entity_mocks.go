// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/internal/worker/firewaller (interfaces: Machine,Unit,Application)
//
// Generated by this command:
//
//	mockgen -typed -package mocks -destination mocks/entity_mocks.go github.com/juju/juju/internal/worker/firewaller Machine,Unit,Application
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	instance "github.com/juju/juju/core/instance"
	life "github.com/juju/juju/core/life"
	watcher "github.com/juju/juju/core/watcher"
	firewaller "github.com/juju/juju/internal/worker/firewaller"
	params "github.com/juju/juju/rpc/params"
	names "github.com/juju/names/v6"
	gomock "go.uber.org/mock/gomock"
)

// MockMachine is a mock of Machine interface.
type MockMachine struct {
	ctrl     *gomock.Controller
	recorder *MockMachineMockRecorder
}

// MockMachineMockRecorder is the mock recorder for MockMachine.
type MockMachineMockRecorder struct {
	mock *MockMachine
}

// NewMockMachine creates a new mock instance.
func NewMockMachine(ctrl *gomock.Controller) *MockMachine {
	mock := &MockMachine{ctrl: ctrl}
	mock.recorder = &MockMachineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachine) EXPECT() *MockMachineMockRecorder {
	return m.recorder
}

// ISGOMOCK indicates that this struct is a gomock mock.
func (m *MockMachine) ISGOMOCK() struct{} {
	return struct{}{}
}

// InstanceId mocks base method.
func (m *MockMachine) InstanceId(arg0 context.Context) (instance.Id, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceId", arg0)
	ret0, _ := ret[0].(instance.Id)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InstanceId indicates an expected call of InstanceId.
func (mr *MockMachineMockRecorder) InstanceId(arg0 any) *MockMachineInstanceIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceId", reflect.TypeOf((*MockMachine)(nil).InstanceId), arg0)
	return &MockMachineInstanceIdCall{Call: call}
}

// MockMachineInstanceIdCall wrap *gomock.Call
type MockMachineInstanceIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineInstanceIdCall) Return(arg0 instance.Id, arg1 error) *MockMachineInstanceIdCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineInstanceIdCall) Do(f func(context.Context) (instance.Id, error)) *MockMachineInstanceIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineInstanceIdCall) DoAndReturn(f func(context.Context) (instance.Id, error)) *MockMachineInstanceIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsManual mocks base method.
func (m *MockMachine) IsManual(arg0 context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsManual", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsManual indicates an expected call of IsManual.
func (mr *MockMachineMockRecorder) IsManual(arg0 any) *MockMachineIsManualCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsManual", reflect.TypeOf((*MockMachine)(nil).IsManual), arg0)
	return &MockMachineIsManualCall{Call: call}
}

// MockMachineIsManualCall wrap *gomock.Call
type MockMachineIsManualCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineIsManualCall) Return(arg0 bool, arg1 error) *MockMachineIsManualCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineIsManualCall) Do(f func(context.Context) (bool, error)) *MockMachineIsManualCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineIsManualCall) DoAndReturn(f func(context.Context) (bool, error)) *MockMachineIsManualCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Life mocks base method.
func (m *MockMachine) Life() life.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Life")
	ret0, _ := ret[0].(life.Value)
	return ret0
}

// Life indicates an expected call of Life.
func (mr *MockMachineMockRecorder) Life() *MockMachineLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Life", reflect.TypeOf((*MockMachine)(nil).Life))
	return &MockMachineLifeCall{Call: call}
}

// MockMachineLifeCall wrap *gomock.Call
type MockMachineLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineLifeCall) Return(arg0 life.Value) *MockMachineLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineLifeCall) Do(f func() life.Value) *MockMachineLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineLifeCall) DoAndReturn(f func() life.Value) *MockMachineLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockMachine) Tag() names.MachineTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.MachineTag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockMachineMockRecorder) Tag() *MockMachineTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockMachine)(nil).Tag))
	return &MockMachineTagCall{Call: call}
}

// MockMachineTagCall wrap *gomock.Call
type MockMachineTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineTagCall) Return(arg0 names.MachineTag) *MockMachineTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineTagCall) Do(f func() names.MachineTag) *MockMachineTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineTagCall) DoAndReturn(f func() names.MachineTag) *MockMachineTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WatchUnits mocks base method.
func (m *MockMachine) WatchUnits(arg0 context.Context) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WatchUnits", arg0)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchUnits indicates an expected call of WatchUnits.
func (mr *MockMachineMockRecorder) WatchUnits(arg0 any) *MockMachineWatchUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchUnits", reflect.TypeOf((*MockMachine)(nil).WatchUnits), arg0)
	return &MockMachineWatchUnitsCall{Call: call}
}

// MockMachineWatchUnitsCall wrap *gomock.Call
type MockMachineWatchUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineWatchUnitsCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockMachineWatchUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineWatchUnitsCall) Do(f func(context.Context) (watcher.Watcher[[]string], error)) *MockMachineWatchUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineWatchUnitsCall) DoAndReturn(f func(context.Context) (watcher.Watcher[[]string], error)) *MockMachineWatchUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUnit is a mock of Unit interface.
type MockUnit struct {
	ctrl     *gomock.Controller
	recorder *MockUnitMockRecorder
}

// MockUnitMockRecorder is the mock recorder for MockUnit.
type MockUnitMockRecorder struct {
	mock *MockUnit
}

// NewMockUnit creates a new mock instance.
func NewMockUnit(ctrl *gomock.Controller) *MockUnit {
	mock := &MockUnit{ctrl: ctrl}
	mock.recorder = &MockUnitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnit) EXPECT() *MockUnitMockRecorder {
	return m.recorder
}

// ISGOMOCK indicates that this struct is a gomock mock.
func (m *MockUnit) ISGOMOCK() struct{} {
	return struct{}{}
}

// Application mocks base method.
func (m *MockUnit) Application() (firewaller.Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Application")
	ret0, _ := ret[0].(firewaller.Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Application indicates an expected call of Application.
func (mr *MockUnitMockRecorder) Application() *MockUnitApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Application", reflect.TypeOf((*MockUnit)(nil).Application))
	return &MockUnitApplicationCall{Call: call}
}

// MockUnitApplicationCall wrap *gomock.Call
type MockUnitApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitApplicationCall) Return(arg0 firewaller.Application, arg1 error) *MockUnitApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitApplicationCall) Do(f func() (firewaller.Application, error)) *MockUnitApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitApplicationCall) DoAndReturn(f func() (firewaller.Application, error)) *MockUnitApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AssignedMachine mocks base method.
func (m *MockUnit) AssignedMachine(arg0 context.Context) (names.MachineTag, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AssignedMachine", arg0)
	ret0, _ := ret[0].(names.MachineTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AssignedMachine indicates an expected call of AssignedMachine.
func (mr *MockUnitMockRecorder) AssignedMachine(arg0 any) *MockUnitAssignedMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssignedMachine", reflect.TypeOf((*MockUnit)(nil).AssignedMachine), arg0)
	return &MockUnitAssignedMachineCall{Call: call}
}

// MockUnitAssignedMachineCall wrap *gomock.Call
type MockUnitAssignedMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitAssignedMachineCall) Return(arg0 names.MachineTag, arg1 error) *MockUnitAssignedMachineCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitAssignedMachineCall) Do(f func(context.Context) (names.MachineTag, error)) *MockUnitAssignedMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitAssignedMachineCall) DoAndReturn(f func(context.Context) (names.MachineTag, error)) *MockUnitAssignedMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Life mocks base method.
func (m *MockUnit) Life() life.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Life")
	ret0, _ := ret[0].(life.Value)
	return ret0
}

// Life indicates an expected call of Life.
func (mr *MockUnitMockRecorder) Life() *MockUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Life", reflect.TypeOf((*MockUnit)(nil).Life))
	return &MockUnitLifeCall{Call: call}
}

// MockUnitLifeCall wrap *gomock.Call
type MockUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitLifeCall) Return(arg0 life.Value) *MockUnitLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitLifeCall) Do(f func() life.Value) *MockUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitLifeCall) DoAndReturn(f func() life.Value) *MockUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockUnit) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockUnitMockRecorder) Name() *MockUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockUnit)(nil).Name))
	return &MockUnitNameCall{Call: call}
}

// MockUnitNameCall wrap *gomock.Call
type MockUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitNameCall) Return(arg0 string) *MockUnitNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitNameCall) Do(f func() string) *MockUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitNameCall) DoAndReturn(f func() string) *MockUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Refresh mocks base method.
func (m *MockUnit) Refresh(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Refresh", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Refresh indicates an expected call of Refresh.
func (mr *MockUnitMockRecorder) Refresh(arg0 any) *MockUnitRefreshCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Refresh", reflect.TypeOf((*MockUnit)(nil).Refresh), arg0)
	return &MockUnitRefreshCall{Call: call}
}

// MockUnitRefreshCall wrap *gomock.Call
type MockUnitRefreshCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUnitRefreshCall) Return(arg0 error) *MockUnitRefreshCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUnitRefreshCall) Do(f func(context.Context) error) *MockUnitRefreshCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUnitRefreshCall) DoAndReturn(f func(context.Context) error) *MockUnitRefreshCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockApplication is a mock of Application interface.
type MockApplication struct {
	ctrl     *gomock.Controller
	recorder *MockApplicationMockRecorder
}

// MockApplicationMockRecorder is the mock recorder for MockApplication.
type MockApplicationMockRecorder struct {
	mock *MockApplication
}

// NewMockApplication creates a new mock instance.
func NewMockApplication(ctrl *gomock.Controller) *MockApplication {
	mock := &MockApplication{ctrl: ctrl}
	mock.recorder = &MockApplicationMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplication) EXPECT() *MockApplicationMockRecorder {
	return m.recorder
}

// ISGOMOCK indicates that this struct is a gomock mock.
func (m *MockApplication) ISGOMOCK() struct{} {
	return struct{}{}
}

// ExposeInfo mocks base method.
func (m *MockApplication) ExposeInfo(arg0 context.Context) (bool, map[string]params.ExposedEndpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExposeInfo", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(map[string]params.ExposedEndpoint)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ExposeInfo indicates an expected call of ExposeInfo.
func (mr *MockApplicationMockRecorder) ExposeInfo(arg0 any) *MockApplicationExposeInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExposeInfo", reflect.TypeOf((*MockApplication)(nil).ExposeInfo), arg0)
	return &MockApplicationExposeInfoCall{Call: call}
}

// MockApplicationExposeInfoCall wrap *gomock.Call
type MockApplicationExposeInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationExposeInfoCall) Return(arg0 bool, arg1 map[string]params.ExposedEndpoint, arg2 error) *MockApplicationExposeInfoCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationExposeInfoCall) Do(f func(context.Context) (bool, map[string]params.ExposedEndpoint, error)) *MockApplicationExposeInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationExposeInfoCall) DoAndReturn(f func(context.Context) (bool, map[string]params.ExposedEndpoint, error)) *MockApplicationExposeInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockApplication) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockApplicationMockRecorder) Name() *MockApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockApplication)(nil).Name))
	return &MockApplicationNameCall{Call: call}
}

// MockApplicationNameCall wrap *gomock.Call
type MockApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationNameCall) Return(arg0 string) *MockApplicationNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationNameCall) Do(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationNameCall) DoAndReturn(f func() string) *MockApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockApplication) Tag() names.ApplicationTag {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag")
	ret0, _ := ret[0].(names.ApplicationTag)
	return ret0
}

// Tag indicates an expected call of Tag.
func (mr *MockApplicationMockRecorder) Tag() *MockApplicationTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockApplication)(nil).Tag))
	return &MockApplicationTagCall{Call: call}
}

// MockApplicationTagCall wrap *gomock.Call
type MockApplicationTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationTagCall) Return(arg0 names.ApplicationTag) *MockApplicationTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationTagCall) Do(f func() names.ApplicationTag) *MockApplicationTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationTagCall) DoAndReturn(f func() names.ApplicationTag) *MockApplicationTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Watch mocks base method.
func (m *MockApplication) Watch(arg0 context.Context) (watcher.Watcher[struct{}], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Watch", arg0)
	ret0, _ := ret[0].(watcher.Watcher[struct{}])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Watch indicates an expected call of Watch.
func (mr *MockApplicationMockRecorder) Watch(arg0 any) *MockApplicationWatchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockApplication)(nil).Watch), arg0)
	return &MockApplicationWatchCall{Call: call}
}

// MockApplicationWatchCall wrap *gomock.Call
type MockApplicationWatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationWatchCall) Return(arg0 watcher.Watcher[struct{}], arg1 error) *MockApplicationWatchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationWatchCall) Do(f func(context.Context) (watcher.Watcher[struct{}], error)) *MockApplicationWatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationWatchCall) DoAndReturn(f func(context.Context) (watcher.Watcher[struct{}], error)) *MockApplicationWatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

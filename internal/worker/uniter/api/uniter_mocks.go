// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface_generics.go
//
// Generated by this command:
//
//	mockgen -typed -package api -destination uniter_mocks.go -source=./interface_generics.go
//

// Package api is a generated GoMock package.
package api

import (
	context "context"
	reflect "reflect"
	time "time"

	uniter "github.com/juju/juju/api/agent/uniter"
	types "github.com/juju/juju/api/types"
	application "github.com/juju/juju/core/application"
	network "github.com/juju/juju/core/network"
	watcher "github.com/juju/juju/core/watcher"
	config "github.com/juju/juju/environs/config"
	params "github.com/juju/juju/rpc/params"
	names "github.com/juju/names/v5"
	gomock "go.uber.org/mock/gomock"
)

// MockUniterClient is a mock of UniterClient interface.
type MockUniterClient struct {
	ctrl     *gomock.Controller
	recorder *MockUniterClientMockRecorder
}

// MockUniterClientMockRecorder is the mock recorder for MockUniterClient.
type MockUniterClientMockRecorder struct {
	mock *MockUniterClient
}

// NewMockUniterClient creates a new mock instance.
func NewMockUniterClient(ctrl *gomock.Controller) *MockUniterClient {
	mock := &MockUniterClient{ctrl: ctrl}
	mock.recorder = &MockUniterClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUniterClient) EXPECT() *MockUniterClientMockRecorder {
	return m.recorder
}

// APIAddresses mocks base method.
func (m *MockUniterClient) APIAddresses(arg0 context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "APIAddresses", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// APIAddresses indicates an expected call of APIAddresses.
func (mr *MockUniterClientMockRecorder) APIAddresses(arg0 any) *MockUniterClientAPIAddressesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "APIAddresses", reflect.TypeOf((*MockUniterClient)(nil).APIAddresses), arg0)
	return &MockUniterClientAPIAddressesCall{Call: call}
}

// MockUniterClientAPIAddressesCall wrap *gomock.Call
type MockUniterClientAPIAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientAPIAddressesCall) Return(arg0 []string, arg1 error) *MockUniterClientAPIAddressesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientAPIAddressesCall) Do(f func(context.Context) ([]string, error)) *MockUniterClientAPIAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientAPIAddressesCall) DoAndReturn(f func(context.Context) ([]string, error)) *MockUniterClientAPIAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Action mocks base method.
func (m *MockUniterClient) Action(ctx context.Context, tag names.ActionTag) (*uniter.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Action", ctx, tag)
	ret0, _ := ret[0].(*uniter.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Action indicates an expected call of Action.
func (mr *MockUniterClientMockRecorder) Action(ctx, tag any) *MockUniterClientActionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Action", reflect.TypeOf((*MockUniterClient)(nil).Action), ctx, tag)
	return &MockUniterClientActionCall{Call: call}
}

// MockUniterClientActionCall wrap *gomock.Call
type MockUniterClientActionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientActionCall) Return(arg0 *uniter.Action, arg1 error) *MockUniterClientActionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientActionCall) Do(f func(context.Context, names.ActionTag) (*uniter.Action, error)) *MockUniterClientActionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientActionCall) DoAndReturn(f func(context.Context, names.ActionTag) (*uniter.Action, error)) *MockUniterClientActionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ActionBegin mocks base method.
func (m *MockUniterClient) ActionBegin(ctx context.Context, tag names.ActionTag) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActionBegin", ctx, tag)
	ret0, _ := ret[0].(error)
	return ret0
}

// ActionBegin indicates an expected call of ActionBegin.
func (mr *MockUniterClientMockRecorder) ActionBegin(ctx, tag any) *MockUniterClientActionBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActionBegin", reflect.TypeOf((*MockUniterClient)(nil).ActionBegin), ctx, tag)
	return &MockUniterClientActionBeginCall{Call: call}
}

// MockUniterClientActionBeginCall wrap *gomock.Call
type MockUniterClientActionBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientActionBeginCall) Return(arg0 error) *MockUniterClientActionBeginCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientActionBeginCall) Do(f func(context.Context, names.ActionTag) error) *MockUniterClientActionBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientActionBeginCall) DoAndReturn(f func(context.Context, names.ActionTag) error) *MockUniterClientActionBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ActionFinish mocks base method.
func (m *MockUniterClient) ActionFinish(ctx context.Context, tag names.ActionTag, status string, results map[string]any, message string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActionFinish", ctx, tag, status, results, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// ActionFinish indicates an expected call of ActionFinish.
func (mr *MockUniterClientMockRecorder) ActionFinish(ctx, tag, status, results, message any) *MockUniterClientActionFinishCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActionFinish", reflect.TypeOf((*MockUniterClient)(nil).ActionFinish), ctx, tag, status, results, message)
	return &MockUniterClientActionFinishCall{Call: call}
}

// MockUniterClientActionFinishCall wrap *gomock.Call
type MockUniterClientActionFinishCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientActionFinishCall) Return(arg0 error) *MockUniterClientActionFinishCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientActionFinishCall) Do(f func(context.Context, names.ActionTag, string, map[string]any, string) error) *MockUniterClientActionFinishCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientActionFinishCall) DoAndReturn(f func(context.Context, names.ActionTag, string, map[string]any, string) error) *MockUniterClientActionFinishCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ActionStatus mocks base method.
func (m *MockUniterClient) ActionStatus(ctx context.Context, tag names.ActionTag) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActionStatus", ctx, tag)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ActionStatus indicates an expected call of ActionStatus.
func (mr *MockUniterClientMockRecorder) ActionStatus(ctx, tag any) *MockUniterClientActionStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActionStatus", reflect.TypeOf((*MockUniterClient)(nil).ActionStatus), ctx, tag)
	return &MockUniterClientActionStatusCall{Call: call}
}

// MockUniterClientActionStatusCall wrap *gomock.Call
type MockUniterClientActionStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientActionStatusCall) Return(arg0 string, arg1 error) *MockUniterClientActionStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientActionStatusCall) Do(f func(context.Context, names.ActionTag) (string, error)) *MockUniterClientActionStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientActionStatusCall) DoAndReturn(f func(context.Context, names.ActionTag) (string, error)) *MockUniterClientActionStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Application mocks base method.
func (m *MockUniterClient) Application(ctx context.Context, tag names.ApplicationTag) (Application, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Application", ctx, tag)
	ret0, _ := ret[0].(Application)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Application indicates an expected call of Application.
func (mr *MockUniterClientMockRecorder) Application(ctx, tag any) *MockUniterClientApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Application", reflect.TypeOf((*MockUniterClient)(nil).Application), ctx, tag)
	return &MockUniterClientApplicationCall{Call: call}
}

// MockUniterClientApplicationCall wrap *gomock.Call
type MockUniterClientApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientApplicationCall) Return(arg0 Application, arg1 error) *MockUniterClientApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientApplicationCall) Do(f func(context.Context, names.ApplicationTag) (Application, error)) *MockUniterClientApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientApplicationCall) DoAndReturn(f func(context.Context, names.ApplicationTag) (Application, error)) *MockUniterClientApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Charm mocks base method.
func (m *MockUniterClient) Charm(curl string) (Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Charm", curl)
	ret0, _ := ret[0].(Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Charm indicates an expected call of Charm.
func (mr *MockUniterClientMockRecorder) Charm(curl any) *MockUniterClientCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Charm", reflect.TypeOf((*MockUniterClient)(nil).Charm), curl)
	return &MockUniterClientCharmCall{Call: call}
}

// MockUniterClientCharmCall wrap *gomock.Call
type MockUniterClientCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientCharmCall) Return(arg0 Charm, arg1 error) *MockUniterClientCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientCharmCall) Do(f func(string) (Charm, error)) *MockUniterClientCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientCharmCall) DoAndReturn(f func(string) (Charm, error)) *MockUniterClientCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudAPIVersion mocks base method.
func (m *MockUniterClient) CloudAPIVersion(arg0 context.Context) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudAPIVersion", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CloudAPIVersion indicates an expected call of CloudAPIVersion.
func (mr *MockUniterClientMockRecorder) CloudAPIVersion(arg0 any) *MockUniterClientCloudAPIVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudAPIVersion", reflect.TypeOf((*MockUniterClient)(nil).CloudAPIVersion), arg0)
	return &MockUniterClientCloudAPIVersionCall{Call: call}
}

// MockUniterClientCloudAPIVersionCall wrap *gomock.Call
type MockUniterClientCloudAPIVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientCloudAPIVersionCall) Return(arg0 string, arg1 error) *MockUniterClientCloudAPIVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientCloudAPIVersionCall) Do(f func(context.Context) (string, error)) *MockUniterClientCloudAPIVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientCloudAPIVersionCall) DoAndReturn(f func(context.Context) (string, error)) *MockUniterClientCloudAPIVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloudSpec mocks base method.
func (m *MockUniterClient) CloudSpec(arg0 context.Context) (*params.CloudSpec, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloudSpec", arg0)
	ret0, _ := ret[0].(*params.CloudSpec)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CloudSpec indicates an expected call of CloudSpec.
func (mr *MockUniterClientMockRecorder) CloudSpec(arg0 any) *MockUniterClientCloudSpecCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloudSpec", reflect.TypeOf((*MockUniterClient)(nil).CloudSpec), arg0)
	return &MockUniterClientCloudSpecCall{Call: call}
}

// MockUniterClientCloudSpecCall wrap *gomock.Call
type MockUniterClientCloudSpecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientCloudSpecCall) Return(arg0 *params.CloudSpec, arg1 error) *MockUniterClientCloudSpecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientCloudSpecCall) Do(f func(context.Context) (*params.CloudSpec, error)) *MockUniterClientCloudSpecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientCloudSpecCall) DoAndReturn(f func(context.Context) (*params.CloudSpec, error)) *MockUniterClientCloudSpecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DestroyUnitStorageAttachments mocks base method.
func (m *MockUniterClient) DestroyUnitStorageAttachments(arg0 names.UnitTag) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyUnitStorageAttachments", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// DestroyUnitStorageAttachments indicates an expected call of DestroyUnitStorageAttachments.
func (mr *MockUniterClientMockRecorder) DestroyUnitStorageAttachments(arg0 any) *MockUniterClientDestroyUnitStorageAttachmentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyUnitStorageAttachments", reflect.TypeOf((*MockUniterClient)(nil).DestroyUnitStorageAttachments), arg0)
	return &MockUniterClientDestroyUnitStorageAttachmentsCall{Call: call}
}

// MockUniterClientDestroyUnitStorageAttachmentsCall wrap *gomock.Call
type MockUniterClientDestroyUnitStorageAttachmentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientDestroyUnitStorageAttachmentsCall) Return(arg0 error) *MockUniterClientDestroyUnitStorageAttachmentsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientDestroyUnitStorageAttachmentsCall) Do(f func(names.UnitTag) error) *MockUniterClientDestroyUnitStorageAttachmentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientDestroyUnitStorageAttachmentsCall) DoAndReturn(f func(names.UnitTag) error) *MockUniterClientDestroyUnitStorageAttachmentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GoalState mocks base method.
func (m *MockUniterClient) GoalState(arg0 context.Context) (application.GoalState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GoalState", arg0)
	ret0, _ := ret[0].(application.GoalState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GoalState indicates an expected call of GoalState.
func (mr *MockUniterClientMockRecorder) GoalState(arg0 any) *MockUniterClientGoalStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GoalState", reflect.TypeOf((*MockUniterClient)(nil).GoalState), arg0)
	return &MockUniterClientGoalStateCall{Call: call}
}

// MockUniterClientGoalStateCall wrap *gomock.Call
type MockUniterClientGoalStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientGoalStateCall) Return(arg0 application.GoalState, arg1 error) *MockUniterClientGoalStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientGoalStateCall) Do(f func(context.Context) (application.GoalState, error)) *MockUniterClientGoalStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientGoalStateCall) DoAndReturn(f func(context.Context) (application.GoalState, error)) *MockUniterClientGoalStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LeadershipSettings mocks base method.
func (m *MockUniterClient) LeadershipSettings() uniter.LeadershipSettingsAccessor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LeadershipSettings")
	ret0, _ := ret[0].(uniter.LeadershipSettingsAccessor)
	return ret0
}

// LeadershipSettings indicates an expected call of LeadershipSettings.
func (mr *MockUniterClientMockRecorder) LeadershipSettings() *MockUniterClientLeadershipSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LeadershipSettings", reflect.TypeOf((*MockUniterClient)(nil).LeadershipSettings))
	return &MockUniterClientLeadershipSettingsCall{Call: call}
}

// MockUniterClientLeadershipSettingsCall wrap *gomock.Call
type MockUniterClientLeadershipSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientLeadershipSettingsCall) Return(arg0 uniter.LeadershipSettingsAccessor) *MockUniterClientLeadershipSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientLeadershipSettingsCall) Do(f func() uniter.LeadershipSettingsAccessor) *MockUniterClientLeadershipSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientLeadershipSettingsCall) DoAndReturn(f func() uniter.LeadershipSettingsAccessor) *MockUniterClientLeadershipSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Model mocks base method.
func (m *MockUniterClient) Model(arg0 context.Context) (*types.Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Model", arg0)
	ret0, _ := ret[0].(*types.Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Model indicates an expected call of Model.
func (mr *MockUniterClientMockRecorder) Model(arg0 any) *MockUniterClientModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Model", reflect.TypeOf((*MockUniterClient)(nil).Model), arg0)
	return &MockUniterClientModelCall{Call: call}
}

// MockUniterClientModelCall wrap *gomock.Call
type MockUniterClientModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientModelCall) Return(arg0 *types.Model, arg1 error) *MockUniterClientModelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientModelCall) Do(f func(context.Context) (*types.Model, error)) *MockUniterClientModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientModelCall) DoAndReturn(f func(context.Context) (*types.Model, error)) *MockUniterClientModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModelConfig mocks base method.
func (m *MockUniterClient) ModelConfig(arg0 context.Context) (*config.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModelConfig", arg0)
	ret0, _ := ret[0].(*config.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ModelConfig indicates an expected call of ModelConfig.
func (mr *MockUniterClientMockRecorder) ModelConfig(arg0 any) *MockUniterClientModelConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModelConfig", reflect.TypeOf((*MockUniterClient)(nil).ModelConfig), arg0)
	return &MockUniterClientModelConfigCall{Call: call}
}

// MockUniterClientModelConfigCall wrap *gomock.Call
type MockUniterClientModelConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientModelConfigCall) Return(arg0 *config.Config, arg1 error) *MockUniterClientModelConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientModelConfigCall) Do(f func(context.Context) (*config.Config, error)) *MockUniterClientModelConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientModelConfigCall) DoAndReturn(f func(context.Context) (*config.Config, error)) *MockUniterClientModelConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenedMachinePortRangesByEndpoint mocks base method.
func (m *MockUniterClient) OpenedMachinePortRangesByEndpoint(ctx context.Context, machineTag names.MachineTag) (map[names.UnitTag]network.GroupedPortRanges, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenedMachinePortRangesByEndpoint", ctx, machineTag)
	ret0, _ := ret[0].(map[names.UnitTag]network.GroupedPortRanges)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenedMachinePortRangesByEndpoint indicates an expected call of OpenedMachinePortRangesByEndpoint.
func (mr *MockUniterClientMockRecorder) OpenedMachinePortRangesByEndpoint(ctx, machineTag any) *MockUniterClientOpenedMachinePortRangesByEndpointCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenedMachinePortRangesByEndpoint", reflect.TypeOf((*MockUniterClient)(nil).OpenedMachinePortRangesByEndpoint), ctx, machineTag)
	return &MockUniterClientOpenedMachinePortRangesByEndpointCall{Call: call}
}

// MockUniterClientOpenedMachinePortRangesByEndpointCall wrap *gomock.Call
type MockUniterClientOpenedMachinePortRangesByEndpointCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientOpenedMachinePortRangesByEndpointCall) Return(arg0 map[names.UnitTag]network.GroupedPortRanges, arg1 error) *MockUniterClientOpenedMachinePortRangesByEndpointCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientOpenedMachinePortRangesByEndpointCall) Do(f func(context.Context, names.MachineTag) (map[names.UnitTag]network.GroupedPortRanges, error)) *MockUniterClientOpenedMachinePortRangesByEndpointCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientOpenedMachinePortRangesByEndpointCall) DoAndReturn(f func(context.Context, names.MachineTag) (map[names.UnitTag]network.GroupedPortRanges, error)) *MockUniterClientOpenedMachinePortRangesByEndpointCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenedPortRangesByEndpoint mocks base method.
func (m *MockUniterClient) OpenedPortRangesByEndpoint(ctx context.Context) (map[names.UnitTag]network.GroupedPortRanges, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenedPortRangesByEndpoint", ctx)
	ret0, _ := ret[0].(map[names.UnitTag]network.GroupedPortRanges)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenedPortRangesByEndpoint indicates an expected call of OpenedPortRangesByEndpoint.
func (mr *MockUniterClientMockRecorder) OpenedPortRangesByEndpoint(ctx any) *MockUniterClientOpenedPortRangesByEndpointCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenedPortRangesByEndpoint", reflect.TypeOf((*MockUniterClient)(nil).OpenedPortRangesByEndpoint), ctx)
	return &MockUniterClientOpenedPortRangesByEndpointCall{Call: call}
}

// MockUniterClientOpenedPortRangesByEndpointCall wrap *gomock.Call
type MockUniterClientOpenedPortRangesByEndpointCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientOpenedPortRangesByEndpointCall) Return(arg0 map[names.UnitTag]network.GroupedPortRanges, arg1 error) *MockUniterClientOpenedPortRangesByEndpointCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientOpenedPortRangesByEndpointCall) Do(f func(context.Context) (map[names.UnitTag]network.GroupedPortRanges, error)) *MockUniterClientOpenedPortRangesByEndpointCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientOpenedPortRangesByEndpointCall) DoAndReturn(f func(context.Context) (map[names.UnitTag]network.GroupedPortRanges, error)) *MockUniterClientOpenedPortRangesByEndpointCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Relation mocks base method.
func (m *MockUniterClient) Relation(ctx context.Context, tag names.RelationTag) (Relation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Relation", ctx, tag)
	ret0, _ := ret[0].(Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Relation indicates an expected call of Relation.
func (mr *MockUniterClientMockRecorder) Relation(ctx, tag any) *MockUniterClientRelationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Relation", reflect.TypeOf((*MockUniterClient)(nil).Relation), ctx, tag)
	return &MockUniterClientRelationCall{Call: call}
}

// MockUniterClientRelationCall wrap *gomock.Call
type MockUniterClientRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientRelationCall) Return(arg0 Relation, arg1 error) *MockUniterClientRelationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientRelationCall) Do(f func(context.Context, names.RelationTag) (Relation, error)) *MockUniterClientRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientRelationCall) DoAndReturn(f func(context.Context, names.RelationTag) (Relation, error)) *MockUniterClientRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RelationById mocks base method.
func (m *MockUniterClient) RelationById(arg0 context.Context, arg1 int) (Relation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RelationById", arg0, arg1)
	ret0, _ := ret[0].(Relation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RelationById indicates an expected call of RelationById.
func (mr *MockUniterClientMockRecorder) RelationById(arg0, arg1 any) *MockUniterClientRelationByIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RelationById", reflect.TypeOf((*MockUniterClient)(nil).RelationById), arg0, arg1)
	return &MockUniterClientRelationByIdCall{Call: call}
}

// MockUniterClientRelationByIdCall wrap *gomock.Call
type MockUniterClientRelationByIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientRelationByIdCall) Return(arg0 Relation, arg1 error) *MockUniterClientRelationByIdCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientRelationByIdCall) Do(f func(context.Context, int) (Relation, error)) *MockUniterClientRelationByIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientRelationByIdCall) DoAndReturn(f func(context.Context, int) (Relation, error)) *MockUniterClientRelationByIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveStorageAttachment mocks base method.
func (m *MockUniterClient) RemoveStorageAttachment(arg0 names.StorageTag, arg1 names.UnitTag) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveStorageAttachment", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveStorageAttachment indicates an expected call of RemoveStorageAttachment.
func (mr *MockUniterClientMockRecorder) RemoveStorageAttachment(arg0, arg1 any) *MockUniterClientRemoveStorageAttachmentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveStorageAttachment", reflect.TypeOf((*MockUniterClient)(nil).RemoveStorageAttachment), arg0, arg1)
	return &MockUniterClientRemoveStorageAttachmentCall{Call: call}
}

// MockUniterClientRemoveStorageAttachmentCall wrap *gomock.Call
type MockUniterClientRemoveStorageAttachmentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientRemoveStorageAttachmentCall) Return(arg0 error) *MockUniterClientRemoveStorageAttachmentCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientRemoveStorageAttachmentCall) Do(f func(names.StorageTag, names.UnitTag) error) *MockUniterClientRemoveStorageAttachmentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientRemoveStorageAttachmentCall) DoAndReturn(f func(names.StorageTag, names.UnitTag) error) *MockUniterClientRemoveStorageAttachmentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitWorkloadVersion mocks base method.
func (m *MockUniterClient) SetUnitWorkloadVersion(ctx context.Context, tag names.UnitTag, version string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitWorkloadVersion", ctx, tag, version)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitWorkloadVersion indicates an expected call of SetUnitWorkloadVersion.
func (mr *MockUniterClientMockRecorder) SetUnitWorkloadVersion(ctx, tag, version any) *MockUniterClientSetUnitWorkloadVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitWorkloadVersion", reflect.TypeOf((*MockUniterClient)(nil).SetUnitWorkloadVersion), ctx, tag, version)
	return &MockUniterClientSetUnitWorkloadVersionCall{Call: call}
}

// MockUniterClientSetUnitWorkloadVersionCall wrap *gomock.Call
type MockUniterClientSetUnitWorkloadVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientSetUnitWorkloadVersionCall) Return(arg0 error) *MockUniterClientSetUnitWorkloadVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientSetUnitWorkloadVersionCall) Do(f func(context.Context, names.UnitTag, string) error) *MockUniterClientSetUnitWorkloadVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientSetUnitWorkloadVersionCall) DoAndReturn(f func(context.Context, names.UnitTag, string) error) *MockUniterClientSetUnitWorkloadVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageAttachment mocks base method.
func (m *MockUniterClient) StorageAttachment(arg0 names.StorageTag, arg1 names.UnitTag) (params.StorageAttachment, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageAttachment", arg0, arg1)
	ret0, _ := ret[0].(params.StorageAttachment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageAttachment indicates an expected call of StorageAttachment.
func (mr *MockUniterClientMockRecorder) StorageAttachment(arg0, arg1 any) *MockUniterClientStorageAttachmentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageAttachment", reflect.TypeOf((*MockUniterClient)(nil).StorageAttachment), arg0, arg1)
	return &MockUniterClientStorageAttachmentCall{Call: call}
}

// MockUniterClientStorageAttachmentCall wrap *gomock.Call
type MockUniterClientStorageAttachmentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientStorageAttachmentCall) Return(arg0 params.StorageAttachment, arg1 error) *MockUniterClientStorageAttachmentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientStorageAttachmentCall) Do(f func(names.StorageTag, names.UnitTag) (params.StorageAttachment, error)) *MockUniterClientStorageAttachmentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientStorageAttachmentCall) DoAndReturn(f func(names.StorageTag, names.UnitTag) (params.StorageAttachment, error)) *MockUniterClientStorageAttachmentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageAttachmentLife mocks base method.
func (m *MockUniterClient) StorageAttachmentLife(arg0 []params.StorageAttachmentId) ([]params.LifeResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageAttachmentLife", arg0)
	ret0, _ := ret[0].([]params.LifeResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageAttachmentLife indicates an expected call of StorageAttachmentLife.
func (mr *MockUniterClientMockRecorder) StorageAttachmentLife(arg0 any) *MockUniterClientStorageAttachmentLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageAttachmentLife", reflect.TypeOf((*MockUniterClient)(nil).StorageAttachmentLife), arg0)
	return &MockUniterClientStorageAttachmentLifeCall{Call: call}
}

// MockUniterClientStorageAttachmentLifeCall wrap *gomock.Call
type MockUniterClientStorageAttachmentLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientStorageAttachmentLifeCall) Return(arg0 []params.LifeResult, arg1 error) *MockUniterClientStorageAttachmentLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientStorageAttachmentLifeCall) Do(f func([]params.StorageAttachmentId) ([]params.LifeResult, error)) *MockUniterClientStorageAttachmentLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientStorageAttachmentLifeCall) DoAndReturn(f func([]params.StorageAttachmentId) ([]params.LifeResult, error)) *MockUniterClientStorageAttachmentLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unit mocks base method.
func (m *MockUniterClient) Unit(ctx context.Context, tag names.UnitTag) (Unit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unit", ctx, tag)
	ret0, _ := ret[0].(Unit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unit indicates an expected call of Unit.
func (mr *MockUniterClientMockRecorder) Unit(ctx, tag any) *MockUniterClientUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unit", reflect.TypeOf((*MockUniterClient)(nil).Unit), ctx, tag)
	return &MockUniterClientUnitCall{Call: call}
}

// MockUniterClientUnitCall wrap *gomock.Call
type MockUniterClientUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientUnitCall) Return(arg0 Unit, arg1 error) *MockUniterClientUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientUnitCall) Do(f func(context.Context, names.UnitTag) (Unit, error)) *MockUniterClientUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientUnitCall) DoAndReturn(f func(context.Context, names.UnitTag) (Unit, error)) *MockUniterClientUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitStorageAttachments mocks base method.
func (m *MockUniterClient) UnitStorageAttachments(arg0 names.UnitTag) ([]params.StorageAttachmentId, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitStorageAttachments", arg0)
	ret0, _ := ret[0].([]params.StorageAttachmentId)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnitStorageAttachments indicates an expected call of UnitStorageAttachments.
func (mr *MockUniterClientMockRecorder) UnitStorageAttachments(arg0 any) *MockUniterClientUnitStorageAttachmentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitStorageAttachments", reflect.TypeOf((*MockUniterClient)(nil).UnitStorageAttachments), arg0)
	return &MockUniterClientUnitStorageAttachmentsCall{Call: call}
}

// MockUniterClientUnitStorageAttachmentsCall wrap *gomock.Call
type MockUniterClientUnitStorageAttachmentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientUnitStorageAttachmentsCall) Return(arg0 []params.StorageAttachmentId, arg1 error) *MockUniterClientUnitStorageAttachmentsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientUnitStorageAttachmentsCall) Do(f func(names.UnitTag) ([]params.StorageAttachmentId, error)) *MockUniterClientUnitStorageAttachmentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientUnitStorageAttachmentsCall) DoAndReturn(f func(names.UnitTag) ([]params.StorageAttachmentId, error)) *MockUniterClientUnitStorageAttachmentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnitWorkloadVersion mocks base method.
func (m *MockUniterClient) UnitWorkloadVersion(ctx context.Context, tag names.UnitTag) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnitWorkloadVersion", ctx, tag)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnitWorkloadVersion indicates an expected call of UnitWorkloadVersion.
func (mr *MockUniterClientMockRecorder) UnitWorkloadVersion(ctx, tag any) *MockUniterClientUnitWorkloadVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnitWorkloadVersion", reflect.TypeOf((*MockUniterClient)(nil).UnitWorkloadVersion), ctx, tag)
	return &MockUniterClientUnitWorkloadVersionCall{Call: call}
}

// MockUniterClientUnitWorkloadVersionCall wrap *gomock.Call
type MockUniterClientUnitWorkloadVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientUnitWorkloadVersionCall) Return(arg0 string, arg1 error) *MockUniterClientUnitWorkloadVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientUnitWorkloadVersionCall) Do(f func(context.Context, names.UnitTag) (string, error)) *MockUniterClientUnitWorkloadVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientUnitWorkloadVersionCall) DoAndReturn(f func(context.Context, names.UnitTag) (string, error)) *MockUniterClientUnitWorkloadVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateStatusHookInterval mocks base method.
func (m *MockUniterClient) UpdateStatusHookInterval(arg0 context.Context) (time.Duration, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateStatusHookInterval", arg0)
	ret0, _ := ret[0].(time.Duration)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateStatusHookInterval indicates an expected call of UpdateStatusHookInterval.
func (mr *MockUniterClientMockRecorder) UpdateStatusHookInterval(arg0 any) *MockUniterClientUpdateStatusHookIntervalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatusHookInterval", reflect.TypeOf((*MockUniterClient)(nil).UpdateStatusHookInterval), arg0)
	return &MockUniterClientUpdateStatusHookIntervalCall{Call: call}
}

// MockUniterClientUpdateStatusHookIntervalCall wrap *gomock.Call
type MockUniterClientUpdateStatusHookIntervalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientUpdateStatusHookIntervalCall) Return(arg0 time.Duration, arg1 error) *MockUniterClientUpdateStatusHookIntervalCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientUpdateStatusHookIntervalCall) Do(f func(context.Context) (time.Duration, error)) *MockUniterClientUpdateStatusHookIntervalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientUpdateStatusHookIntervalCall) DoAndReturn(f func(context.Context) (time.Duration, error)) *MockUniterClientUpdateStatusHookIntervalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WatchRelationUnits mocks base method.
func (m *MockUniterClient) WatchRelationUnits(arg0 context.Context, arg1 names.RelationTag, arg2 names.UnitTag) (watcher.RelationUnitsWatcher, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WatchRelationUnits", arg0, arg1, arg2)
	ret0, _ := ret[0].(watcher.RelationUnitsWatcher)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchRelationUnits indicates an expected call of WatchRelationUnits.
func (mr *MockUniterClientMockRecorder) WatchRelationUnits(arg0, arg1, arg2 any) *MockUniterClientWatchRelationUnitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchRelationUnits", reflect.TypeOf((*MockUniterClient)(nil).WatchRelationUnits), arg0, arg1, arg2)
	return &MockUniterClientWatchRelationUnitsCall{Call: call}
}

// MockUniterClientWatchRelationUnitsCall wrap *gomock.Call
type MockUniterClientWatchRelationUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientWatchRelationUnitsCall) Return(arg0 watcher.RelationUnitsWatcher, arg1 error) *MockUniterClientWatchRelationUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientWatchRelationUnitsCall) Do(f func(context.Context, names.RelationTag, names.UnitTag) (watcher.RelationUnitsWatcher, error)) *MockUniterClientWatchRelationUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientWatchRelationUnitsCall) DoAndReturn(f func(context.Context, names.RelationTag, names.UnitTag) (watcher.RelationUnitsWatcher, error)) *MockUniterClientWatchRelationUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WatchStorageAttachment mocks base method.
func (m *MockUniterClient) WatchStorageAttachment(arg0 names.StorageTag, arg1 names.UnitTag) (watcher.NotifyWatcher, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WatchStorageAttachment", arg0, arg1)
	ret0, _ := ret[0].(watcher.NotifyWatcher)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchStorageAttachment indicates an expected call of WatchStorageAttachment.
func (mr *MockUniterClientMockRecorder) WatchStorageAttachment(arg0, arg1 any) *MockUniterClientWatchStorageAttachmentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchStorageAttachment", reflect.TypeOf((*MockUniterClient)(nil).WatchStorageAttachment), arg0, arg1)
	return &MockUniterClientWatchStorageAttachmentCall{Call: call}
}

// MockUniterClientWatchStorageAttachmentCall wrap *gomock.Call
type MockUniterClientWatchStorageAttachmentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientWatchStorageAttachmentCall) Return(arg0 watcher.NotifyWatcher, arg1 error) *MockUniterClientWatchStorageAttachmentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientWatchStorageAttachmentCall) Do(f func(names.StorageTag, names.UnitTag) (watcher.NotifyWatcher, error)) *MockUniterClientWatchStorageAttachmentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientWatchStorageAttachmentCall) DoAndReturn(f func(names.StorageTag, names.UnitTag) (watcher.NotifyWatcher, error)) *MockUniterClientWatchStorageAttachmentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WatchUpdateStatusHookInterval mocks base method.
func (m *MockUniterClient) WatchUpdateStatusHookInterval(arg0 context.Context) (watcher.NotifyWatcher, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WatchUpdateStatusHookInterval", arg0)
	ret0, _ := ret[0].(watcher.NotifyWatcher)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WatchUpdateStatusHookInterval indicates an expected call of WatchUpdateStatusHookInterval.
func (mr *MockUniterClientMockRecorder) WatchUpdateStatusHookInterval(arg0 any) *MockUniterClientWatchUpdateStatusHookIntervalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WatchUpdateStatusHookInterval", reflect.TypeOf((*MockUniterClient)(nil).WatchUpdateStatusHookInterval), arg0)
	return &MockUniterClientWatchUpdateStatusHookIntervalCall{Call: call}
}

// MockUniterClientWatchUpdateStatusHookIntervalCall wrap *gomock.Call
type MockUniterClientWatchUpdateStatusHookIntervalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUniterClientWatchUpdateStatusHookIntervalCall) Return(arg0 watcher.NotifyWatcher, arg1 error) *MockUniterClientWatchUpdateStatusHookIntervalCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUniterClientWatchUpdateStatusHookIntervalCall) Do(f func(context.Context) (watcher.NotifyWatcher, error)) *MockUniterClientWatchUpdateStatusHookIntervalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUniterClientWatchUpdateStatusHookIntervalCall) DoAndReturn(f func(context.Context) (watcher.NotifyWatcher, error)) *MockUniterClientWatchUpdateStatusHookIntervalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

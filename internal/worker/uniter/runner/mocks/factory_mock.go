// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/internal/worker/uniter/runner (interfaces: Factory,Runner)
//
// Generated by this command:
//
//	mockgen -typed -package mocks -destination mocks/factory_mock.go github.com/juju/juju/internal/worker/uniter/runner Factory,Runner
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	uniter "github.com/juju/juju/api/agent/uniter"
	hook "github.com/juju/juju/internal/worker/uniter/hook"
	runner "github.com/juju/juju/internal/worker/uniter/runner"
	context0 "github.com/juju/juju/internal/worker/uniter/runner/context"
	exec "github.com/juju/utils/v4/exec"
	gomock "go.uber.org/mock/gomock"
)

// MockFactory is a mock of Factory interface.
type MockFactory struct {
	ctrl     *gomock.Controller
	recorder *MockFactoryMockRecorder
}

// MockFactoryMockRecorder is the mock recorder for MockFactory.
type MockFactoryMockRecorder struct {
	mock *MockFactory
}

// NewMockFactory creates a new mock instance.
func NewMockFactory(ctrl *gomock.Controller) *MockFactory {
	mock := &MockFactory{ctrl: ctrl}
	mock.recorder = &MockFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFactory) EXPECT() *MockFactoryMockRecorder {
	return m.recorder
}

// NewActionRunner mocks base method.
func (m *MockFactory) NewActionRunner(arg0 context.Context, arg1 *uniter.Action, arg2 <-chan struct{}) (runner.Runner, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewActionRunner", arg0, arg1, arg2)
	ret0, _ := ret[0].(runner.Runner)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewActionRunner indicates an expected call of NewActionRunner.
func (mr *MockFactoryMockRecorder) NewActionRunner(arg0, arg1, arg2 any) *MockFactoryNewActionRunnerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewActionRunner", reflect.TypeOf((*MockFactory)(nil).NewActionRunner), arg0, arg1, arg2)
	return &MockFactoryNewActionRunnerCall{Call: call}
}

// MockFactoryNewActionRunnerCall wrap *gomock.Call
type MockFactoryNewActionRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFactoryNewActionRunnerCall) Return(arg0 runner.Runner, arg1 error) *MockFactoryNewActionRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFactoryNewActionRunnerCall) Do(f func(context.Context, *uniter.Action, <-chan struct{}) (runner.Runner, error)) *MockFactoryNewActionRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFactoryNewActionRunnerCall) DoAndReturn(f func(context.Context, *uniter.Action, <-chan struct{}) (runner.Runner, error)) *MockFactoryNewActionRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewCommandRunner mocks base method.
func (m *MockFactory) NewCommandRunner(arg0 context.Context, arg1 context0.CommandInfo) (runner.Runner, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewCommandRunner", arg0, arg1)
	ret0, _ := ret[0].(runner.Runner)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewCommandRunner indicates an expected call of NewCommandRunner.
func (mr *MockFactoryMockRecorder) NewCommandRunner(arg0, arg1 any) *MockFactoryNewCommandRunnerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewCommandRunner", reflect.TypeOf((*MockFactory)(nil).NewCommandRunner), arg0, arg1)
	return &MockFactoryNewCommandRunnerCall{Call: call}
}

// MockFactoryNewCommandRunnerCall wrap *gomock.Call
type MockFactoryNewCommandRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFactoryNewCommandRunnerCall) Return(arg0 runner.Runner, arg1 error) *MockFactoryNewCommandRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFactoryNewCommandRunnerCall) Do(f func(context.Context, context0.CommandInfo) (runner.Runner, error)) *MockFactoryNewCommandRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFactoryNewCommandRunnerCall) DoAndReturn(f func(context.Context, context0.CommandInfo) (runner.Runner, error)) *MockFactoryNewCommandRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewHookRunner mocks base method.
func (m *MockFactory) NewHookRunner(arg0 context.Context, arg1 hook.Info) (runner.Runner, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewHookRunner", arg0, arg1)
	ret0, _ := ret[0].(runner.Runner)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewHookRunner indicates an expected call of NewHookRunner.
func (mr *MockFactoryMockRecorder) NewHookRunner(arg0, arg1 any) *MockFactoryNewHookRunnerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewHookRunner", reflect.TypeOf((*MockFactory)(nil).NewHookRunner), arg0, arg1)
	return &MockFactoryNewHookRunnerCall{Call: call}
}

// MockFactoryNewHookRunnerCall wrap *gomock.Call
type MockFactoryNewHookRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFactoryNewHookRunnerCall) Return(arg0 runner.Runner, arg1 error) *MockFactoryNewHookRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFactoryNewHookRunnerCall) Do(f func(context.Context, hook.Info) (runner.Runner, error)) *MockFactoryNewHookRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFactoryNewHookRunnerCall) DoAndReturn(f func(context.Context, hook.Info) (runner.Runner, error)) *MockFactoryNewHookRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRunner is a mock of Runner interface.
type MockRunner struct {
	ctrl     *gomock.Controller
	recorder *MockRunnerMockRecorder
}

// MockRunnerMockRecorder is the mock recorder for MockRunner.
type MockRunnerMockRecorder struct {
	mock *MockRunner
}

// NewMockRunner creates a new mock instance.
func NewMockRunner(ctrl *gomock.Controller) *MockRunner {
	mock := &MockRunner{ctrl: ctrl}
	mock.recorder = &MockRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRunner) EXPECT() *MockRunnerMockRecorder {
	return m.recorder
}

// Context mocks base method.
func (m *MockRunner) Context() context0.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Context")
	ret0, _ := ret[0].(context0.Context)
	return ret0
}

// Context indicates an expected call of Context.
func (mr *MockRunnerMockRecorder) Context() *MockRunnerContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Context", reflect.TypeOf((*MockRunner)(nil).Context))
	return &MockRunnerContextCall{Call: call}
}

// MockRunnerContextCall wrap *gomock.Call
type MockRunnerContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnerContextCall) Return(arg0 context0.Context) *MockRunnerContextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnerContextCall) Do(f func() context0.Context) *MockRunnerContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnerContextCall) DoAndReturn(f func() context0.Context) *MockRunnerContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RunAction mocks base method.
func (m *MockRunner) RunAction(arg0 context.Context, arg1 string) (runner.HookHandlerType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunAction", arg0, arg1)
	ret0, _ := ret[0].(runner.HookHandlerType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunAction indicates an expected call of RunAction.
func (mr *MockRunnerMockRecorder) RunAction(arg0, arg1 any) *MockRunnerRunActionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunAction", reflect.TypeOf((*MockRunner)(nil).RunAction), arg0, arg1)
	return &MockRunnerRunActionCall{Call: call}
}

// MockRunnerRunActionCall wrap *gomock.Call
type MockRunnerRunActionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnerRunActionCall) Return(arg0 runner.HookHandlerType, arg1 error) *MockRunnerRunActionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnerRunActionCall) Do(f func(context.Context, string) (runner.HookHandlerType, error)) *MockRunnerRunActionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnerRunActionCall) DoAndReturn(f func(context.Context, string) (runner.HookHandlerType, error)) *MockRunnerRunActionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RunCommands mocks base method.
func (m *MockRunner) RunCommands(arg0 context.Context, arg1 string, arg2 runner.RunLocation) (*exec.ExecResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunCommands", arg0, arg1, arg2)
	ret0, _ := ret[0].(*exec.ExecResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunCommands indicates an expected call of RunCommands.
func (mr *MockRunnerMockRecorder) RunCommands(arg0, arg1, arg2 any) *MockRunnerRunCommandsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunCommands", reflect.TypeOf((*MockRunner)(nil).RunCommands), arg0, arg1, arg2)
	return &MockRunnerRunCommandsCall{Call: call}
}

// MockRunnerRunCommandsCall wrap *gomock.Call
type MockRunnerRunCommandsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnerRunCommandsCall) Return(arg0 *exec.ExecResponse, arg1 error) *MockRunnerRunCommandsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnerRunCommandsCall) Do(f func(context.Context, string, runner.RunLocation) (*exec.ExecResponse, error)) *MockRunnerRunCommandsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnerRunCommandsCall) DoAndReturn(f func(context.Context, string, runner.RunLocation) (*exec.ExecResponse, error)) *MockRunnerRunCommandsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RunHook mocks base method.
func (m *MockRunner) RunHook(arg0 context.Context, arg1 string) (runner.HookHandlerType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunHook", arg0, arg1)
	ret0, _ := ret[0].(runner.HookHandlerType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunHook indicates an expected call of RunHook.
func (mr *MockRunnerMockRecorder) RunHook(arg0, arg1 any) *MockRunnerRunHookCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunHook", reflect.TypeOf((*MockRunner)(nil).RunHook), arg0, arg1)
	return &MockRunnerRunHookCall{Call: call}
}

// MockRunnerRunHookCall wrap *gomock.Call
type MockRunnerRunHookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnerRunHookCall) Return(arg0 runner.HookHandlerType, arg1 error) *MockRunnerRunHookCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnerRunHookCall) Do(f func(context.Context, string) (runner.HookHandlerType, error)) *MockRunnerRunHookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnerRunHookCall) DoAndReturn(f func(context.Context, string) (runner.HookHandlerType, error)) *MockRunnerRunHookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

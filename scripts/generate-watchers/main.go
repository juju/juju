// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package main

import (
	"flag"
	"os"
	"reflect"
	"text/template"

	"github.com/juju/utils/set"

	"github.com/juju/juju/core/cache"
)

var source = map[string]interface{}{
	"Application": cache.ApplicationChange{},
	"Unit":        cache.UnitChange{},
}

var tmpl = `
// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

/*
 * CODE GENERATED BY juju/scripts/generate-watchers/main.go.
 * THIS FILE SHOULD NOT BE EDITED BY HAND.
 */

package cache
{{ range $key, $fields := . }}
type {{ $key }}Delta struct {
	old, new {{ $key }}Change
}

type {{ $key }}FieldWatcher struct {
	*notifyWatcherBase
	comparitors []func(*{{ $key }}Delta) bool
}

func new{{ $key }}FieldWatcher(comparitors []func(*{{ $key }}Delta) bool) *{{ $key }}FieldWatcher {
	return &{{ $key }}FieldWatcher{
		notifyWatcherBase: newNotifyWatcherBase(),
		comparitors:       comparitors,
	}
}

func (w *{{ $key }}FieldWatcher) detailsChange(topic string, value interface{}) {
	delta, ok := value.(*{{ $key }}Delta)
	if !ok {
		logger.Errorf("programming error, value not of type *{{ $key }}Delta")
	}

	// If no comparitors were specified, notify for any change.
	if len(w.comparitors) == 0 {
		w.notify()
		return
	}

	// Otherwise notify if any of the articles we are interested in change.
	for _, c := range w.comparitors {
		if c(delta) {
			w.notify()
			return
		}
	}
}
{{ range $idx, $field := $fields }}
var {{ $key }}{{ $field }}Changed = func(delta *{{ $key }}Delta) bool {
	return delta.new.{{ $field }} != delta.old.{{ $field }}
}
{{ end }}{{ end }}`[1:]

var out = flag.String("o", "", "output file")

//go:generate go run main.go -o ../../core/cache/fieldwatcher.go

func main() {
	flag.Parse()

	t, err := template.New("juju-cache-delta-comparitors").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	of := os.Stdout
	if *out != "" {
		of, err = os.OpenFile(*out, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
		if err != nil {
			panic(err)
		}
	}

	driver := make(map[string][]string)
	for name, v := range source {
		t := reflect.ValueOf(v).Type()

		var fields []string
		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)

			// TODO (manadart 2019-03-13): Check that the field is exported.

			// TODO (manadart 2019-03-13): Accommodate the other types;
			// maybe use nested templates to generate reflection-less
			// comparitors for the different types we deal with.

			direct := set.NewStrings("string", "int", "int64", "bool")
			if direct.Contains(f.Type.String()) {
				fields = append(fields, f.Name)
			}
		}
		driver[name] = fields
	}

	if err := t.Execute(of, driver); err != nil {
		panic(err)
	}
}

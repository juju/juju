// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package main

import (
	"flag"
	"os"
	"reflect"
	"text/template"

	"github.com/juju/utils/set"

	"github.com/juju/juju/core/cache"
)

var source = map[string]interface{}{
	"Application": cache.ApplicationChange{},
	"Unit":        cache.UnitChange{},
}

var tmpl = `
// Copyright 2019 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

/*
 * CODE GENERATED BY juju/scripts/generate-watchers/main.go.
 * THIS FILE SHOULD NOT BE EDITED BY HAND.
 */

package cache
{{ range $key, $fields := . }}{{ range $idx, $field := $fields }}
var {{ $key }}{{ $field }}Changed = func(new, old {{ $key }}Change) bool {
	return new.{{ $field }} != old.{{ $field }}
}
{{ end }}{{ end }}`[1:]

var out = flag.String("o", "", "output file")

//go:generate go run main.go -o ../../core/cache/comparitors.go

func main() {
	flag.Parse()

	t, err := template.New("juju-cache-delta-comparitors").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	of := os.Stdout
	if *out != "" {
		of, err = os.OpenFile(*out, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
		if err != nil {
			panic(err)
		}
	}

	driver := make(map[string][]string)
	for name, v := range source {
		t := reflect.ValueOf(v).Type()

		var fields []string
		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)

			// TODO (manadart 2019-03-13): Check that the field is exported.

			// TODO (manadart 2019-03-13): Accommodate the other types;
			// maybe use nested templates to generate reflection-less
			// comparitors for the different types we deal with.

			direct := set.NewStrings("string", "int", "int64", "bool")
			if direct.Contains(f.Type.String()) {
				fields = append(fields, f.Name)
			}
		}
		driver[name] = fields
	}

	if err := t.Execute(of, driver); err != nil {
		panic(err)
	}
}

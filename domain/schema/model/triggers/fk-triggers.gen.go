// Code generated by fktriggergen. DO NOT EDIT.

package triggers

import (
	"github.com/juju/juju/core/database/schema"
)

// FKDebugTriggers generates triggers from all tables to debug FK violations.
func FKDebugTriggers() func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(`

-- fk debug delete trigger for agent_stream for fk ref from agent_version
CREATE TRIGGER trg_fk_debug_agent_stream_id_agent_version_stream_id
BEFORE DELETE ON 'agent_stream' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM agent_stream due to referencing rows in agent_version ON stream_id')
                    ELSE
                        NULL
                    END panic
        FROM 'agent_version'
        WHERE stream_id=OLD.id;
END;

-- fk debug delete trigger for application_endpoint for fk ref from application_exposed_endpoint_cidr
CREATE TRIGGER trg_fk_debug_application_endpoint_uuid_application_exposed_endpoint_cidr_application_endpoint_uuid
BEFORE DELETE ON 'application_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application_endpoint due to referencing rows in application_exposed_endpoint_cidr ON application_endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_exposed_endpoint_cidr'
        WHERE application_endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application_endpoint for fk ref from application_exposed_endpoint_space
CREATE TRIGGER trg_fk_debug_application_endpoint_uuid_application_exposed_endpoint_space_application_endpoint_uuid
BEFORE DELETE ON 'application_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application_endpoint due to referencing rows in application_exposed_endpoint_space ON application_endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_exposed_endpoint_space'
        WHERE application_endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application_endpoint for fk ref from offer_endpoint
CREATE TRIGGER trg_fk_debug_application_endpoint_uuid_offer_endpoint_endpoint_uuid
BEFORE DELETE ON 'application_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application_endpoint due to referencing rows in offer_endpoint ON endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'offer_endpoint'
        WHERE endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application_endpoint for fk ref from relation_endpoint
CREATE TRIGGER trg_fk_debug_application_endpoint_uuid_relation_endpoint_endpoint_uuid
BEFORE DELETE ON 'application_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application_endpoint due to referencing rows in relation_endpoint ON endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_endpoint'
        WHERE endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application_remote_offerer for fk ref from application_remote_offerer_status
CREATE TRIGGER trg_fk_debug_application_remote_offerer_uuid_application_remote_offerer_status_application_remote_offerer_uuid
BEFORE DELETE ON 'application_remote_offerer' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application_remote_offerer due to referencing rows in application_remote_offerer_status ON application_remote_offerer_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_offerer_status'
        WHERE application_remote_offerer_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application_remote_relation for fk ref from offer_connection
CREATE TRIGGER trg_fk_debug_application_remote_relation_relation_uuid_offer_connection_application_remote_relation_uuid
BEFORE DELETE ON 'application_remote_relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application_remote_relation due to referencing rows in offer_connection ON application_remote_relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'offer_connection'
        WHERE application_remote_relation_uuid=OLD.relation_uuid;
END;

-- fk debug delete trigger for application for fk ref from application_agent
CREATE TRIGGER trg_fk_debug_application_uuid_application_agent_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_agent ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_agent'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_channel
CREATE TRIGGER trg_fk_debug_application_uuid_application_channel_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_channel ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_channel'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_config
CREATE TRIGGER trg_fk_debug_application_uuid_application_config_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_config ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_config'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_config_hash
CREATE TRIGGER trg_fk_debug_application_uuid_application_config_hash_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_config_hash ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_config_hash'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_constraint
CREATE TRIGGER trg_fk_debug_application_uuid_application_constraint_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_constraint ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_constraint'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_controller
CREATE TRIGGER trg_fk_debug_application_uuid_application_controller_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_controller ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_controller'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_endpoint
CREATE TRIGGER trg_fk_debug_application_uuid_application_endpoint_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_endpoint ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_endpoint'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_exposed_endpoint_cidr
CREATE TRIGGER trg_fk_debug_application_uuid_application_exposed_endpoint_cidr_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_exposed_endpoint_cidr ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_exposed_endpoint_cidr'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_exposed_endpoint_space
CREATE TRIGGER trg_fk_debug_application_uuid_application_exposed_endpoint_space_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_exposed_endpoint_space ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_exposed_endpoint_space'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_extra_endpoint
CREATE TRIGGER trg_fk_debug_application_uuid_application_extra_endpoint_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_extra_endpoint ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_extra_endpoint'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_platform
CREATE TRIGGER trg_fk_debug_application_uuid_application_platform_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_platform ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_platform'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_remote_consumer
CREATE TRIGGER trg_fk_debug_application_uuid_application_remote_consumer_consumer_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_remote_consumer ON consumer_application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_consumer'
        WHERE consumer_application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_remote_consumer
CREATE TRIGGER trg_fk_debug_application_uuid_application_remote_consumer_offerer_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_remote_consumer ON offerer_application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_consumer'
        WHERE offerer_application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_remote_offerer
CREATE TRIGGER trg_fk_debug_application_uuid_application_remote_offerer_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_remote_offerer ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_offerer'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_resource
CREATE TRIGGER trg_fk_debug_application_uuid_application_resource_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_resource ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_resource'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_scale
CREATE TRIGGER trg_fk_debug_application_uuid_application_scale_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_scale ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_scale'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_setting
CREATE TRIGGER trg_fk_debug_application_uuid_application_setting_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_setting ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_setting'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_status
CREATE TRIGGER trg_fk_debug_application_uuid_application_status_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_status ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_status'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_storage_directive
CREATE TRIGGER trg_fk_debug_application_uuid_application_storage_directive_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_storage_directive ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_storage_directive'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from application_workload_version
CREATE TRIGGER trg_fk_debug_application_uuid_application_workload_version_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in application_workload_version ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_workload_version'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from device_constraint
CREATE TRIGGER trg_fk_debug_application_uuid_device_constraint_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in device_constraint ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'device_constraint'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from k8s_service
CREATE TRIGGER trg_fk_debug_application_uuid_k8s_service_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in k8s_service ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'k8s_service'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from secret_application_owner
CREATE TRIGGER trg_fk_debug_application_uuid_secret_application_owner_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in secret_application_owner ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_application_owner'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for application for fk ref from unit
CREATE TRIGGER trg_fk_debug_application_uuid_unit_application_uuid
BEFORE DELETE ON 'application' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM application due to referencing rows in unit ON application_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit'
        WHERE application_uuid=OLD.uuid;
END;

-- fk debug delete trigger for architecture for fk ref from agent_binary_store
CREATE TRIGGER trg_fk_debug_architecture_id_agent_binary_store_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in agent_binary_store ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'agent_binary_store'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for architecture for fk ref from application_platform
CREATE TRIGGER trg_fk_debug_architecture_id_application_platform_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in application_platform ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_platform'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for architecture for fk ref from charm
CREATE TRIGGER trg_fk_debug_architecture_id_charm_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in charm ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for architecture for fk ref from charm_manifest_base
CREATE TRIGGER trg_fk_debug_architecture_id_charm_manifest_base_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in charm_manifest_base ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_manifest_base'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for architecture for fk ref from machine_agent_version
CREATE TRIGGER trg_fk_debug_architecture_id_machine_agent_version_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in machine_agent_version ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_agent_version'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for architecture for fk ref from machine_platform
CREATE TRIGGER trg_fk_debug_architecture_id_machine_platform_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in machine_platform ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_platform'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for architecture for fk ref from unit_agent_version
CREATE TRIGGER trg_fk_debug_architecture_id_unit_agent_version_architecture_id
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in unit_agent_version ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_agent_version'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for availability_zone for fk ref from availability_zone_subnet
CREATE TRIGGER trg_fk_debug_availability_zone_uuid_availability_zone_subnet_availability_zone_uuid
BEFORE DELETE ON 'availability_zone' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM availability_zone due to referencing rows in availability_zone_subnet ON availability_zone_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'availability_zone_subnet'
        WHERE availability_zone_uuid=OLD.uuid;
END;

-- fk debug delete trigger for availability_zone for fk ref from machine_cloud_instance
CREATE TRIGGER trg_fk_debug_availability_zone_uuid_machine_cloud_instance_availability_zone_uuid
BEFORE DELETE ON 'availability_zone' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM availability_zone due to referencing rows in machine_cloud_instance ON availability_zone_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_cloud_instance'
        WHERE availability_zone_uuid=OLD.uuid;
END;

-- fk debug delete trigger for block_command_type for fk ref from block_command
CREATE TRIGGER trg_fk_debug_block_command_type_id_block_command_block_command_type_id
BEFORE DELETE ON 'block_command_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM block_command_type due to referencing rows in block_command ON block_command_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'block_command'
        WHERE block_command_type_id=OLD.id;
END;

-- fk debug delete trigger for block_device for fk ref from block_device_link_device
CREATE TRIGGER trg_fk_debug_block_device_uuid_block_device_link_device_block_device_uuid
BEFORE DELETE ON 'block_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM block_device due to referencing rows in block_device_link_device ON block_device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'block_device_link_device'
        WHERE block_device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for block_device for fk ref from storage_volume_attachment
CREATE TRIGGER trg_fk_debug_block_device_uuid_storage_volume_attachment_block_device_uuid
BEFORE DELETE ON 'block_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM block_device due to referencing rows in storage_volume_attachment ON block_device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment'
        WHERE block_device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for change_log_edit_type for fk ref from change_log
CREATE TRIGGER trg_fk_debug_change_log_edit_type_id_change_log_edit_type_id
BEFORE DELETE ON 'change_log_edit_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM change_log_edit_type due to referencing rows in change_log ON edit_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'change_log'
        WHERE edit_type_id=OLD.id;
END;

-- fk debug delete trigger for change_log_namespace for fk ref from change_log
CREATE TRIGGER trg_fk_debug_change_log_namespace_id_change_log_namespace_id
BEFORE DELETE ON 'change_log_namespace' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM change_log_namespace due to referencing rows in change_log ON namespace_id')
                    ELSE
                        NULL
                    END panic
        FROM 'change_log'
        WHERE namespace_id=OLD.id;
END;

-- fk debug delete trigger for charm_action for fk ref from operation_action
CREATE TRIGGER trg_fk_debug_charm_action_charm_uuid_operation_action_charm_uuid
BEFORE DELETE ON 'charm_action' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_action due to referencing rows in operation_action ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_action'
        WHERE charm_uuid=OLD.charm_uuid;
END;

-- fk debug delete trigger for charm_action for fk ref from operation_action
CREATE TRIGGER trg_fk_debug_charm_action_key_operation_action_charm_action_key
BEFORE DELETE ON 'charm_action' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_action due to referencing rows in operation_action ON charm_action_key')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_action'
        WHERE charm_action_key=OLD.key;
END;

-- fk debug delete trigger for charm_config_type for fk ref from application_config
CREATE TRIGGER trg_fk_debug_charm_config_type_id_application_config_type_id
BEFORE DELETE ON 'charm_config_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_config_type due to referencing rows in application_config ON type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_config'
        WHERE type_id=OLD.id;
END;

-- fk debug delete trigger for charm_config_type for fk ref from charm_config
CREATE TRIGGER trg_fk_debug_charm_config_type_id_charm_config_type_id
BEFORE DELETE ON 'charm_config_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_config_type due to referencing rows in charm_config ON type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_config'
        WHERE type_id=OLD.id;
END;

-- fk debug delete trigger for charm_container for fk ref from charm_container_mount
CREATE TRIGGER trg_fk_debug_charm_container_charm_uuid_charm_container_mount_charm_uuid
BEFORE DELETE ON 'charm_container' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_container due to referencing rows in charm_container_mount ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_container_mount'
        WHERE charm_uuid=OLD.charm_uuid;
END;

-- fk debug delete trigger for charm_container for fk ref from charm_container_mount
CREATE TRIGGER trg_fk_debug_charm_container_key_charm_container_mount_charm_container_key
BEFORE DELETE ON 'charm_container' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_container due to referencing rows in charm_container_mount ON charm_container_key')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_container_mount'
        WHERE charm_container_key=OLD.key;
END;

-- fk debug delete trigger for charm_extra_binding for fk ref from application_extra_endpoint
CREATE TRIGGER trg_fk_debug_charm_extra_binding_uuid_application_extra_endpoint_charm_extra_binding_uuid
BEFORE DELETE ON 'charm_extra_binding' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_extra_binding due to referencing rows in application_extra_endpoint ON charm_extra_binding_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_extra_endpoint'
        WHERE charm_extra_binding_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm_relation_role for fk ref from charm_relation
CREATE TRIGGER trg_fk_debug_charm_relation_role_id_charm_relation_role_id
BEFORE DELETE ON 'charm_relation_role' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_relation_role due to referencing rows in charm_relation ON role_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_relation'
        WHERE role_id=OLD.id;
END;

-- fk debug delete trigger for charm_relation_scope for fk ref from charm_relation
CREATE TRIGGER trg_fk_debug_charm_relation_scope_id_charm_relation_scope_id
BEFORE DELETE ON 'charm_relation_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_relation_scope due to referencing rows in charm_relation ON scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_relation'
        WHERE scope_id=OLD.id;
END;

-- fk debug delete trigger for charm_relation_scope for fk ref from relation
CREATE TRIGGER trg_fk_debug_charm_relation_scope_id_relation_scope_id
BEFORE DELETE ON 'charm_relation_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_relation_scope due to referencing rows in relation ON scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'relation'
        WHERE scope_id=OLD.id;
END;

-- fk debug delete trigger for charm_relation for fk ref from application_endpoint
CREATE TRIGGER trg_fk_debug_charm_relation_uuid_application_endpoint_charm_relation_uuid
BEFORE DELETE ON 'charm_relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_relation due to referencing rows in application_endpoint ON charm_relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_endpoint'
        WHERE charm_relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm_relation for fk ref from port_range
CREATE TRIGGER trg_fk_debug_charm_relation_uuid_port_range_relation_uuid
BEFORE DELETE ON 'charm_relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_relation due to referencing rows in port_range ON relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'port_range'
        WHERE relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm_resource_kind for fk ref from charm_resource
CREATE TRIGGER trg_fk_debug_charm_resource_kind_id_charm_resource_kind_id
BEFORE DELETE ON 'charm_resource_kind' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_resource_kind due to referencing rows in charm_resource ON kind_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_resource'
        WHERE kind_id=OLD.id;
END;

-- fk debug delete trigger for charm_resource for fk ref from resource
CREATE TRIGGER trg_fk_debug_charm_resource_charm_uuid_resource_charm_uuid
BEFORE DELETE ON 'charm_resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_resource due to referencing rows in resource ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'resource'
        WHERE charm_uuid=OLD.charm_uuid;
END;

-- fk debug delete trigger for charm_resource for fk ref from resource
CREATE TRIGGER trg_fk_debug_charm_resource_name_resource_charm_resource_name
BEFORE DELETE ON 'charm_resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_resource due to referencing rows in resource ON charm_resource_name')
                    ELSE
                        NULL
                    END panic
        FROM 'resource'
        WHERE charm_resource_name=OLD.name;
END;

-- fk debug delete trigger for charm_run_as_kind for fk ref from charm_metadata
CREATE TRIGGER trg_fk_debug_charm_run_as_kind_id_charm_metadata_run_as_id
BEFORE DELETE ON 'charm_run_as_kind' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_run_as_kind due to referencing rows in charm_metadata ON run_as_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_metadata'
        WHERE run_as_id=OLD.id;
END;

-- fk debug delete trigger for charm_source for fk ref from charm
CREATE TRIGGER trg_fk_debug_charm_source_id_charm_source_id
BEFORE DELETE ON 'charm_source' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_source due to referencing rows in charm ON source_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm'
        WHERE source_id=OLD.id;
END;

-- fk debug delete trigger for charm_storage_kind for fk ref from charm_storage
CREATE TRIGGER trg_fk_debug_charm_storage_kind_id_charm_storage_storage_kind_id
BEFORE DELETE ON 'charm_storage_kind' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage_kind due to referencing rows in charm_storage ON storage_kind_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_storage'
        WHERE storage_kind_id=OLD.id;
END;

-- fk debug delete trigger for charm_storage for fk ref from application_storage_directive
CREATE TRIGGER trg_fk_debug_charm_storage_charm_uuid_application_storage_directive_charm_uuid
BEFORE DELETE ON 'charm_storage' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage due to referencing rows in application_storage_directive ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_storage_directive'
        WHERE charm_uuid=OLD.charm_uuid;
END;

-- fk debug delete trigger for charm_storage for fk ref from charm_storage_property
CREATE TRIGGER trg_fk_debug_charm_storage_charm_uuid_charm_storage_property_charm_uuid
BEFORE DELETE ON 'charm_storage' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage due to referencing rows in charm_storage_property ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_storage_property'
        WHERE charm_uuid=OLD.charm_uuid;
END;

-- fk debug delete trigger for charm_storage for fk ref from unit_storage_directive
CREATE TRIGGER trg_fk_debug_charm_storage_charm_uuid_unit_storage_directive_charm_uuid
BEFORE DELETE ON 'charm_storage' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage due to referencing rows in unit_storage_directive ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_storage_directive'
        WHERE charm_uuid=OLD.charm_uuid;
END;

-- fk debug delete trigger for charm_storage for fk ref from application_storage_directive
CREATE TRIGGER trg_fk_debug_charm_storage_name_application_storage_directive_storage_name
BEFORE DELETE ON 'charm_storage' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage due to referencing rows in application_storage_directive ON storage_name')
                    ELSE
                        NULL
                    END panic
        FROM 'application_storage_directive'
        WHERE storage_name=OLD.name;
END;

-- fk debug delete trigger for charm_storage for fk ref from charm_storage_property
CREATE TRIGGER trg_fk_debug_charm_storage_name_charm_storage_property_charm_storage_name
BEFORE DELETE ON 'charm_storage' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage due to referencing rows in charm_storage_property ON charm_storage_name')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_storage_property'
        WHERE charm_storage_name=OLD.name;
END;

-- fk debug delete trigger for charm_storage for fk ref from unit_storage_directive
CREATE TRIGGER trg_fk_debug_charm_storage_name_unit_storage_directive_storage_name
BEFORE DELETE ON 'charm_storage' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm_storage due to referencing rows in unit_storage_directive ON storage_name')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_storage_directive'
        WHERE storage_name=OLD.name;
END;

-- fk debug delete trigger for charm for fk ref from annotation_charm
CREATE TRIGGER trg_fk_debug_charm_uuid_annotation_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in annotation_charm ON uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'annotation_charm'
        WHERE uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from application
CREATE TRIGGER trg_fk_debug_charm_uuid_application_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in application ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_action
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_action_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_action ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_action'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_category
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_category_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_category ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_category'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_config
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_config_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_config ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_config'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_container
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_container_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_container ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_container'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_container_mount
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_container_mount_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_container_mount ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_container_mount'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_device
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_device_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_device ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_device'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_download_info
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_download_info_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_download_info ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_download_info'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_extra_binding
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_extra_binding_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_extra_binding ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_extra_binding'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_hash
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_hash_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_hash ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_hash'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_manifest_base
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_manifest_base_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_manifest_base ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_manifest_base'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_metadata
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_metadata_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_metadata ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_metadata'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_relation
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_relation_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_relation ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_relation'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_resource
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_resource_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_resource ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_resource'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_storage
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_storage_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_storage ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_storage'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_storage_property
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_storage_property_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_storage_property ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_storage_property'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_tag
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_tag_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_tag ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_tag'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from charm_term
CREATE TRIGGER trg_fk_debug_charm_uuid_charm_term_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in charm_term ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_term'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for charm for fk ref from unit
CREATE TRIGGER trg_fk_debug_charm_uuid_unit_charm_uuid
BEFORE DELETE ON 'charm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM charm due to referencing rows in unit ON charm_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit'
        WHERE charm_uuid=OLD.uuid;
END;

-- fk debug delete trigger for constraint for fk ref from application_constraint
CREATE TRIGGER trg_fk_debug_constraint_uuid_application_constraint_constraint_uuid
BEFORE DELETE ON 'constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM constraint due to referencing rows in application_constraint ON constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_constraint'
        WHERE constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for constraint for fk ref from constraint_space
CREATE TRIGGER trg_fk_debug_constraint_uuid_constraint_space_constraint_uuid
BEFORE DELETE ON 'constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM constraint due to referencing rows in constraint_space ON constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'constraint_space'
        WHERE constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for constraint for fk ref from constraint_tag
CREATE TRIGGER trg_fk_debug_constraint_uuid_constraint_tag_constraint_uuid
BEFORE DELETE ON 'constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM constraint due to referencing rows in constraint_tag ON constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'constraint_tag'
        WHERE constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for constraint for fk ref from constraint_zone
CREATE TRIGGER trg_fk_debug_constraint_uuid_constraint_zone_constraint_uuid
BEFORE DELETE ON 'constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM constraint due to referencing rows in constraint_zone ON constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'constraint_zone'
        WHERE constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for constraint for fk ref from machine_constraint
CREATE TRIGGER trg_fk_debug_constraint_uuid_machine_constraint_constraint_uuid
BEFORE DELETE ON 'constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM constraint due to referencing rows in machine_constraint ON constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_constraint'
        WHERE constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for constraint for fk ref from model_constraint
CREATE TRIGGER trg_fk_debug_constraint_uuid_model_constraint_constraint_uuid
BEFORE DELETE ON 'constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM constraint due to referencing rows in model_constraint ON constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_constraint'
        WHERE constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for container_type for fk ref from constraint
CREATE TRIGGER trg_fk_debug_container_type_id_constraint_container_type_id
BEFORE DELETE ON 'container_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM container_type due to referencing rows in constraint ON container_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'constraint'
        WHERE container_type_id=OLD.id;
END;

-- fk debug delete trigger for container_type for fk ref from machine_container_type
CREATE TRIGGER trg_fk_debug_container_type_id_machine_container_type_container_type_id
BEFORE DELETE ON 'container_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM container_type due to referencing rows in machine_container_type ON container_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_container_type'
        WHERE container_type_id=OLD.id;
END;

-- fk debug delete trigger for device_constraint for fk ref from device_constraint_attribute
CREATE TRIGGER trg_fk_debug_device_constraint_uuid_device_constraint_attribute_device_constraint_uuid
BEFORE DELETE ON 'device_constraint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM device_constraint due to referencing rows in device_constraint_attribute ON device_constraint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'device_constraint_attribute'
        WHERE device_constraint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for fqdn_address for fk ref from net_node_fqdn_address
CREATE TRIGGER trg_fk_debug_fqdn_address_uuid_net_node_fqdn_address_address_uuid
BEFORE DELETE ON 'fqdn_address' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM fqdn_address due to referencing rows in net_node_fqdn_address ON address_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'net_node_fqdn_address'
        WHERE address_uuid=OLD.uuid;
END;

-- fk debug delete trigger for hash_kind for fk ref from charm_hash
CREATE TRIGGER trg_fk_debug_hash_kind_id_charm_hash_hash_kind_id
BEFORE DELETE ON 'hash_kind' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM hash_kind due to referencing rows in charm_hash ON hash_kind_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_hash'
        WHERE hash_kind_id=OLD.id;
END;

-- fk debug delete trigger for hostname_address for fk ref from net_node_hostname_address
CREATE TRIGGER trg_fk_debug_hostname_address_uuid_net_node_hostname_address_address_uuid
BEFORE DELETE ON 'hostname_address' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM hostname_address due to referencing rows in net_node_hostname_address ON address_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'net_node_hostname_address'
        WHERE address_uuid=OLD.uuid;
END;

-- fk debug delete trigger for ip_address_config_type for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_ip_address_config_type_id_ip_address_config_type_id
BEFORE DELETE ON 'ip_address_config_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM ip_address_config_type due to referencing rows in ip_address ON config_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE config_type_id=OLD.id;
END;

-- fk debug delete trigger for ip_address_origin for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_ip_address_origin_id_ip_address_origin_id
BEFORE DELETE ON 'ip_address_origin' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM ip_address_origin due to referencing rows in ip_address ON origin_id')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE origin_id=OLD.id;
END;

-- fk debug delete trigger for ip_address_scope for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_ip_address_scope_id_ip_address_scope_id
BEFORE DELETE ON 'ip_address_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM ip_address_scope due to referencing rows in ip_address ON scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE scope_id=OLD.id;
END;

-- fk debug delete trigger for ip_address_type for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_ip_address_type_id_ip_address_type_id
BEFORE DELETE ON 'ip_address_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM ip_address_type due to referencing rows in ip_address ON type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE type_id=OLD.id;
END;

-- fk debug delete trigger for ip_address for fk ref from provider_ip_address
CREATE TRIGGER trg_fk_debug_ip_address_uuid_provider_ip_address_address_uuid
BEFORE DELETE ON 'ip_address' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM ip_address due to referencing rows in provider_ip_address ON address_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'provider_ip_address'
        WHERE address_uuid=OLD.uuid;
END;

-- fk debug delete trigger for k8s_pod_status_value for fk ref from k8s_pod_status
CREATE TRIGGER trg_fk_debug_k8s_pod_status_value_id_k8s_pod_status_status_id
BEFORE DELETE ON 'k8s_pod_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM k8s_pod_status_value due to referencing rows in k8s_pod_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'k8s_pod_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for k8s_pod for fk ref from k8s_pod_port
CREATE TRIGGER trg_fk_debug_k8s_pod_unit_uuid_k8s_pod_port_unit_uuid
BEFORE DELETE ON 'k8s_pod' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM k8s_pod due to referencing rows in k8s_pod_port ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'k8s_pod_port'
        WHERE unit_uuid=OLD.unit_uuid;
END;

-- fk debug delete trigger for life for fk ref from application
CREATE TRIGGER trg_fk_debug_life_id_application_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in application ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from application_remote_consumer
CREATE TRIGGER trg_fk_debug_life_id_application_remote_consumer_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in application_remote_consumer ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_consumer'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from application_remote_offerer
CREATE TRIGGER trg_fk_debug_life_id_application_remote_offerer_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in application_remote_offerer ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_offerer'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from machine
CREATE TRIGGER trg_fk_debug_life_id_machine_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in machine ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from machine_cloud_instance
CREATE TRIGGER trg_fk_debug_life_id_machine_cloud_instance_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in machine_cloud_instance ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_cloud_instance'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from model_life
CREATE TRIGGER trg_fk_debug_life_id_model_life_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in model_life ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'model_life'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from relation
CREATE TRIGGER trg_fk_debug_life_id_relation_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in relation ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'relation'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_attachment
CREATE TRIGGER trg_fk_debug_life_id_storage_attachment_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_attachment ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_attachment'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_filesystem
CREATE TRIGGER trg_fk_debug_life_id_storage_filesystem_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_filesystem ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_filesystem_attachment
CREATE TRIGGER trg_fk_debug_life_id_storage_filesystem_attachment_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_filesystem_attachment ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem_attachment'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_instance
CREATE TRIGGER trg_fk_debug_life_id_storage_instance_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_instance ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_volume
CREATE TRIGGER trg_fk_debug_life_id_storage_volume_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_volume ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_volume_attachment
CREATE TRIGGER trg_fk_debug_life_id_storage_volume_attachment_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_volume_attachment ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from storage_volume_attachment_plan
CREATE TRIGGER trg_fk_debug_life_id_storage_volume_attachment_plan_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in storage_volume_attachment_plan ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment_plan'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for life for fk ref from unit
CREATE TRIGGER trg_fk_debug_life_id_unit_life_id
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in unit ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'unit'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for link_layer_device_type for fk ref from link_layer_device
CREATE TRIGGER trg_fk_debug_link_layer_device_type_id_link_layer_device_device_type_id
BEFORE DELETE ON 'link_layer_device_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device_type due to referencing rows in link_layer_device ON device_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device'
        WHERE device_type_id=OLD.id;
END;

-- fk debug delete trigger for link_layer_device for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_ip_address_device_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in ip_address ON device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for link_layer_device for fk ref from link_layer_device_dns_address
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_link_layer_device_dns_address_device_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in link_layer_device_dns_address ON device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device_dns_address'
        WHERE device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for link_layer_device for fk ref from link_layer_device_dns_domain
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_link_layer_device_dns_domain_device_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in link_layer_device_dns_domain ON device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device_dns_domain'
        WHERE device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for link_layer_device for fk ref from link_layer_device_parent
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_link_layer_device_parent_parent_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in link_layer_device_parent ON parent_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device_parent'
        WHERE parent_uuid=OLD.uuid;
END;

-- fk debug delete trigger for link_layer_device for fk ref from link_layer_device_parent
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_link_layer_device_parent_device_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in link_layer_device_parent ON device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device_parent'
        WHERE device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for link_layer_device for fk ref from link_layer_device_route
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_link_layer_device_route_device_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in link_layer_device_route ON device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device_route'
        WHERE device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for link_layer_device for fk ref from provider_link_layer_device
CREATE TRIGGER trg_fk_debug_link_layer_device_uuid_provider_link_layer_device_device_uuid
BEFORE DELETE ON 'link_layer_device' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM link_layer_device due to referencing rows in provider_link_layer_device ON device_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'provider_link_layer_device'
        WHERE device_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine_cloud_instance_status_value for fk ref from machine_cloud_instance_status
CREATE TRIGGER trg_fk_debug_machine_cloud_instance_status_value_id_machine_cloud_instance_status_status_id
BEFORE DELETE ON 'machine_cloud_instance_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine_cloud_instance_status_value due to referencing rows in machine_cloud_instance_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_cloud_instance_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for machine_cloud_instance for fk ref from machine_cloud_instance_status
CREATE TRIGGER trg_fk_debug_machine_cloud_instance_machine_uuid_machine_cloud_instance_status_machine_uuid
BEFORE DELETE ON 'machine_cloud_instance' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine_cloud_instance due to referencing rows in machine_cloud_instance_status ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_cloud_instance_status'
        WHERE machine_uuid=OLD.machine_uuid;
END;

-- fk debug delete trigger for machine_placement_scope for fk ref from machine_placement
CREATE TRIGGER trg_fk_debug_machine_placement_scope_id_machine_placement_scope_id
BEFORE DELETE ON 'machine_placement_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine_placement_scope due to referencing rows in machine_placement ON scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_placement'
        WHERE scope_id=OLD.id;
END;

-- fk debug delete trigger for machine_status_value for fk ref from machine_status
CREATE TRIGGER trg_fk_debug_machine_status_value_id_machine_status_status_id
BEFORE DELETE ON 'machine_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine_status_value due to referencing rows in machine_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for machine for fk ref from block_device
CREATE TRIGGER trg_fk_debug_machine_uuid_block_device_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in block_device ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'block_device'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from block_device_link_device
CREATE TRIGGER trg_fk_debug_machine_uuid_block_device_link_device_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in block_device_link_device ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'block_device_link_device'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from instance_tag
CREATE TRIGGER trg_fk_debug_machine_uuid_instance_tag_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in instance_tag ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'instance_tag'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_agent_presence
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_agent_presence_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_agent_presence ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_agent_presence'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_agent_version
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_agent_version_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_agent_version ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_agent_version'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_cloud_instance
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_cloud_instance_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_cloud_instance ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_cloud_instance'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_constraint
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_constraint_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_constraint ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_constraint'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_container_type
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_container_type_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_container_type ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_container_type'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_filesystem
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_filesystem_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_filesystem ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_filesystem'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_lxd_profile
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_lxd_profile_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_lxd_profile ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_lxd_profile'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_manual
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_manual_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_manual ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_manual'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_parent
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_parent_parent_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_parent ON parent_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_parent'
        WHERE parent_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_parent
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_parent_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_parent ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_parent'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_placement
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_placement_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_placement ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_placement'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_platform
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_platform_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_platform ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_platform'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_requires_reboot
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_requires_reboot_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_requires_reboot ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_requires_reboot'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_ssh_host_key
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_ssh_host_key_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_ssh_host_key ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_ssh_host_key'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_status
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_status_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_status ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_status'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from machine_volume
CREATE TRIGGER trg_fk_debug_machine_uuid_machine_volume_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in machine_volume ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_volume'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for machine for fk ref from operation_machine_task
CREATE TRIGGER trg_fk_debug_machine_uuid_operation_machine_task_machine_uuid
BEFORE DELETE ON 'machine' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM machine due to referencing rows in operation_machine_task ON machine_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_machine_task'
        WHERE machine_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_agent
CREATE TRIGGER trg_fk_debug_model_uuid_model_agent_model_uuid
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_agent ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_agent'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_constraint
CREATE TRIGGER trg_fk_debug_model_uuid_model_constraint_model_uuid
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_constraint ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_constraint'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_life
CREATE TRIGGER trg_fk_debug_model_uuid_model_life_model_uuid
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_life ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_life'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_net_node_uuid_ip_address_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in ip_address ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from k8s_service
CREATE TRIGGER trg_fk_debug_net_node_uuid_k8s_service_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in k8s_service ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'k8s_service'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from link_layer_device
CREATE TRIGGER trg_fk_debug_net_node_uuid_link_layer_device_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in link_layer_device ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from machine
CREATE TRIGGER trg_fk_debug_net_node_uuid_machine_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in machine ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from net_node_fqdn_address
CREATE TRIGGER trg_fk_debug_net_node_uuid_net_node_fqdn_address_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in net_node_fqdn_address ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'net_node_fqdn_address'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from net_node_hostname_address
CREATE TRIGGER trg_fk_debug_net_node_uuid_net_node_hostname_address_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in net_node_hostname_address ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'net_node_hostname_address'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from storage_filesystem_attachment
CREATE TRIGGER trg_fk_debug_net_node_uuid_storage_filesystem_attachment_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in storage_filesystem_attachment ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem_attachment'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from storage_volume_attachment
CREATE TRIGGER trg_fk_debug_net_node_uuid_storage_volume_attachment_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in storage_volume_attachment ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from storage_volume_attachment_plan
CREATE TRIGGER trg_fk_debug_net_node_uuid_storage_volume_attachment_plan_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in storage_volume_attachment_plan ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment_plan'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for net_node for fk ref from unit
CREATE TRIGGER trg_fk_debug_net_node_uuid_unit_net_node_uuid
BEFORE DELETE ON 'net_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM net_node due to referencing rows in unit ON net_node_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit'
        WHERE net_node_uuid=OLD.uuid;
END;

-- fk debug delete trigger for network_address_scope for fk ref from fqdn_address
CREATE TRIGGER trg_fk_debug_network_address_scope_id_fqdn_address_scope_id
BEFORE DELETE ON 'network_address_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM network_address_scope due to referencing rows in fqdn_address ON scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'fqdn_address'
        WHERE scope_id=OLD.id;
END;

-- fk debug delete trigger for network_address_scope for fk ref from hostname_address
CREATE TRIGGER trg_fk_debug_network_address_scope_id_hostname_address_scope_id
BEFORE DELETE ON 'network_address_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM network_address_scope due to referencing rows in hostname_address ON scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'hostname_address'
        WHERE scope_id=OLD.id;
END;

-- fk debug delete trigger for object_store_metadata_path for fk ref from operation_task_output
CREATE TRIGGER trg_fk_debug_object_store_metadata_path_path_operation_task_output_store_path
BEFORE DELETE ON 'object_store_metadata_path' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata_path due to referencing rows in operation_task_output ON store_path')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_task_output'
        WHERE store_path=OLD.path;
END;

-- fk debug delete trigger for object_store_metadata for fk ref from agent_binary_store
CREATE TRIGGER trg_fk_debug_object_store_metadata_uuid_agent_binary_store_object_store_uuid
BEFORE DELETE ON 'object_store_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata due to referencing rows in agent_binary_store ON object_store_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'agent_binary_store'
        WHERE object_store_uuid=OLD.uuid;
END;

-- fk debug delete trigger for object_store_metadata for fk ref from charm
CREATE TRIGGER trg_fk_debug_object_store_metadata_uuid_charm_object_store_uuid
BEFORE DELETE ON 'object_store_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata due to referencing rows in charm ON object_store_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'charm'
        WHERE object_store_uuid=OLD.uuid;
END;

-- fk debug delete trigger for object_store_metadata for fk ref from object_store_metadata_path
CREATE TRIGGER trg_fk_debug_object_store_metadata_uuid_object_store_metadata_path_metadata_uuid
BEFORE DELETE ON 'object_store_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata due to referencing rows in object_store_metadata_path ON metadata_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'object_store_metadata_path'
        WHERE metadata_uuid=OLD.uuid;
END;

-- fk debug delete trigger for object_store_metadata for fk ref from resource_file_store
CREATE TRIGGER trg_fk_debug_object_store_metadata_uuid_resource_file_store_store_uuid
BEFORE DELETE ON 'object_store_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata due to referencing rows in resource_file_store ON store_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'resource_file_store'
        WHERE store_uuid=OLD.uuid;
END;

-- fk debug delete trigger for offer_connection for fk ref from application_remote_consumer
CREATE TRIGGER trg_fk_debug_offer_connection_uuid_application_remote_consumer_offer_connection_uuid
BEFORE DELETE ON 'offer_connection' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM offer_connection due to referencing rows in application_remote_consumer ON offer_connection_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_consumer'
        WHERE offer_connection_uuid=OLD.uuid;
END;

-- fk debug delete trigger for offer for fk ref from offer_connection
CREATE TRIGGER trg_fk_debug_offer_uuid_offer_connection_offer_uuid
BEFORE DELETE ON 'offer' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM offer due to referencing rows in offer_connection ON offer_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'offer_connection'
        WHERE offer_uuid=OLD.uuid;
END;

-- fk debug delete trigger for offer for fk ref from offer_endpoint
CREATE TRIGGER trg_fk_debug_offer_uuid_offer_endpoint_offer_uuid
BEFORE DELETE ON 'offer' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM offer due to referencing rows in offer_endpoint ON offer_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'offer_endpoint'
        WHERE offer_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation_task_status_value for fk ref from operation_task_status
CREATE TRIGGER trg_fk_debug_operation_task_status_value_id_operation_task_status_status_id
BEFORE DELETE ON 'operation_task_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation_task_status_value due to referencing rows in operation_task_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_task_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for operation_task for fk ref from operation_machine_task
CREATE TRIGGER trg_fk_debug_operation_task_uuid_operation_machine_task_task_uuid
BEFORE DELETE ON 'operation_task' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation_task due to referencing rows in operation_machine_task ON task_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_machine_task'
        WHERE task_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation_task for fk ref from operation_task_log
CREATE TRIGGER trg_fk_debug_operation_task_uuid_operation_task_log_task_uuid
BEFORE DELETE ON 'operation_task' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation_task due to referencing rows in operation_task_log ON task_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_task_log'
        WHERE task_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation_task for fk ref from operation_task_output
CREATE TRIGGER trg_fk_debug_operation_task_uuid_operation_task_output_task_uuid
BEFORE DELETE ON 'operation_task' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation_task due to referencing rows in operation_task_output ON task_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_task_output'
        WHERE task_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation_task for fk ref from operation_task_status
CREATE TRIGGER trg_fk_debug_operation_task_uuid_operation_task_status_task_uuid
BEFORE DELETE ON 'operation_task' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation_task due to referencing rows in operation_task_status ON task_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_task_status'
        WHERE task_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation_task for fk ref from operation_unit_task
CREATE TRIGGER trg_fk_debug_operation_task_uuid_operation_unit_task_task_uuid
BEFORE DELETE ON 'operation_task' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation_task due to referencing rows in operation_unit_task ON task_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_unit_task'
        WHERE task_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation for fk ref from operation_action
CREATE TRIGGER trg_fk_debug_operation_uuid_operation_action_operation_uuid
BEFORE DELETE ON 'operation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation due to referencing rows in operation_action ON operation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_action'
        WHERE operation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation for fk ref from operation_parameter
CREATE TRIGGER trg_fk_debug_operation_uuid_operation_parameter_operation_uuid
BEFORE DELETE ON 'operation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation due to referencing rows in operation_parameter ON operation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_parameter'
        WHERE operation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for operation for fk ref from operation_task
CREATE TRIGGER trg_fk_debug_operation_uuid_operation_task_operation_uuid
BEFORE DELETE ON 'operation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM operation due to referencing rows in operation_task ON operation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_task'
        WHERE operation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for os for fk ref from application_platform
CREATE TRIGGER trg_fk_debug_os_id_application_platform_os_id
BEFORE DELETE ON 'os' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM os due to referencing rows in application_platform ON os_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_platform'
        WHERE os_id=OLD.id;
END;

-- fk debug delete trigger for os for fk ref from charm_manifest_base
CREATE TRIGGER trg_fk_debug_os_id_charm_manifest_base_os_id
BEFORE DELETE ON 'os' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM os due to referencing rows in charm_manifest_base ON os_id')
                    ELSE
                        NULL
                    END panic
        FROM 'charm_manifest_base'
        WHERE os_id=OLD.id;
END;

-- fk debug delete trigger for os for fk ref from machine_platform
CREATE TRIGGER trg_fk_debug_os_id_machine_platform_os_id
BEFORE DELETE ON 'os' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM os due to referencing rows in machine_platform ON os_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_platform'
        WHERE os_id=OLD.id;
END;

-- fk debug delete trigger for password_hash_algorithm for fk ref from application_agent
CREATE TRIGGER trg_fk_debug_password_hash_algorithm_id_application_agent_password_hash_algorithm_id
BEFORE DELETE ON 'password_hash_algorithm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM password_hash_algorithm due to referencing rows in application_agent ON password_hash_algorithm_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_agent'
        WHERE password_hash_algorithm_id=OLD.id;
END;

-- fk debug delete trigger for password_hash_algorithm for fk ref from machine
CREATE TRIGGER trg_fk_debug_password_hash_algorithm_id_machine_password_hash_algorithm_id
BEFORE DELETE ON 'password_hash_algorithm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM password_hash_algorithm due to referencing rows in machine ON password_hash_algorithm_id')
                    ELSE
                        NULL
                    END panic
        FROM 'machine'
        WHERE password_hash_algorithm_id=OLD.id;
END;

-- fk debug delete trigger for password_hash_algorithm for fk ref from model_agent
CREATE TRIGGER trg_fk_debug_password_hash_algorithm_id_model_agent_password_hash_algorithm_id
BEFORE DELETE ON 'password_hash_algorithm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM password_hash_algorithm due to referencing rows in model_agent ON password_hash_algorithm_id')
                    ELSE
                        NULL
                    END panic
        FROM 'model_agent'
        WHERE password_hash_algorithm_id=OLD.id;
END;

-- fk debug delete trigger for password_hash_algorithm for fk ref from unit
CREATE TRIGGER trg_fk_debug_password_hash_algorithm_id_unit_password_hash_algorithm_id
BEFORE DELETE ON 'password_hash_algorithm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM password_hash_algorithm due to referencing rows in unit ON password_hash_algorithm_id')
                    ELSE
                        NULL
                    END panic
        FROM 'unit'
        WHERE password_hash_algorithm_id=OLD.id;
END;

-- fk debug delete trigger for protocol for fk ref from port_range
CREATE TRIGGER trg_fk_debug_protocol_id_port_range_protocol_id
BEFORE DELETE ON 'protocol' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM protocol due to referencing rows in port_range ON protocol_id')
                    ELSE
                        NULL
                    END panic
        FROM 'port_range'
        WHERE protocol_id=OLD.id;
END;

-- fk debug delete trigger for provider_network for fk ref from provider_network_subnet
CREATE TRIGGER trg_fk_debug_provider_network_uuid_provider_network_subnet_provider_network_uuid
BEFORE DELETE ON 'provider_network' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM provider_network due to referencing rows in provider_network_subnet ON provider_network_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'provider_network_subnet'
        WHERE provider_network_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation_endpoint for fk ref from relation_application_setting
CREATE TRIGGER trg_fk_debug_relation_endpoint_uuid_relation_application_setting_relation_endpoint_uuid
BEFORE DELETE ON 'relation_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation_endpoint due to referencing rows in relation_application_setting ON relation_endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_application_setting'
        WHERE relation_endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation_endpoint for fk ref from relation_application_settings_hash
CREATE TRIGGER trg_fk_debug_relation_endpoint_uuid_relation_application_settings_hash_relation_endpoint_uuid
BEFORE DELETE ON 'relation_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation_endpoint due to referencing rows in relation_application_settings_hash ON relation_endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_application_settings_hash'
        WHERE relation_endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation_endpoint for fk ref from relation_unit
CREATE TRIGGER trg_fk_debug_relation_endpoint_uuid_relation_unit_relation_endpoint_uuid
BEFORE DELETE ON 'relation_endpoint' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation_endpoint due to referencing rows in relation_unit ON relation_endpoint_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_unit'
        WHERE relation_endpoint_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation_status_type for fk ref from relation_status
CREATE TRIGGER trg_fk_debug_relation_status_type_id_relation_status_relation_status_type_id
BEFORE DELETE ON 'relation_status_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation_status_type due to referencing rows in relation_status ON relation_status_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_status'
        WHERE relation_status_type_id=OLD.id;
END;

-- fk debug delete trigger for relation_unit for fk ref from relation_unit_setting
CREATE TRIGGER trg_fk_debug_relation_unit_uuid_relation_unit_setting_relation_unit_uuid
BEFORE DELETE ON 'relation_unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation_unit due to referencing rows in relation_unit_setting ON relation_unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_unit_setting'
        WHERE relation_unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation_unit for fk ref from relation_unit_settings_hash
CREATE TRIGGER trg_fk_debug_relation_unit_uuid_relation_unit_settings_hash_relation_unit_uuid
BEFORE DELETE ON 'relation_unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation_unit due to referencing rows in relation_unit_settings_hash ON relation_unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_unit_settings_hash'
        WHERE relation_unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation for fk ref from application_remote_offerer_relation_macaroon
CREATE TRIGGER trg_fk_debug_relation_uuid_application_remote_offerer_relation_macaroon_relation_uuid
BEFORE DELETE ON 'relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation due to referencing rows in application_remote_offerer_relation_macaroon ON relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_offerer_relation_macaroon'
        WHERE relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation for fk ref from application_remote_relation
CREATE TRIGGER trg_fk_debug_relation_uuid_application_remote_relation_relation_uuid
BEFORE DELETE ON 'relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation due to referencing rows in application_remote_relation ON relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_relation'
        WHERE relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation for fk ref from relation_endpoint
CREATE TRIGGER trg_fk_debug_relation_uuid_relation_endpoint_relation_uuid
BEFORE DELETE ON 'relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation due to referencing rows in relation_endpoint ON relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_endpoint'
        WHERE relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation for fk ref from relation_status
CREATE TRIGGER trg_fk_debug_relation_uuid_relation_status_relation_uuid
BEFORE DELETE ON 'relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation due to referencing rows in relation_status ON relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_status'
        WHERE relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for relation for fk ref from relation_unit_setting_archive
CREATE TRIGGER trg_fk_debug_relation_uuid_relation_unit_setting_archive_relation_uuid
BEFORE DELETE ON 'relation' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM relation due to referencing rows in relation_unit_setting_archive ON relation_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_unit_setting_archive'
        WHERE relation_uuid=OLD.uuid;
END;

-- fk debug delete trigger for removal_type for fk ref from removal
CREATE TRIGGER trg_fk_debug_removal_type_id_removal_removal_type_id
BEFORE DELETE ON 'removal_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM removal_type due to referencing rows in removal ON removal_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'removal'
        WHERE removal_type_id=OLD.id;
END;

-- fk debug delete trigger for resolve_mode for fk ref from unit_resolved
CREATE TRIGGER trg_fk_debug_resolve_mode_id_unit_resolved_mode_id
BEFORE DELETE ON 'resolve_mode' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resolve_mode due to referencing rows in unit_resolved ON mode_id')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_resolved'
        WHERE mode_id=OLD.id;
END;

-- fk debug delete trigger for resource_container_image_metadata_store for fk ref from resource_image_store
CREATE TRIGGER trg_fk_debug_resource_container_image_metadata_store_storage_key_resource_image_store_store_storage_key
BEFORE DELETE ON 'resource_container_image_metadata_store' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource_container_image_metadata_store due to referencing rows in resource_image_store ON store_storage_key')
                    ELSE
                        NULL
                    END panic
        FROM 'resource_image_store'
        WHERE store_storage_key=OLD.storage_key;
END;

-- fk debug delete trigger for resource_origin_type for fk ref from resource
CREATE TRIGGER trg_fk_debug_resource_origin_type_id_resource_origin_type_id
BEFORE DELETE ON 'resource_origin_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource_origin_type due to referencing rows in resource ON origin_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'resource'
        WHERE origin_type_id=OLD.id;
END;

-- fk debug delete trigger for resource_retrieved_by_type for fk ref from resource_retrieved_by
CREATE TRIGGER trg_fk_debug_resource_retrieved_by_type_id_resource_retrieved_by_retrieved_by_type_id
BEFORE DELETE ON 'resource_retrieved_by_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource_retrieved_by_type due to referencing rows in resource_retrieved_by ON retrieved_by_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'resource_retrieved_by'
        WHERE retrieved_by_type_id=OLD.id;
END;

-- fk debug delete trigger for resource_state for fk ref from resource
CREATE TRIGGER trg_fk_debug_resource_state_id_resource_state_id
BEFORE DELETE ON 'resource_state' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource_state due to referencing rows in resource ON state_id')
                    ELSE
                        NULL
                    END panic
        FROM 'resource'
        WHERE state_id=OLD.id;
END;

-- fk debug delete trigger for resource for fk ref from application_resource
CREATE TRIGGER trg_fk_debug_resource_uuid_application_resource_resource_uuid
BEFORE DELETE ON 'resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource due to referencing rows in application_resource ON resource_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_resource'
        WHERE resource_uuid=OLD.uuid;
END;

-- fk debug delete trigger for resource for fk ref from pending_application_resource
CREATE TRIGGER trg_fk_debug_resource_uuid_pending_application_resource_resource_uuid
BEFORE DELETE ON 'resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource due to referencing rows in pending_application_resource ON resource_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'pending_application_resource'
        WHERE resource_uuid=OLD.uuid;
END;

-- fk debug delete trigger for resource for fk ref from resource_file_store
CREATE TRIGGER trg_fk_debug_resource_uuid_resource_file_store_resource_uuid
BEFORE DELETE ON 'resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource due to referencing rows in resource_file_store ON resource_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'resource_file_store'
        WHERE resource_uuid=OLD.uuid;
END;

-- fk debug delete trigger for resource for fk ref from resource_image_store
CREATE TRIGGER trg_fk_debug_resource_uuid_resource_image_store_resource_uuid
BEFORE DELETE ON 'resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource due to referencing rows in resource_image_store ON resource_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'resource_image_store'
        WHERE resource_uuid=OLD.uuid;
END;

-- fk debug delete trigger for resource for fk ref from resource_retrieved_by
CREATE TRIGGER trg_fk_debug_resource_uuid_resource_retrieved_by_resource_uuid
BEFORE DELETE ON 'resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource due to referencing rows in resource_retrieved_by ON resource_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'resource_retrieved_by'
        WHERE resource_uuid=OLD.uuid;
END;

-- fk debug delete trigger for resource for fk ref from unit_resource
CREATE TRIGGER trg_fk_debug_resource_uuid_unit_resource_resource_uuid
BEFORE DELETE ON 'resource' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM resource due to referencing rows in unit_resource ON resource_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_resource'
        WHERE resource_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_grant_scope_type for fk ref from secret_permission
CREATE TRIGGER trg_fk_debug_secret_grant_scope_type_id_secret_permission_scope_type_id
BEFORE DELETE ON 'secret_grant_scope_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_grant_scope_type due to referencing rows in secret_permission ON scope_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_permission'
        WHERE scope_type_id=OLD.id;
END;

-- fk debug delete trigger for secret_grant_subject_type for fk ref from secret_permission
CREATE TRIGGER trg_fk_debug_secret_grant_subject_type_id_secret_permission_subject_type_id
BEFORE DELETE ON 'secret_grant_subject_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_grant_subject_type due to referencing rows in secret_permission ON subject_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_permission'
        WHERE subject_type_id=OLD.id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_application_owner
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_application_owner_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_application_owner ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_application_owner'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_model_owner
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_model_owner_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_model_owner ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_model_owner'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_permission
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_permission_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_permission ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_permission'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_remote_unit_consumer
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_remote_unit_consumer_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_remote_unit_consumer ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_remote_unit_consumer'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_revision
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_revision_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_revision ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_revision'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_rotation
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_rotation_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_rotation ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_rotation'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_metadata for fk ref from secret_unit_owner
CREATE TRIGGER trg_fk_debug_secret_metadata_secret_id_secret_unit_owner_secret_id
BEFORE DELETE ON 'secret_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_metadata due to referencing rows in secret_unit_owner ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_unit_owner'
        WHERE secret_id=OLD.secret_id;
END;

-- fk debug delete trigger for secret_revision for fk ref from secret_content
CREATE TRIGGER trg_fk_debug_secret_revision_uuid_secret_content_revision_uuid
BEFORE DELETE ON 'secret_revision' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_revision due to referencing rows in secret_content ON revision_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_content'
        WHERE revision_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_revision for fk ref from secret_revision_expire
CREATE TRIGGER trg_fk_debug_secret_revision_uuid_secret_revision_expire_revision_uuid
BEFORE DELETE ON 'secret_revision' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_revision due to referencing rows in secret_revision_expire ON revision_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_revision_expire'
        WHERE revision_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_revision for fk ref from secret_revision_obsolete
CREATE TRIGGER trg_fk_debug_secret_revision_uuid_secret_revision_obsolete_revision_uuid
BEFORE DELETE ON 'secret_revision' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_revision due to referencing rows in secret_revision_obsolete ON revision_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_revision_obsolete'
        WHERE revision_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_revision for fk ref from secret_value_ref
CREATE TRIGGER trg_fk_debug_secret_revision_uuid_secret_value_ref_revision_uuid
BEFORE DELETE ON 'secret_revision' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_revision due to referencing rows in secret_value_ref ON revision_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_value_ref'
        WHERE revision_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_role for fk ref from secret_permission
CREATE TRIGGER trg_fk_debug_secret_role_id_secret_permission_role_id
BEFORE DELETE ON 'secret_role' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_role due to referencing rows in secret_permission ON role_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_permission'
        WHERE role_id=OLD.id;
END;

-- fk debug delete trigger for secret_rotate_policy for fk ref from secret_metadata
CREATE TRIGGER trg_fk_debug_secret_rotate_policy_id_secret_metadata_rotate_policy_id
BEFORE DELETE ON 'secret_rotate_policy' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_rotate_policy due to referencing rows in secret_metadata ON rotate_policy_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_metadata'
        WHERE rotate_policy_id=OLD.id;
END;

-- fk debug delete trigger for secret for fk ref from secret_metadata
CREATE TRIGGER trg_fk_debug_secret_id_secret_metadata_secret_id
BEFORE DELETE ON 'secret' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret due to referencing rows in secret_metadata ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_metadata'
        WHERE secret_id=OLD.id;
END;

-- fk debug delete trigger for secret for fk ref from secret_reference
CREATE TRIGGER trg_fk_debug_secret_id_secret_reference_secret_id
BEFORE DELETE ON 'secret' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret due to referencing rows in secret_reference ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_reference'
        WHERE secret_id=OLD.id;
END;

-- fk debug delete trigger for secret for fk ref from secret_unit_consumer
CREATE TRIGGER trg_fk_debug_secret_id_secret_unit_consumer_secret_id
BEFORE DELETE ON 'secret' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret due to referencing rows in secret_unit_consumer ON secret_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_unit_consumer'
        WHERE secret_id=OLD.id;
END;

-- fk debug delete trigger for space for fk ref from constraint_space
CREATE TRIGGER trg_fk_debug_space_name_constraint_space_space
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in constraint_space ON space')
                    ELSE
                        NULL
                    END panic
        FROM 'constraint_space'
        WHERE space=OLD.name;
END;

-- fk debug delete trigger for space for fk ref from application
CREATE TRIGGER trg_fk_debug_space_uuid_application_space_uuid
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in application ON space_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application'
        WHERE space_uuid=OLD.uuid;
END;

-- fk debug delete trigger for space for fk ref from application_endpoint
CREATE TRIGGER trg_fk_debug_space_uuid_application_endpoint_space_uuid
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in application_endpoint ON space_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_endpoint'
        WHERE space_uuid=OLD.uuid;
END;

-- fk debug delete trigger for space for fk ref from application_exposed_endpoint_space
CREATE TRIGGER trg_fk_debug_space_uuid_application_exposed_endpoint_space_space_uuid
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in application_exposed_endpoint_space ON space_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_exposed_endpoint_space'
        WHERE space_uuid=OLD.uuid;
END;

-- fk debug delete trigger for space for fk ref from application_extra_endpoint
CREATE TRIGGER trg_fk_debug_space_uuid_application_extra_endpoint_space_uuid
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in application_extra_endpoint ON space_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_extra_endpoint'
        WHERE space_uuid=OLD.uuid;
END;

-- fk debug delete trigger for space for fk ref from provider_space
CREATE TRIGGER trg_fk_debug_space_uuid_provider_space_space_uuid
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in provider_space ON space_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'provider_space'
        WHERE space_uuid=OLD.uuid;
END;

-- fk debug delete trigger for space for fk ref from subnet
CREATE TRIGGER trg_fk_debug_space_uuid_subnet_space_uuid
BEFORE DELETE ON 'space' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM space due to referencing rows in subnet ON space_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'subnet'
        WHERE space_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_filesystem_status_value for fk ref from storage_filesystem_status
CREATE TRIGGER trg_fk_debug_storage_filesystem_status_value_id_storage_filesystem_status_status_id
BEFORE DELETE ON 'storage_filesystem_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_filesystem_status_value due to referencing rows in storage_filesystem_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for storage_filesystem for fk ref from machine_filesystem
CREATE TRIGGER trg_fk_debug_storage_filesystem_uuid_machine_filesystem_filesystem_uuid
BEFORE DELETE ON 'storage_filesystem' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_filesystem due to referencing rows in machine_filesystem ON filesystem_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_filesystem'
        WHERE filesystem_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_filesystem for fk ref from storage_filesystem_attachment
CREATE TRIGGER trg_fk_debug_storage_filesystem_uuid_storage_filesystem_attachment_storage_filesystem_uuid
BEFORE DELETE ON 'storage_filesystem' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_filesystem due to referencing rows in storage_filesystem_attachment ON storage_filesystem_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem_attachment'
        WHERE storage_filesystem_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_filesystem for fk ref from storage_filesystem_status
CREATE TRIGGER trg_fk_debug_storage_filesystem_uuid_storage_filesystem_status_filesystem_uuid
BEFORE DELETE ON 'storage_filesystem' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_filesystem due to referencing rows in storage_filesystem_status ON filesystem_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem_status'
        WHERE filesystem_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_filesystem for fk ref from storage_instance_filesystem
CREATE TRIGGER trg_fk_debug_storage_filesystem_uuid_storage_instance_filesystem_storage_filesystem_uuid
BEFORE DELETE ON 'storage_filesystem' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_filesystem due to referencing rows in storage_instance_filesystem ON storage_filesystem_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance_filesystem'
        WHERE storage_filesystem_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_instance for fk ref from storage_attachment
CREATE TRIGGER trg_fk_debug_storage_instance_uuid_storage_attachment_storage_instance_uuid
BEFORE DELETE ON 'storage_instance' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_instance due to referencing rows in storage_attachment ON storage_instance_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_attachment'
        WHERE storage_instance_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_instance for fk ref from storage_instance_filesystem
CREATE TRIGGER trg_fk_debug_storage_instance_uuid_storage_instance_filesystem_storage_instance_uuid
BEFORE DELETE ON 'storage_instance' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_instance due to referencing rows in storage_instance_filesystem ON storage_instance_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance_filesystem'
        WHERE storage_instance_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_instance for fk ref from storage_instance_volume
CREATE TRIGGER trg_fk_debug_storage_instance_uuid_storage_instance_volume_storage_instance_uuid
BEFORE DELETE ON 'storage_instance' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_instance due to referencing rows in storage_instance_volume ON storage_instance_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance_volume'
        WHERE storage_instance_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_instance for fk ref from storage_unit_owner
CREATE TRIGGER trg_fk_debug_storage_instance_uuid_storage_unit_owner_storage_instance_uuid
BEFORE DELETE ON 'storage_instance' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_instance due to referencing rows in storage_unit_owner ON storage_instance_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_unit_owner'
        WHERE storage_instance_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_kind for fk ref from storage_instance
CREATE TRIGGER trg_fk_debug_storage_kind_id_storage_instance_storage_kind_id
BEFORE DELETE ON 'storage_kind' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_kind due to referencing rows in storage_instance ON storage_kind_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance'
        WHERE storage_kind_id=OLD.id;
END;

-- fk debug delete trigger for storage_pool_origin for fk ref from storage_pool
CREATE TRIGGER trg_fk_debug_storage_pool_origin_id_storage_pool_origin_id
BEFORE DELETE ON 'storage_pool_origin' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_pool_origin due to referencing rows in storage_pool ON origin_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_pool'
        WHERE origin_id=OLD.id;
END;

-- fk debug delete trigger for storage_pool for fk ref from application_storage_directive
CREATE TRIGGER trg_fk_debug_storage_pool_uuid_application_storage_directive_storage_pool_uuid
BEFORE DELETE ON 'storage_pool' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_pool due to referencing rows in application_storage_directive ON storage_pool_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'application_storage_directive'
        WHERE storage_pool_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_pool for fk ref from storage_instance
CREATE TRIGGER trg_fk_debug_storage_pool_uuid_storage_instance_storage_pool_uuid
BEFORE DELETE ON 'storage_pool' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_pool due to referencing rows in storage_instance ON storage_pool_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance'
        WHERE storage_pool_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_pool for fk ref from storage_pool_attribute
CREATE TRIGGER trg_fk_debug_storage_pool_uuid_storage_pool_attribute_storage_pool_uuid
BEFORE DELETE ON 'storage_pool' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_pool due to referencing rows in storage_pool_attribute ON storage_pool_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_pool_attribute'
        WHERE storage_pool_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_pool for fk ref from unit_storage_directive
CREATE TRIGGER trg_fk_debug_storage_pool_uuid_unit_storage_directive_storage_pool_uuid
BEFORE DELETE ON 'storage_pool' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_pool due to referencing rows in unit_storage_directive ON storage_pool_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_storage_directive'
        WHERE storage_pool_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_provision_scope for fk ref from storage_filesystem
CREATE TRIGGER trg_fk_debug_storage_provision_scope_id_storage_filesystem_provision_scope_id
BEFORE DELETE ON 'storage_provision_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_provision_scope due to referencing rows in storage_filesystem ON provision_scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem'
        WHERE provision_scope_id=OLD.id;
END;

-- fk debug delete trigger for storage_provision_scope for fk ref from storage_filesystem_attachment
CREATE TRIGGER trg_fk_debug_storage_provision_scope_id_storage_filesystem_attachment_provision_scope_id
BEFORE DELETE ON 'storage_provision_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_provision_scope due to referencing rows in storage_filesystem_attachment ON provision_scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_filesystem_attachment'
        WHERE provision_scope_id=OLD.id;
END;

-- fk debug delete trigger for storage_provision_scope for fk ref from storage_volume
CREATE TRIGGER trg_fk_debug_storage_provision_scope_id_storage_volume_provision_scope_id
BEFORE DELETE ON 'storage_provision_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_provision_scope due to referencing rows in storage_volume ON provision_scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume'
        WHERE provision_scope_id=OLD.id;
END;

-- fk debug delete trigger for storage_provision_scope for fk ref from storage_volume_attachment
CREATE TRIGGER trg_fk_debug_storage_provision_scope_id_storage_volume_attachment_provision_scope_id
BEFORE DELETE ON 'storage_provision_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_provision_scope due to referencing rows in storage_volume_attachment ON provision_scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment'
        WHERE provision_scope_id=OLD.id;
END;

-- fk debug delete trigger for storage_provision_scope for fk ref from storage_volume_attachment_plan
CREATE TRIGGER trg_fk_debug_storage_provision_scope_id_storage_volume_attachment_plan_provision_scope_id
BEFORE DELETE ON 'storage_provision_scope' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_provision_scope due to referencing rows in storage_volume_attachment_plan ON provision_scope_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment_plan'
        WHERE provision_scope_id=OLD.id;
END;

-- fk debug delete trigger for storage_volume_attachment_plan for fk ref from storage_volume_attachment_plan_attr
CREATE TRIGGER trg_fk_debug_storage_volume_attachment_plan_uuid_storage_volume_attachment_plan_attr_attachment_plan_uuid
BEFORE DELETE ON 'storage_volume_attachment_plan' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume_attachment_plan due to referencing rows in storage_volume_attachment_plan_attr ON attachment_plan_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment_plan_attr'
        WHERE attachment_plan_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_volume_device_type for fk ref from storage_volume_attachment_plan
CREATE TRIGGER trg_fk_debug_storage_volume_device_type_id_storage_volume_attachment_plan_device_type_id
BEFORE DELETE ON 'storage_volume_device_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume_device_type due to referencing rows in storage_volume_attachment_plan ON device_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment_plan'
        WHERE device_type_id=OLD.id;
END;

-- fk debug delete trigger for storage_volume_status_value for fk ref from storage_volume_status
CREATE TRIGGER trg_fk_debug_storage_volume_status_value_id_storage_volume_status_status_id
BEFORE DELETE ON 'storage_volume_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume_status_value due to referencing rows in storage_volume_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for storage_volume for fk ref from machine_volume
CREATE TRIGGER trg_fk_debug_storage_volume_uuid_machine_volume_volume_uuid
BEFORE DELETE ON 'storage_volume' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume due to referencing rows in machine_volume ON volume_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'machine_volume'
        WHERE volume_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_volume for fk ref from storage_instance_volume
CREATE TRIGGER trg_fk_debug_storage_volume_uuid_storage_instance_volume_storage_volume_uuid
BEFORE DELETE ON 'storage_volume' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume due to referencing rows in storage_instance_volume ON storage_volume_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_instance_volume'
        WHERE storage_volume_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_volume for fk ref from storage_volume_attachment
CREATE TRIGGER trg_fk_debug_storage_volume_uuid_storage_volume_attachment_storage_volume_uuid
BEFORE DELETE ON 'storage_volume' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume due to referencing rows in storage_volume_attachment ON storage_volume_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment'
        WHERE storage_volume_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_volume for fk ref from storage_volume_attachment_plan
CREATE TRIGGER trg_fk_debug_storage_volume_uuid_storage_volume_attachment_plan_storage_volume_uuid
BEFORE DELETE ON 'storage_volume' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume due to referencing rows in storage_volume_attachment_plan ON storage_volume_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_attachment_plan'
        WHERE storage_volume_uuid=OLD.uuid;
END;

-- fk debug delete trigger for storage_volume for fk ref from storage_volume_status
CREATE TRIGGER trg_fk_debug_storage_volume_uuid_storage_volume_status_volume_uuid
BEFORE DELETE ON 'storage_volume' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM storage_volume due to referencing rows in storage_volume_status ON volume_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_volume_status'
        WHERE volume_uuid=OLD.uuid;
END;

-- fk debug delete trigger for subnet for fk ref from availability_zone_subnet
CREATE TRIGGER trg_fk_debug_subnet_uuid_availability_zone_subnet_subnet_uuid
BEFORE DELETE ON 'subnet' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM subnet due to referencing rows in availability_zone_subnet ON subnet_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'availability_zone_subnet'
        WHERE subnet_uuid=OLD.uuid;
END;

-- fk debug delete trigger for subnet for fk ref from ip_address
CREATE TRIGGER trg_fk_debug_subnet_uuid_ip_address_subnet_uuid
BEFORE DELETE ON 'subnet' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM subnet due to referencing rows in ip_address ON subnet_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'ip_address'
        WHERE subnet_uuid=OLD.uuid;
END;

-- fk debug delete trigger for subnet for fk ref from provider_network_subnet
CREATE TRIGGER trg_fk_debug_subnet_uuid_provider_network_subnet_subnet_uuid
BEFORE DELETE ON 'subnet' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM subnet due to referencing rows in provider_network_subnet ON subnet_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'provider_network_subnet'
        WHERE subnet_uuid=OLD.uuid;
END;

-- fk debug delete trigger for subnet for fk ref from provider_subnet
CREATE TRIGGER trg_fk_debug_subnet_uuid_provider_subnet_subnet_uuid
BEFORE DELETE ON 'subnet' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM subnet due to referencing rows in provider_subnet ON subnet_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'provider_subnet'
        WHERE subnet_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit_agent_status_value for fk ref from unit_agent_status
CREATE TRIGGER trg_fk_debug_unit_agent_status_value_id_unit_agent_status_status_id
BEFORE DELETE ON 'unit_agent_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit_agent_status_value due to referencing rows in unit_agent_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_agent_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for unit for fk ref from annotation_unit
CREATE TRIGGER trg_fk_debug_unit_uuid_annotation_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in annotation_unit ON uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'annotation_unit'
        WHERE uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from k8s_pod
CREATE TRIGGER trg_fk_debug_unit_uuid_k8s_pod_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in k8s_pod ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'k8s_pod'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from k8s_pod_status
CREATE TRIGGER trg_fk_debug_unit_uuid_k8s_pod_status_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in k8s_pod_status ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'k8s_pod_status'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from operation_unit_task
CREATE TRIGGER trg_fk_debug_unit_uuid_operation_unit_task_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in operation_unit_task ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'operation_unit_task'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from port_range
CREATE TRIGGER trg_fk_debug_unit_uuid_port_range_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in port_range ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'port_range'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from relation_unit
CREATE TRIGGER trg_fk_debug_unit_uuid_relation_unit_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in relation_unit ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'relation_unit'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from secret_unit_consumer
CREATE TRIGGER trg_fk_debug_unit_uuid_secret_unit_consumer_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in secret_unit_consumer ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_unit_consumer'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from secret_unit_owner
CREATE TRIGGER trg_fk_debug_unit_uuid_secret_unit_owner_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in secret_unit_owner ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_unit_owner'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from storage_attachment
CREATE TRIGGER trg_fk_debug_unit_uuid_storage_attachment_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in storage_attachment ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_attachment'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from storage_unit_owner
CREATE TRIGGER trg_fk_debug_unit_uuid_storage_unit_owner_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in storage_unit_owner ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'storage_unit_owner'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_agent_presence
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_agent_presence_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_agent_presence ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_agent_presence'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_agent_status
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_agent_status_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_agent_status ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_agent_status'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_agent_version
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_agent_version_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_agent_version ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_agent_version'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_principal
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_principal_principal_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_principal ON principal_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_principal'
        WHERE principal_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_principal
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_principal_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_principal ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_principal'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_resolved
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_resolved_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_resolved ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_resolved'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_resource
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_resource_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_resource ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_resource'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_state
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_state_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_state ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_state'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_state_charm
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_state_charm_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_state_charm ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_state_charm'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_state_relation
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_state_relation_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_state_relation ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_state_relation'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_storage_directive
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_storage_directive_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_storage_directive ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_storage_directive'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_workload_status
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_workload_status_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_workload_status ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_workload_status'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for unit for fk ref from unit_workload_version
CREATE TRIGGER trg_fk_debug_unit_uuid_unit_workload_version_unit_uuid
BEFORE DELETE ON 'unit' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM unit due to referencing rows in unit_workload_version ON unit_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_workload_version'
        WHERE unit_uuid=OLD.uuid;
END;

-- fk debug delete trigger for virtual_port_type for fk ref from link_layer_device
CREATE TRIGGER trg_fk_debug_virtual_port_type_id_link_layer_device_virtual_port_type_id
BEFORE DELETE ON 'virtual_port_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM virtual_port_type due to referencing rows in link_layer_device ON virtual_port_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'link_layer_device'
        WHERE virtual_port_type_id=OLD.id;
END;

-- fk debug delete trigger for workload_status_value for fk ref from application_remote_offerer_status
CREATE TRIGGER trg_fk_debug_workload_status_value_id_application_remote_offerer_status_status_id
BEFORE DELETE ON 'workload_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM workload_status_value due to referencing rows in application_remote_offerer_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_remote_offerer_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for workload_status_value for fk ref from application_status
CREATE TRIGGER trg_fk_debug_workload_status_value_id_application_status_status_id
BEFORE DELETE ON 'workload_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM workload_status_value due to referencing rows in application_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'application_status'
        WHERE status_id=OLD.id;
END;

-- fk debug delete trigger for workload_status_value for fk ref from unit_workload_status
CREATE TRIGGER trg_fk_debug_workload_status_value_id_unit_workload_status_status_id
BEFORE DELETE ON 'workload_status_value' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM workload_status_value due to referencing rows in unit_workload_status ON status_id')
                    ELSE
                        NULL
                    END panic
        FROM 'unit_workload_status'
        WHERE status_id=OLD.id;
END;

`)
	}
}


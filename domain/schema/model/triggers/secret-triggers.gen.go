// Code generated by triggergen. DO NOT EDIT.

package triggers

import (
	"fmt"
	"strings"

	"github.com/juju/juju/core/database/schema"
)


// ChangeLogTriggersForSecretMetadata generates the triggers for the
// secret_metadata table.
func ChangeLogTriggersForSecretMetadata(namespaceID int, changeColumnName string) func() schema.Patch {
	return ChangeLogTriggersForSecretMetadataWithDiscriminator(namespaceID, changeColumnName, "")
}

// ChangeLogTriggersForSecretMetadataWithDiscriminator generates the triggers for the
// secret_metadata table, with the value of the optional discriminator column included in the
// change event. The discriminator column name is ignored if empty.
func ChangeLogTriggersForSecretMetadataWithDiscriminator(namespaceID int, changeColumnName, discriminatorColumnName string) func() schema.Patch {
	changeLogColumns := []string{"changed"}
	newColumnValues := "NEW." + changeColumnName
	oldColumnValues := "OLD." + changeColumnName
	if discriminatorColumnName != "" {
		changeLogColumns = append(changeLogColumns, "discriminator")
		newColumnValues += ", NEW." + discriminatorColumnName
		oldColumnValues += ", OLD." + discriminatorColumnName
	}
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- insert trigger for SecretMetadata
CREATE TRIGGER trg_log_secret_metadata_insert
AFTER INSERT ON secret_metadata FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (1, %[1]d, %[2]s, DATETIME('now'));
END;

-- update trigger for SecretMetadata
CREATE TRIGGER trg_log_secret_metadata_update
AFTER UPDATE ON secret_metadata FOR EACH ROW
WHEN 
	NEW.version != OLD.version OR
	(NEW.description != OLD.description OR (NEW.description IS NOT NULL AND OLD.description IS NULL) OR (NEW.description IS NULL AND OLD.description IS NOT NULL)) OR
	NEW.rotate_policy_id != OLD.rotate_policy_id OR
	NEW.auto_prune != OLD.auto_prune OR
	NEW.create_time != OLD.create_time OR
	NEW.update_time != OLD.update_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (2, %[1]d, %[3]s, DATETIME('now'));
END;

-- delete trigger for SecretMetadata
CREATE TRIGGER trg_log_secret_metadata_delete
AFTER DELETE ON secret_metadata FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (4, %[1]d, %[3]s, DATETIME('now'));
END;`, namespaceID, newColumnValues, oldColumnValues, strings.Join(changeLogColumns, ", ")))
	}
}

// ChangeLogTriggersForSecretReference generates the triggers for the
// secret_reference table.
func ChangeLogTriggersForSecretReference(namespaceID int, changeColumnName string) func() schema.Patch {
	return ChangeLogTriggersForSecretReferenceWithDiscriminator(namespaceID, changeColumnName, "")
}

// ChangeLogTriggersForSecretReferenceWithDiscriminator generates the triggers for the
// secret_reference table, with the value of the optional discriminator column included in the
// change event. The discriminator column name is ignored if empty.
func ChangeLogTriggersForSecretReferenceWithDiscriminator(namespaceID int, changeColumnName, discriminatorColumnName string) func() schema.Patch {
	changeLogColumns := []string{"changed"}
	newColumnValues := "NEW." + changeColumnName
	oldColumnValues := "OLD." + changeColumnName
	if discriminatorColumnName != "" {
		changeLogColumns = append(changeLogColumns, "discriminator")
		newColumnValues += ", NEW." + discriminatorColumnName
		oldColumnValues += ", OLD." + discriminatorColumnName
	}
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- insert trigger for SecretReference
CREATE TRIGGER trg_log_secret_reference_insert
AFTER INSERT ON secret_reference FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (1, %[1]d, %[2]s, DATETIME('now'));
END;

-- update trigger for SecretReference
CREATE TRIGGER trg_log_secret_reference_update
AFTER UPDATE ON secret_reference FOR EACH ROW
WHEN 
	NEW.latest_revision != OLD.latest_revision 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (2, %[1]d, %[3]s, DATETIME('now'));
END;

-- delete trigger for SecretReference
CREATE TRIGGER trg_log_secret_reference_delete
AFTER DELETE ON secret_reference FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (4, %[1]d, %[3]s, DATETIME('now'));
END;`, namespaceID, newColumnValues, oldColumnValues, strings.Join(changeLogColumns, ", ")))
	}
}

// ChangeLogTriggersForSecretRevision generates the triggers for the
// secret_revision table.
func ChangeLogTriggersForSecretRevision(namespaceID int, changeColumnName string) func() schema.Patch {
	return ChangeLogTriggersForSecretRevisionWithDiscriminator(namespaceID, changeColumnName, "")
}

// ChangeLogTriggersForSecretRevisionWithDiscriminator generates the triggers for the
// secret_revision table, with the value of the optional discriminator column included in the
// change event. The discriminator column name is ignored if empty.
func ChangeLogTriggersForSecretRevisionWithDiscriminator(namespaceID int, changeColumnName, discriminatorColumnName string) func() schema.Patch {
	changeLogColumns := []string{"changed"}
	newColumnValues := "NEW." + changeColumnName
	oldColumnValues := "OLD." + changeColumnName
	if discriminatorColumnName != "" {
		changeLogColumns = append(changeLogColumns, "discriminator")
		newColumnValues += ", NEW." + discriminatorColumnName
		oldColumnValues += ", OLD." + discriminatorColumnName
	}
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- insert trigger for SecretRevision
CREATE TRIGGER trg_log_secret_revision_insert
AFTER INSERT ON secret_revision FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (1, %[1]d, %[2]s, DATETIME('now'));
END;

-- update trigger for SecretRevision
CREATE TRIGGER trg_log_secret_revision_update
AFTER UPDATE ON secret_revision FOR EACH ROW
WHEN 
	NEW.secret_id != OLD.secret_id OR
	NEW.revision != OLD.revision OR
	NEW.create_time != OLD.create_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (2, %[1]d, %[3]s, DATETIME('now'));
END;

-- delete trigger for SecretRevision
CREATE TRIGGER trg_log_secret_revision_delete
AFTER DELETE ON secret_revision FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (4, %[1]d, %[3]s, DATETIME('now'));
END;`, namespaceID, newColumnValues, oldColumnValues, strings.Join(changeLogColumns, ", ")))
	}
}

// ChangeLogTriggersForSecretRevisionExpire generates the triggers for the
// secret_revision_expire table.
func ChangeLogTriggersForSecretRevisionExpire(namespaceID int, changeColumnName string) func() schema.Patch {
	return ChangeLogTriggersForSecretRevisionExpireWithDiscriminator(namespaceID, changeColumnName, "")
}

// ChangeLogTriggersForSecretRevisionExpireWithDiscriminator generates the triggers for the
// secret_revision_expire table, with the value of the optional discriminator column included in the
// change event. The discriminator column name is ignored if empty.
func ChangeLogTriggersForSecretRevisionExpireWithDiscriminator(namespaceID int, changeColumnName, discriminatorColumnName string) func() schema.Patch {
	changeLogColumns := []string{"changed"}
	newColumnValues := "NEW." + changeColumnName
	oldColumnValues := "OLD." + changeColumnName
	if discriminatorColumnName != "" {
		changeLogColumns = append(changeLogColumns, "discriminator")
		newColumnValues += ", NEW." + discriminatorColumnName
		oldColumnValues += ", OLD." + discriminatorColumnName
	}
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- insert trigger for SecretRevisionExpire
CREATE TRIGGER trg_log_secret_revision_expire_insert
AFTER INSERT ON secret_revision_expire FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (1, %[1]d, %[2]s, DATETIME('now'));
END;

-- update trigger for SecretRevisionExpire
CREATE TRIGGER trg_log_secret_revision_expire_update
AFTER UPDATE ON secret_revision_expire FOR EACH ROW
WHEN 
	NEW.expire_time != OLD.expire_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (2, %[1]d, %[3]s, DATETIME('now'));
END;

-- delete trigger for SecretRevisionExpire
CREATE TRIGGER trg_log_secret_revision_expire_delete
AFTER DELETE ON secret_revision_expire FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (4, %[1]d, %[3]s, DATETIME('now'));
END;`, namespaceID, newColumnValues, oldColumnValues, strings.Join(changeLogColumns, ", ")))
	}
}

// ChangeLogTriggersForSecretRevisionObsolete generates the triggers for the
// secret_revision_obsolete table.
func ChangeLogTriggersForSecretRevisionObsolete(namespaceID int, changeColumnName string) func() schema.Patch {
	return ChangeLogTriggersForSecretRevisionObsoleteWithDiscriminator(namespaceID, changeColumnName, "")
}

// ChangeLogTriggersForSecretRevisionObsoleteWithDiscriminator generates the triggers for the
// secret_revision_obsolete table, with the value of the optional discriminator column included in the
// change event. The discriminator column name is ignored if empty.
func ChangeLogTriggersForSecretRevisionObsoleteWithDiscriminator(namespaceID int, changeColumnName, discriminatorColumnName string) func() schema.Patch {
	changeLogColumns := []string{"changed"}
	newColumnValues := "NEW." + changeColumnName
	oldColumnValues := "OLD." + changeColumnName
	if discriminatorColumnName != "" {
		changeLogColumns = append(changeLogColumns, "discriminator")
		newColumnValues += ", NEW." + discriminatorColumnName
		oldColumnValues += ", OLD." + discriminatorColumnName
	}
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- insert trigger for SecretRevisionObsolete
CREATE TRIGGER trg_log_secret_revision_obsolete_insert
AFTER INSERT ON secret_revision_obsolete FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (1, %[1]d, %[2]s, DATETIME('now'));
END;

-- update trigger for SecretRevisionObsolete
CREATE TRIGGER trg_log_secret_revision_obsolete_update
AFTER UPDATE ON secret_revision_obsolete FOR EACH ROW
WHEN 
	NEW.obsolete != OLD.obsolete OR
	NEW.pending_delete != OLD.pending_delete 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (2, %[1]d, %[3]s, DATETIME('now'));
END;

-- delete trigger for SecretRevisionObsolete
CREATE TRIGGER trg_log_secret_revision_obsolete_delete
AFTER DELETE ON secret_revision_obsolete FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (4, %[1]d, %[3]s, DATETIME('now'));
END;`, namespaceID, newColumnValues, oldColumnValues, strings.Join(changeLogColumns, ", ")))
	}
}

// ChangeLogTriggersForSecretRotation generates the triggers for the
// secret_rotation table.
func ChangeLogTriggersForSecretRotation(namespaceID int, changeColumnName string) func() schema.Patch {
	return ChangeLogTriggersForSecretRotationWithDiscriminator(namespaceID, changeColumnName, "")
}

// ChangeLogTriggersForSecretRotationWithDiscriminator generates the triggers for the
// secret_rotation table, with the value of the optional discriminator column included in the
// change event. The discriminator column name is ignored if empty.
func ChangeLogTriggersForSecretRotationWithDiscriminator(namespaceID int, changeColumnName, discriminatorColumnName string) func() schema.Patch {
	changeLogColumns := []string{"changed"}
	newColumnValues := "NEW." + changeColumnName
	oldColumnValues := "OLD." + changeColumnName
	if discriminatorColumnName != "" {
		changeLogColumns = append(changeLogColumns, "discriminator")
		newColumnValues += ", NEW." + discriminatorColumnName
		oldColumnValues += ", OLD." + discriminatorColumnName
	}
	return func() schema.Patch {
		return schema.MakePatch(fmt.Sprintf(`
-- insert trigger for SecretRotation
CREATE TRIGGER trg_log_secret_rotation_insert
AFTER INSERT ON secret_rotation FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (1, %[1]d, %[2]s, DATETIME('now'));
END;

-- update trigger for SecretRotation
CREATE TRIGGER trg_log_secret_rotation_update
AFTER UPDATE ON secret_rotation FOR EACH ROW
WHEN 
	NEW.next_rotation_time != OLD.next_rotation_time 
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (2, %[1]d, %[3]s, DATETIME('now'));
END;

-- delete trigger for SecretRotation
CREATE TRIGGER trg_log_secret_rotation_delete
AFTER DELETE ON secret_rotation FOR EACH ROW
BEGIN
    INSERT INTO change_log (edit_type_id, namespace_id, %[4]s, created_at)
    VALUES (4, %[1]d, %[3]s, DATETIME('now'));
END;`, namespaceID, newColumnValues, oldColumnValues, strings.Join(changeLogColumns, ", ")))
	}
}


// Code generated by fktriggergen. DO NOT EDIT.

package triggers

import (
	"github.com/juju/juju/core/database/schema"
)

// FKDebugTriggers generates triggers from all tables to debug FK violations.
func FKDebugTriggers() func() schema.Patch {
	return func() schema.Patch {
		return schema.MakePatch(`

-- fk debug delete trigger for architecture for fk ref from agent_binary_store
CREATE TRIGGER trg_fk_debug_agent_binary_store_0
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in agent_binary_store ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'agent_binary_store'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for object_store_metadata for fk ref from agent_binary_store
CREATE TRIGGER trg_fk_debug_agent_binary_store_1
BEFORE DELETE ON 'object_store_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata due to referencing rows in agent_binary_store ON object_store_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'agent_binary_store'
        WHERE object_store_uuid=OLD.uuid;
END;

-- fk debug delete trigger for autocert_cache_encoding for fk ref from autocert_cache
CREATE TRIGGER trg_fk_debug_autocert_cache_0
BEFORE DELETE ON 'autocert_cache_encoding' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM autocert_cache_encoding due to referencing rows in autocert_cache ON encoding')
                    ELSE
                        NULL
                    END panic
        FROM 'autocert_cache'
        WHERE encoding=OLD.id;
END;

-- fk debug delete trigger for change_log_namespace for fk ref from change_log
CREATE TRIGGER trg_fk_debug_change_log_0
BEFORE DELETE ON 'change_log_namespace' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM change_log_namespace due to referencing rows in change_log ON namespace_id')
                    ELSE
                        NULL
                    END panic
        FROM 'change_log'
        WHERE namespace_id=OLD.id;
END;

-- fk debug delete trigger for change_log_edit_type for fk ref from change_log
CREATE TRIGGER trg_fk_debug_change_log_1
BEFORE DELETE ON 'change_log_edit_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM change_log_edit_type due to referencing rows in change_log ON edit_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'change_log'
        WHERE edit_type_id=OLD.id;
END;

-- fk debug delete trigger for cloud_type for fk ref from cloud
CREATE TRIGGER trg_fk_debug_cloud_0
BEFORE DELETE ON 'cloud_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud_type due to referencing rows in cloud ON cloud_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud'
        WHERE cloud_type_id=OLD.id;
END;

-- fk debug delete trigger for auth_type for fk ref from cloud_auth_type
CREATE TRIGGER trg_fk_debug_cloud_auth_type_0
BEFORE DELETE ON 'auth_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM auth_type due to referencing rows in cloud_auth_type ON auth_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_auth_type'
        WHERE auth_type_id=OLD.id;
END;

-- fk debug delete trigger for cloud for fk ref from cloud_auth_type
CREATE TRIGGER trg_fk_debug_cloud_auth_type_1
BEFORE DELETE ON 'cloud' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud due to referencing rows in cloud_auth_type ON cloud_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_auth_type'
        WHERE cloud_uuid=OLD.uuid;
END;

-- fk debug delete trigger for cloud for fk ref from cloud_ca_cert
CREATE TRIGGER trg_fk_debug_cloud_ca_cert_0
BEFORE DELETE ON 'cloud' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud due to referencing rows in cloud_ca_cert ON cloud_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_ca_cert'
        WHERE cloud_uuid=OLD.uuid;
END;

-- fk debug delete trigger for user for fk ref from cloud_credential
CREATE TRIGGER trg_fk_debug_cloud_credential_0
BEFORE DELETE ON 'user' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user due to referencing rows in cloud_credential ON owner_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_credential'
        WHERE owner_uuid=OLD.uuid;
END;

-- fk debug delete trigger for auth_type for fk ref from cloud_credential
CREATE TRIGGER trg_fk_debug_cloud_credential_1
BEFORE DELETE ON 'auth_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM auth_type due to referencing rows in cloud_credential ON auth_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_credential'
        WHERE auth_type_id=OLD.id;
END;

-- fk debug delete trigger for cloud for fk ref from cloud_credential
CREATE TRIGGER trg_fk_debug_cloud_credential_2
BEFORE DELETE ON 'cloud' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud due to referencing rows in cloud_credential ON cloud_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_credential'
        WHERE cloud_uuid=OLD.uuid;
END;

-- fk debug delete trigger for cloud_credential for fk ref from cloud_credential_attribute
CREATE TRIGGER trg_fk_debug_cloud_credential_attribute_0
BEFORE DELETE ON 'cloud_credential' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud_credential due to referencing rows in cloud_credential_attribute ON cloud_credential_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_credential_attribute'
        WHERE cloud_credential_uuid=OLD.uuid;
END;

-- fk debug delete trigger for cloud for fk ref from cloud_defaults
CREATE TRIGGER trg_fk_debug_cloud_defaults_0
BEFORE DELETE ON 'cloud' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud due to referencing rows in cloud_defaults ON cloud_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_defaults'
        WHERE cloud_uuid=OLD.uuid;
END;

-- fk debug delete trigger for architecture for fk ref from cloud_image_metadata
CREATE TRIGGER trg_fk_debug_cloud_image_metadata_0
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in cloud_image_metadata ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_image_metadata'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for cloud for fk ref from cloud_region
CREATE TRIGGER trg_fk_debug_cloud_region_0
BEFORE DELETE ON 'cloud' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud due to referencing rows in cloud_region ON cloud_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_region'
        WHERE cloud_uuid=OLD.uuid;
END;

-- fk debug delete trigger for cloud_region for fk ref from cloud_region_defaults
CREATE TRIGGER trg_fk_debug_cloud_region_defaults_0
BEFORE DELETE ON 'cloud_region' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud_region due to referencing rows in cloud_region_defaults ON region_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'cloud_region_defaults'
        WHERE region_uuid=OLD.uuid;
END;

-- fk debug delete trigger for controller_node for fk ref from controller_api_address
CREATE TRIGGER trg_fk_debug_controller_api_address_0
BEFORE DELETE ON 'controller_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM controller_node due to referencing rows in controller_api_address ON controller_id')
                    ELSE
                        NULL
                    END panic
        FROM 'controller_api_address'
        WHERE controller_id=OLD.controller_id;
END;

-- fk debug delete trigger for architecture for fk ref from controller_node_agent_version
CREATE TRIGGER trg_fk_debug_controller_node_agent_version_0
BEFORE DELETE ON 'architecture' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM architecture due to referencing rows in controller_node_agent_version ON architecture_id')
                    ELSE
                        NULL
                    END panic
        FROM 'controller_node_agent_version'
        WHERE architecture_id=OLD.id;
END;

-- fk debug delete trigger for controller_node for fk ref from controller_node_agent_version
CREATE TRIGGER trg_fk_debug_controller_node_agent_version_1
BEFORE DELETE ON 'controller_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM controller_node due to referencing rows in controller_node_agent_version ON controller_id')
                    ELSE
                        NULL
                    END panic
        FROM 'controller_node_agent_version'
        WHERE controller_id=OLD.controller_id;
END;

-- fk debug delete trigger for password_hash_algorithm for fk ref from controller_node_password
CREATE TRIGGER trg_fk_debug_controller_node_password_0
BEFORE DELETE ON 'password_hash_algorithm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM password_hash_algorithm due to referencing rows in controller_node_password ON password_hash_algorithm_id')
                    ELSE
                        NULL
                    END panic
        FROM 'controller_node_password'
        WHERE password_hash_algorithm_id=OLD.id;
END;

-- fk debug delete trigger for controller_node for fk ref from controller_node_password
CREATE TRIGGER trg_fk_debug_controller_node_password_1
BEFORE DELETE ON 'controller_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM controller_node due to referencing rows in controller_node_password ON controller_id')
                    ELSE
                        NULL
                    END panic
        FROM 'controller_node_password'
        WHERE controller_id=OLD.controller_id;
END;

-- fk debug delete trigger for external_controller for fk ref from external_controller_address
CREATE TRIGGER trg_fk_debug_external_controller_address_0
BEFORE DELETE ON 'external_controller' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM external_controller due to referencing rows in external_controller_address ON controller_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'external_controller_address'
        WHERE controller_uuid=OLD.uuid;
END;

-- fk debug delete trigger for external_controller for fk ref from external_model
CREATE TRIGGER trg_fk_debug_external_model_0
BEFORE DELETE ON 'external_controller' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM external_controller due to referencing rows in external_model ON controller_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'external_model'
        WHERE controller_uuid=OLD.uuid;
END;

-- fk debug delete trigger for lease_type for fk ref from lease
CREATE TRIGGER trg_fk_debug_lease_0
BEFORE DELETE ON 'lease_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM lease_type due to referencing rows in lease ON lease_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'lease'
        WHERE lease_type_id=OLD.id;
END;

-- fk debug delete trigger for lease for fk ref from lease_pin
CREATE TRIGGER trg_fk_debug_lease_pin_0
BEFORE DELETE ON 'lease' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM lease due to referencing rows in lease_pin ON lease_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'lease_pin'
        WHERE lease_uuid=OLD.uuid;
END;

-- fk debug delete trigger for life for fk ref from model
CREATE TRIGGER trg_fk_debug_model_0
BEFORE DELETE ON 'life' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM life due to referencing rows in model ON life_id')
                    ELSE
                        NULL
                    END panic
        FROM 'model'
        WHERE life_id=OLD.id;
END;

-- fk debug delete trigger for model_type for fk ref from model
CREATE TRIGGER trg_fk_debug_model_1
BEFORE DELETE ON 'model_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model_type due to referencing rows in model ON model_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'model'
        WHERE model_type_id=OLD.id;
END;

-- fk debug delete trigger for cloud_credential for fk ref from model
CREATE TRIGGER trg_fk_debug_model_2
BEFORE DELETE ON 'cloud_credential' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud_credential due to referencing rows in model ON cloud_credential_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model'
        WHERE cloud_credential_uuid=OLD.uuid;
END;

-- fk debug delete trigger for cloud_region for fk ref from model
CREATE TRIGGER trg_fk_debug_model_3
BEFORE DELETE ON 'cloud_region' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud_region due to referencing rows in model ON cloud_region_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model'
        WHERE cloud_region_uuid=OLD.uuid;
END;

-- fk debug delete trigger for cloud for fk ref from model
CREATE TRIGGER trg_fk_debug_model_4
BEFORE DELETE ON 'cloud' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM cloud due to referencing rows in model ON cloud_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model'
        WHERE cloud_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_authorized_keys
CREATE TRIGGER trg_fk_debug_model_authorized_keys_0
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_authorized_keys ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_authorized_keys'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for user_public_ssh_key for fk ref from model_authorized_keys
CREATE TRIGGER trg_fk_debug_model_authorized_keys_1
BEFORE DELETE ON 'user_public_ssh_key' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user_public_ssh_key due to referencing rows in model_authorized_keys ON user_public_ssh_key_id')
                    ELSE
                        NULL
                    END panic
        FROM 'model_authorized_keys'
        WHERE user_public_ssh_key_id=OLD.id;
END;

-- fk debug delete trigger for user for fk ref from model_last_login
CREATE TRIGGER trg_fk_debug_model_last_login_0
BEFORE DELETE ON 'user' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user due to referencing rows in model_last_login ON user_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_last_login'
        WHERE user_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_last_login
CREATE TRIGGER trg_fk_debug_model_last_login_1
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_last_login ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_last_login'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for external_controller for fk ref from model_migration
CREATE TRIGGER trg_fk_debug_model_migration_0
BEFORE DELETE ON 'external_controller' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM external_controller due to referencing rows in model_migration ON target_controller_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_migration'
        WHERE target_controller_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model_migration for fk ref from model_migration_minion_sync
CREATE TRIGGER trg_fk_debug_model_migration_minion_sync_0
BEFORE DELETE ON 'model_migration' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model_migration due to referencing rows in model_migration_minion_sync ON migration_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_migration_minion_sync'
        WHERE migration_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model_migration for fk ref from model_migration_user
CREATE TRIGGER trg_fk_debug_model_migration_user_0
BEFORE DELETE ON 'model_migration' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model_migration due to referencing rows in model_migration_user ON migration_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_migration_user'
        WHERE migration_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_namespace
CREATE TRIGGER trg_fk_debug_model_namespace_0
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_namespace ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_namespace'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_backend for fk ref from model_secret_backend
CREATE TRIGGER trg_fk_debug_model_secret_backend_0
BEFORE DELETE ON 'secret_backend' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_backend due to referencing rows in model_secret_backend ON secret_backend_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_secret_backend'
        WHERE secret_backend_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from model_secret_backend
CREATE TRIGGER trg_fk_debug_model_secret_backend_1
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in model_secret_backend ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'model_secret_backend'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for object_store_drain_phase_type for fk ref from object_store_drain_info
CREATE TRIGGER trg_fk_debug_object_store_drain_info_0
BEFORE DELETE ON 'object_store_drain_phase_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_drain_phase_type due to referencing rows in object_store_drain_info ON phase_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'object_store_drain_info'
        WHERE phase_type_id=OLD.id;
END;

-- fk debug delete trigger for object_store_metadata for fk ref from object_store_metadata_path
CREATE TRIGGER trg_fk_debug_object_store_metadata_path_0
BEFORE DELETE ON 'object_store_metadata' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM object_store_metadata due to referencing rows in object_store_metadata_path ON metadata_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'object_store_metadata_path'
        WHERE metadata_uuid=OLD.uuid;
END;

-- fk debug delete trigger for permission_object_access for fk ref from permission
CREATE TRIGGER trg_fk_debug_permission_0
BEFORE DELETE ON 'permission_object_access' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM permission_object_access due to referencing rows in permission ON access_type_id object_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'permission'
        WHERE access_type_id=OLD.access_type_id AND object_type_id=OLD.object_type_id;
END;

-- fk debug delete trigger for user for fk ref from permission
CREATE TRIGGER trg_fk_debug_permission_1
BEFORE DELETE ON 'user' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user due to referencing rows in permission ON grant_to')
                    ELSE
                        NULL
                    END panic
        FROM 'permission'
        WHERE grant_to=OLD.uuid;
END;

-- fk debug delete trigger for permission_object_type for fk ref from permission_object_access
CREATE TRIGGER trg_fk_debug_permission_object_access_0
BEFORE DELETE ON 'permission_object_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM permission_object_type due to referencing rows in permission_object_access ON object_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'permission_object_access'
        WHERE object_type_id=OLD.id;
END;

-- fk debug delete trigger for permission_access_type for fk ref from permission_object_access
CREATE TRIGGER trg_fk_debug_permission_object_access_1
BEFORE DELETE ON 'permission_access_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM permission_access_type due to referencing rows in permission_object_access ON access_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'permission_object_access'
        WHERE access_type_id=OLD.id;
END;

-- fk debug delete trigger for secret_backend_type for fk ref from secret_backend
CREATE TRIGGER trg_fk_debug_secret_backend_0
BEFORE DELETE ON 'secret_backend_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_backend_type due to referencing rows in secret_backend ON backend_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_backend'
        WHERE backend_type_id=OLD.id;
END;

-- fk debug delete trigger for secret_backend for fk ref from secret_backend_config
CREATE TRIGGER trg_fk_debug_secret_backend_config_0
BEFORE DELETE ON 'secret_backend' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_backend due to referencing rows in secret_backend_config ON backend_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_backend_config'
        WHERE backend_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_backend for fk ref from secret_backend_reference
CREATE TRIGGER trg_fk_debug_secret_backend_reference_0
BEFORE DELETE ON 'secret_backend' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_backend due to referencing rows in secret_backend_reference ON secret_backend_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_backend_reference'
        WHERE secret_backend_uuid=OLD.uuid;
END;

-- fk debug delete trigger for model for fk ref from secret_backend_reference
CREATE TRIGGER trg_fk_debug_secret_backend_reference_1
BEFORE DELETE ON 'model' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM model due to referencing rows in secret_backend_reference ON model_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_backend_reference'
        WHERE model_uuid=OLD.uuid;
END;

-- fk debug delete trigger for secret_backend for fk ref from secret_backend_rotation
CREATE TRIGGER trg_fk_debug_secret_backend_rotation_0
BEFORE DELETE ON 'secret_backend' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM secret_backend due to referencing rows in secret_backend_rotation ON backend_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'secret_backend_rotation'
        WHERE backend_uuid=OLD.uuid;
END;

-- fk debug delete trigger for upgrade_state_type for fk ref from upgrade_info
CREATE TRIGGER trg_fk_debug_upgrade_info_0
BEFORE DELETE ON 'upgrade_state_type' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM upgrade_state_type due to referencing rows in upgrade_info ON state_type_id')
                    ELSE
                        NULL
                    END panic
        FROM 'upgrade_info'
        WHERE state_type_id=OLD.id;
END;

-- fk debug delete trigger for upgrade_info for fk ref from upgrade_info_controller_node
CREATE TRIGGER trg_fk_debug_upgrade_info_controller_node_0
BEFORE DELETE ON 'upgrade_info' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM upgrade_info due to referencing rows in upgrade_info_controller_node ON upgrade_info_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'upgrade_info_controller_node'
        WHERE upgrade_info_uuid=OLD.uuid;
END;

-- fk debug delete trigger for controller_node for fk ref from upgrade_info_controller_node
CREATE TRIGGER trg_fk_debug_upgrade_info_controller_node_1
BEFORE DELETE ON 'controller_node' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM controller_node due to referencing rows in upgrade_info_controller_node ON controller_node_id')
                    ELSE
                        NULL
                    END panic
        FROM 'upgrade_info_controller_node'
        WHERE controller_node_id=OLD.controller_id;
END;

-- fk debug delete trigger for user for fk ref from user
CREATE TRIGGER trg_fk_debug_user_0
BEFORE DELETE ON 'user' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user due to referencing rows in user ON created_by_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'user'
        WHERE created_by_uuid=OLD.uuid;
END;

-- fk debug delete trigger for user_authentication for fk ref from user_activation_key
CREATE TRIGGER trg_fk_debug_user_activation_key_0
BEFORE DELETE ON 'user_authentication' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user_authentication due to referencing rows in user_activation_key ON user_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'user_activation_key'
        WHERE user_uuid=OLD.user_uuid;
END;

-- fk debug delete trigger for user for fk ref from user_authentication
CREATE TRIGGER trg_fk_debug_user_authentication_0
BEFORE DELETE ON 'user' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user due to referencing rows in user_authentication ON user_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'user_authentication'
        WHERE user_uuid=OLD.uuid;
END;

-- fk debug delete trigger for user_authentication for fk ref from user_password
CREATE TRIGGER trg_fk_debug_user_password_0
BEFORE DELETE ON 'user_authentication' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user_authentication due to referencing rows in user_password ON user_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'user_password'
        WHERE user_uuid=OLD.user_uuid;
END;

-- fk debug delete trigger for user for fk ref from user_public_ssh_key
CREATE TRIGGER trg_fk_debug_user_public_ssh_key_0
BEFORE DELETE ON 'user' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM user due to referencing rows in user_public_ssh_key ON user_uuid')
                    ELSE
                        NULL
                    END panic
        FROM 'user_public_ssh_key'
        WHERE user_uuid=OLD.uuid;
END;

-- fk debug delete trigger for ssh_fingerprint_hash_algorithm for fk ref from user_public_ssh_key
CREATE TRIGGER trg_fk_debug_user_public_ssh_key_1
BEFORE DELETE ON 'ssh_fingerprint_hash_algorithm' FOR EACH ROW
BEGIN
        SELECT CASE WHEN COUNT(*) > 0 AND (SELECT * FROM pragma_foreign_keys)
                    THEN
                        RAISE(FAIL, 'Foreign Key violation during DELETE FROM ssh_fingerprint_hash_algorithm due to referencing rows in user_public_ssh_key ON fingerprint_hash_algorithm_id')
                    ELSE
                        NULL
                    END panic
        FROM 'user_public_ssh_key'
        WHERE fingerprint_hash_algorithm_id=OLD.id;
END;

`)
	}
}


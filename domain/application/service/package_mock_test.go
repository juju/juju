// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/domain/application/service (interfaces: ApplicationState,CharmState,DeleteSecretState,ResourceState,WatcherFactory,AgentVersionGetter,Provider)
//
// Generated by this command:
//
//	mockgen -typed -package service -destination package_mock_test.go github.com/juju/juju/domain/application/service ApplicationState,CharmState,DeleteSecretState,ResourceState,WatcherFactory,AgentVersionGetter,Provider
//

// Package service is a generated GoMock package.
package service

import (
	context "context"
	reflect "reflect"

	application "github.com/juju/juju/core/application"
	assumes "github.com/juju/juju/core/assumes"
	changestream "github.com/juju/juju/core/changestream"
	charm "github.com/juju/juju/core/charm"
	model "github.com/juju/juju/core/model"
	network "github.com/juju/juju/core/network"
	resources "github.com/juju/juju/core/resources"
	secrets "github.com/juju/juju/core/secrets"
	unit "github.com/juju/juju/core/unit"
	watcher "github.com/juju/juju/core/watcher"
	eventsource "github.com/juju/juju/core/watcher/eventsource"
	domain "github.com/juju/juju/domain"
	application0 "github.com/juju/juju/domain/application"
	charm0 "github.com/juju/juju/domain/application/charm"
	resource "github.com/juju/juju/domain/application/resource"
	life "github.com/juju/juju/domain/life"
	storage "github.com/juju/juju/domain/storage"
	version "github.com/juju/version/v2"
	gomock "go.uber.org/mock/gomock"
)

// MockApplicationState is a mock of ApplicationState interface.
type MockApplicationState struct {
	ctrl     *gomock.Controller
	recorder *MockApplicationStateMockRecorder
}

// MockApplicationStateMockRecorder is the mock recorder for MockApplicationState.
type MockApplicationStateMockRecorder struct {
	mock *MockApplicationState
}

// NewMockApplicationState creates a new mock instance.
func NewMockApplicationState(ctrl *gomock.Controller) *MockApplicationState {
	mock := &MockApplicationState{ctrl: ctrl}
	mock.recorder = &MockApplicationStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockApplicationState) EXPECT() *MockApplicationStateMockRecorder {
	return m.recorder
}

// AddUnits mocks base method.
func (m *MockApplicationState) AddUnits(arg0 domain.AtomicContext, arg1 application.ID, arg2 ...application0.AddUnitArg) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddUnits", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddUnits indicates an expected call of AddUnits.
func (mr *MockApplicationStateMockRecorder) AddUnits(arg0, arg1 any, arg2 ...any) *MockApplicationStateAddUnitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUnits", reflect.TypeOf((*MockApplicationState)(nil).AddUnits), varargs...)
	return &MockApplicationStateAddUnitsCall{Call: call}
}

// MockApplicationStateAddUnitsCall wrap *gomock.Call
type MockApplicationStateAddUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateAddUnitsCall) Return(arg0 error) *MockApplicationStateAddUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateAddUnitsCall) Do(f func(domain.AtomicContext, application.ID, ...application0.AddUnitArg) error) *MockApplicationStateAddUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateAddUnitsCall) DoAndReturn(f func(domain.AtomicContext, application.ID, ...application0.AddUnitArg) error) *MockApplicationStateAddUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateApplication mocks base method.
func (m *MockApplicationState) CreateApplication(arg0 domain.AtomicContext, arg1 string, arg2 application0.AddApplicationArg) (application.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateApplication", arg0, arg1, arg2)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateApplication indicates an expected call of CreateApplication.
func (mr *MockApplicationStateMockRecorder) CreateApplication(arg0, arg1, arg2 any) *MockApplicationStateCreateApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateApplication", reflect.TypeOf((*MockApplicationState)(nil).CreateApplication), arg0, arg1, arg2)
	return &MockApplicationStateCreateApplicationCall{Call: call}
}

// MockApplicationStateCreateApplicationCall wrap *gomock.Call
type MockApplicationStateCreateApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateCreateApplicationCall) Return(arg0 application.ID, arg1 error) *MockApplicationStateCreateApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateCreateApplicationCall) Do(f func(domain.AtomicContext, string, application0.AddApplicationArg) (application.ID, error)) *MockApplicationStateCreateApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateCreateApplicationCall) DoAndReturn(f func(domain.AtomicContext, string, application0.AddApplicationArg) (application.ID, error)) *MockApplicationStateCreateApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteApplication mocks base method.
func (m *MockApplicationState) DeleteApplication(arg0 domain.AtomicContext, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteApplication", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteApplication indicates an expected call of DeleteApplication.
func (mr *MockApplicationStateMockRecorder) DeleteApplication(arg0, arg1 any) *MockApplicationStateDeleteApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteApplication", reflect.TypeOf((*MockApplicationState)(nil).DeleteApplication), arg0, arg1)
	return &MockApplicationStateDeleteApplicationCall{Call: call}
}

// MockApplicationStateDeleteApplicationCall wrap *gomock.Call
type MockApplicationStateDeleteApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateDeleteApplicationCall) Return(arg0 error) *MockApplicationStateDeleteApplicationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateDeleteApplicationCall) Do(f func(domain.AtomicContext, string) error) *MockApplicationStateDeleteApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateDeleteApplicationCall) DoAndReturn(f func(domain.AtomicContext, string) error) *MockApplicationStateDeleteApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteUnit mocks base method.
func (m *MockApplicationState) DeleteUnit(arg0 domain.AtomicContext, arg1 unit.Name) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteUnit", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteUnit indicates an expected call of DeleteUnit.
func (mr *MockApplicationStateMockRecorder) DeleteUnit(arg0, arg1 any) *MockApplicationStateDeleteUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUnit", reflect.TypeOf((*MockApplicationState)(nil).DeleteUnit), arg0, arg1)
	return &MockApplicationStateDeleteUnitCall{Call: call}
}

// MockApplicationStateDeleteUnitCall wrap *gomock.Call
type MockApplicationStateDeleteUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateDeleteUnitCall) Return(arg0 bool, arg1 error) *MockApplicationStateDeleteUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateDeleteUnitCall) Do(f func(domain.AtomicContext, unit.Name) (bool, error)) *MockApplicationStateDeleteUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateDeleteUnitCall) DoAndReturn(f func(domain.AtomicContext, unit.Name) (bool, error)) *MockApplicationStateDeleteUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationID mocks base method.
func (m *MockApplicationState) GetApplicationID(arg0 domain.AtomicContext, arg1 string) (application.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationID", arg0, arg1)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationID indicates an expected call of GetApplicationID.
func (mr *MockApplicationStateMockRecorder) GetApplicationID(arg0, arg1 any) *MockApplicationStateGetApplicationIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationID", reflect.TypeOf((*MockApplicationState)(nil).GetApplicationID), arg0, arg1)
	return &MockApplicationStateGetApplicationIDCall{Call: call}
}

// MockApplicationStateGetApplicationIDCall wrap *gomock.Call
type MockApplicationStateGetApplicationIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetApplicationIDCall) Return(arg0 application.ID, arg1 error) *MockApplicationStateGetApplicationIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetApplicationIDCall) Do(f func(domain.AtomicContext, string) (application.ID, error)) *MockApplicationStateGetApplicationIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetApplicationIDCall) DoAndReturn(f func(domain.AtomicContext, string) (application.ID, error)) *MockApplicationStateGetApplicationIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationLife mocks base method.
func (m *MockApplicationState) GetApplicationLife(arg0 domain.AtomicContext, arg1 string) (application.ID, life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationLife", arg0, arg1)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(life.Life)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApplicationLife indicates an expected call of GetApplicationLife.
func (mr *MockApplicationStateMockRecorder) GetApplicationLife(arg0, arg1 any) *MockApplicationStateGetApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationLife", reflect.TypeOf((*MockApplicationState)(nil).GetApplicationLife), arg0, arg1)
	return &MockApplicationStateGetApplicationLifeCall{Call: call}
}

// MockApplicationStateGetApplicationLifeCall wrap *gomock.Call
type MockApplicationStateGetApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetApplicationLifeCall) Return(arg0 application.ID, arg1 life.Life, arg2 error) *MockApplicationStateGetApplicationLifeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetApplicationLifeCall) Do(f func(domain.AtomicContext, string) (application.ID, life.Life, error)) *MockApplicationStateGetApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetApplicationLifeCall) DoAndReturn(f func(domain.AtomicContext, string) (application.ID, life.Life, error)) *MockApplicationStateGetApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationScaleState mocks base method.
func (m *MockApplicationState) GetApplicationScaleState(arg0 domain.AtomicContext, arg1 application.ID) (application0.ScaleState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationScaleState", arg0, arg1)
	ret0, _ := ret[0].(application0.ScaleState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationScaleState indicates an expected call of GetApplicationScaleState.
func (mr *MockApplicationStateMockRecorder) GetApplicationScaleState(arg0, arg1 any) *MockApplicationStateGetApplicationScaleStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationScaleState", reflect.TypeOf((*MockApplicationState)(nil).GetApplicationScaleState), arg0, arg1)
	return &MockApplicationStateGetApplicationScaleStateCall{Call: call}
}

// MockApplicationStateGetApplicationScaleStateCall wrap *gomock.Call
type MockApplicationStateGetApplicationScaleStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetApplicationScaleStateCall) Return(arg0 application0.ScaleState, arg1 error) *MockApplicationStateGetApplicationScaleStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetApplicationScaleStateCall) Do(f func(domain.AtomicContext, application.ID) (application0.ScaleState, error)) *MockApplicationStateGetApplicationScaleStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetApplicationScaleStateCall) DoAndReturn(f func(domain.AtomicContext, application.ID) (application0.ScaleState, error)) *MockApplicationStateGetApplicationScaleStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUnitLife mocks base method.
func (m *MockApplicationState) GetApplicationUnitLife(arg0 context.Context, arg1 string, arg2 ...unit.UUID) (map[unit.UUID]life.Life, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetApplicationUnitLife", varargs...)
	ret0, _ := ret[0].(map[unit.UUID]life.Life)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationUnitLife indicates an expected call of GetApplicationUnitLife.
func (mr *MockApplicationStateMockRecorder) GetApplicationUnitLife(arg0, arg1 any, arg2 ...any) *MockApplicationStateGetApplicationUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUnitLife", reflect.TypeOf((*MockApplicationState)(nil).GetApplicationUnitLife), varargs...)
	return &MockApplicationStateGetApplicationUnitLifeCall{Call: call}
}

// MockApplicationStateGetApplicationUnitLifeCall wrap *gomock.Call
type MockApplicationStateGetApplicationUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetApplicationUnitLifeCall) Return(arg0 map[unit.UUID]life.Life, arg1 error) *MockApplicationStateGetApplicationUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetApplicationUnitLifeCall) Do(f func(context.Context, string, ...unit.UUID) (map[unit.UUID]life.Life, error)) *MockApplicationStateGetApplicationUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetApplicationUnitLifeCall) DoAndReturn(f func(context.Context, string, ...unit.UUID) (map[unit.UUID]life.Life, error)) *MockApplicationStateGetApplicationUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmByApplicationID mocks base method.
func (m *MockApplicationState) GetCharmByApplicationID(arg0 context.Context, arg1 application.ID) (charm0.Charm, charm0.CharmOrigin, charm0.Platform, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmByApplicationID", arg0, arg1)
	ret0, _ := ret[0].(charm0.Charm)
	ret1, _ := ret[1].(charm0.CharmOrigin)
	ret2, _ := ret[2].(charm0.Platform)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetCharmByApplicationID indicates an expected call of GetCharmByApplicationID.
func (mr *MockApplicationStateMockRecorder) GetCharmByApplicationID(arg0, arg1 any) *MockApplicationStateGetCharmByApplicationIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmByApplicationID", reflect.TypeOf((*MockApplicationState)(nil).GetCharmByApplicationID), arg0, arg1)
	return &MockApplicationStateGetCharmByApplicationIDCall{Call: call}
}

// MockApplicationStateGetCharmByApplicationIDCall wrap *gomock.Call
type MockApplicationStateGetCharmByApplicationIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetCharmByApplicationIDCall) Return(arg0 charm0.Charm, arg1 charm0.CharmOrigin, arg2 charm0.Platform, arg3 error) *MockApplicationStateGetCharmByApplicationIDCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetCharmByApplicationIDCall) Do(f func(context.Context, application.ID) (charm0.Charm, charm0.CharmOrigin, charm0.Platform, error)) *MockApplicationStateGetCharmByApplicationIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetCharmByApplicationIDCall) DoAndReturn(f func(context.Context, application.ID) (charm0.Charm, charm0.CharmOrigin, charm0.Platform, error)) *MockApplicationStateGetCharmByApplicationIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmIDByApplicationName mocks base method.
func (m *MockApplicationState) GetCharmIDByApplicationName(arg0 context.Context, arg1 string) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmIDByApplicationName", arg0, arg1)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmIDByApplicationName indicates an expected call of GetCharmIDByApplicationName.
func (mr *MockApplicationStateMockRecorder) GetCharmIDByApplicationName(arg0, arg1 any) *MockApplicationStateGetCharmIDByApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmIDByApplicationName", reflect.TypeOf((*MockApplicationState)(nil).GetCharmIDByApplicationName), arg0, arg1)
	return &MockApplicationStateGetCharmIDByApplicationNameCall{Call: call}
}

// MockApplicationStateGetCharmIDByApplicationNameCall wrap *gomock.Call
type MockApplicationStateGetCharmIDByApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetCharmIDByApplicationNameCall) Return(arg0 charm.ID, arg1 error) *MockApplicationStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetCharmIDByApplicationNameCall) Do(f func(context.Context, string) (charm.ID, error)) *MockApplicationStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetCharmIDByApplicationNameCall) DoAndReturn(f func(context.Context, string) (charm.ID, error)) *MockApplicationStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetModelType mocks base method.
func (m *MockApplicationState) GetModelType(arg0 context.Context) (model.ModelType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModelType", arg0)
	ret0, _ := ret[0].(model.ModelType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModelType indicates an expected call of GetModelType.
func (mr *MockApplicationStateMockRecorder) GetModelType(arg0 any) *MockApplicationStateGetModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelType", reflect.TypeOf((*MockApplicationState)(nil).GetModelType), arg0)
	return &MockApplicationStateGetModelTypeCall{Call: call}
}

// MockApplicationStateGetModelTypeCall wrap *gomock.Call
type MockApplicationStateGetModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetModelTypeCall) Return(arg0 model.ModelType, arg1 error) *MockApplicationStateGetModelTypeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetModelTypeCall) Do(f func(context.Context) (model.ModelType, error)) *MockApplicationStateGetModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetModelTypeCall) DoAndReturn(f func(context.Context) (model.ModelType, error)) *MockApplicationStateGetModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSecretsForApplication mocks base method.
func (m *MockApplicationState) GetSecretsForApplication(arg0 domain.AtomicContext, arg1 string) ([]*secrets.URI, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSecretsForApplication", arg0, arg1)
	ret0, _ := ret[0].([]*secrets.URI)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSecretsForApplication indicates an expected call of GetSecretsForApplication.
func (mr *MockApplicationStateMockRecorder) GetSecretsForApplication(arg0, arg1 any) *MockApplicationStateGetSecretsForApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecretsForApplication", reflect.TypeOf((*MockApplicationState)(nil).GetSecretsForApplication), arg0, arg1)
	return &MockApplicationStateGetSecretsForApplicationCall{Call: call}
}

// MockApplicationStateGetSecretsForApplicationCall wrap *gomock.Call
type MockApplicationStateGetSecretsForApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetSecretsForApplicationCall) Return(arg0 []*secrets.URI, arg1 error) *MockApplicationStateGetSecretsForApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetSecretsForApplicationCall) Do(f func(domain.AtomicContext, string) ([]*secrets.URI, error)) *MockApplicationStateGetSecretsForApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetSecretsForApplicationCall) DoAndReturn(f func(domain.AtomicContext, string) ([]*secrets.URI, error)) *MockApplicationStateGetSecretsForApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSecretsForUnit mocks base method.
func (m *MockApplicationState) GetSecretsForUnit(arg0 domain.AtomicContext, arg1 unit.Name) ([]*secrets.URI, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSecretsForUnit", arg0, arg1)
	ret0, _ := ret[0].([]*secrets.URI)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSecretsForUnit indicates an expected call of GetSecretsForUnit.
func (mr *MockApplicationStateMockRecorder) GetSecretsForUnit(arg0, arg1 any) *MockApplicationStateGetSecretsForUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSecretsForUnit", reflect.TypeOf((*MockApplicationState)(nil).GetSecretsForUnit), arg0, arg1)
	return &MockApplicationStateGetSecretsForUnitCall{Call: call}
}

// MockApplicationStateGetSecretsForUnitCall wrap *gomock.Call
type MockApplicationStateGetSecretsForUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetSecretsForUnitCall) Return(arg0 []*secrets.URI, arg1 error) *MockApplicationStateGetSecretsForUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetSecretsForUnitCall) Do(f func(domain.AtomicContext, unit.Name) ([]*secrets.URI, error)) *MockApplicationStateGetSecretsForUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetSecretsForUnitCall) DoAndReturn(f func(domain.AtomicContext, unit.Name) ([]*secrets.URI, error)) *MockApplicationStateGetSecretsForUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStoragePoolByName mocks base method.
func (m *MockApplicationState) GetStoragePoolByName(arg0 context.Context, arg1 string) (storage.StoragePoolDetails, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoragePoolByName", arg0, arg1)
	ret0, _ := ret[0].(storage.StoragePoolDetails)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStoragePoolByName indicates an expected call of GetStoragePoolByName.
func (mr *MockApplicationStateMockRecorder) GetStoragePoolByName(arg0, arg1 any) *MockApplicationStateGetStoragePoolByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoragePoolByName", reflect.TypeOf((*MockApplicationState)(nil).GetStoragePoolByName), arg0, arg1)
	return &MockApplicationStateGetStoragePoolByNameCall{Call: call}
}

// MockApplicationStateGetStoragePoolByNameCall wrap *gomock.Call
type MockApplicationStateGetStoragePoolByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetStoragePoolByNameCall) Return(arg0 storage.StoragePoolDetails, arg1 error) *MockApplicationStateGetStoragePoolByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetStoragePoolByNameCall) Do(f func(context.Context, string) (storage.StoragePoolDetails, error)) *MockApplicationStateGetStoragePoolByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetStoragePoolByNameCall) DoAndReturn(f func(context.Context, string) (storage.StoragePoolDetails, error)) *MockApplicationStateGetStoragePoolByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitLife mocks base method.
func (m *MockApplicationState) GetUnitLife(arg0 domain.AtomicContext, arg1 unit.Name) (life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitLife", arg0, arg1)
	ret0, _ := ret[0].(life.Life)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitLife indicates an expected call of GetUnitLife.
func (mr *MockApplicationStateMockRecorder) GetUnitLife(arg0, arg1 any) *MockApplicationStateGetUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitLife", reflect.TypeOf((*MockApplicationState)(nil).GetUnitLife), arg0, arg1)
	return &MockApplicationStateGetUnitLifeCall{Call: call}
}

// MockApplicationStateGetUnitLifeCall wrap *gomock.Call
type MockApplicationStateGetUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetUnitLifeCall) Return(arg0 life.Life, arg1 error) *MockApplicationStateGetUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetUnitLifeCall) Do(f func(domain.AtomicContext, unit.Name) (life.Life, error)) *MockApplicationStateGetUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetUnitLifeCall) DoAndReturn(f func(domain.AtomicContext, unit.Name) (life.Life, error)) *MockApplicationStateGetUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitNames mocks base method.
func (m *MockApplicationState) GetUnitNames(arg0 context.Context, arg1 []unit.UUID) ([]unit.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitNames", arg0, arg1)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitNames indicates an expected call of GetUnitNames.
func (mr *MockApplicationStateMockRecorder) GetUnitNames(arg0, arg1 any) *MockApplicationStateGetUnitNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitNames", reflect.TypeOf((*MockApplicationState)(nil).GetUnitNames), arg0, arg1)
	return &MockApplicationStateGetUnitNamesCall{Call: call}
}

// MockApplicationStateGetUnitNamesCall wrap *gomock.Call
type MockApplicationStateGetUnitNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetUnitNamesCall) Return(arg0 []unit.Name, arg1 error) *MockApplicationStateGetUnitNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetUnitNamesCall) Do(f func(context.Context, []unit.UUID) ([]unit.Name, error)) *MockApplicationStateGetUnitNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetUnitNamesCall) DoAndReturn(f func(context.Context, []unit.UUID) ([]unit.Name, error)) *MockApplicationStateGetUnitNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitUUID mocks base method.
func (m *MockApplicationState) GetUnitUUID(arg0 domain.AtomicContext, arg1 unit.Name) (unit.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitUUID", arg0, arg1)
	ret0, _ := ret[0].(unit.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitUUID indicates an expected call of GetUnitUUID.
func (mr *MockApplicationStateMockRecorder) GetUnitUUID(arg0, arg1 any) *MockApplicationStateGetUnitUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitUUID", reflect.TypeOf((*MockApplicationState)(nil).GetUnitUUID), arg0, arg1)
	return &MockApplicationStateGetUnitUUIDCall{Call: call}
}

// MockApplicationStateGetUnitUUIDCall wrap *gomock.Call
type MockApplicationStateGetUnitUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetUnitUUIDCall) Return(arg0 unit.UUID, arg1 error) *MockApplicationStateGetUnitUUIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetUnitUUIDCall) Do(f func(domain.AtomicContext, unit.Name) (unit.UUID, error)) *MockApplicationStateGetUnitUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetUnitUUIDCall) DoAndReturn(f func(domain.AtomicContext, unit.Name) (unit.UUID, error)) *MockApplicationStateGetUnitUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitUUIDs mocks base method.
func (m *MockApplicationState) GetUnitUUIDs(arg0 context.Context, arg1 []unit.Name) ([]unit.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitUUIDs", arg0, arg1)
	ret0, _ := ret[0].([]unit.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitUUIDs indicates an expected call of GetUnitUUIDs.
func (mr *MockApplicationStateMockRecorder) GetUnitUUIDs(arg0, arg1 any) *MockApplicationStateGetUnitUUIDsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitUUIDs", reflect.TypeOf((*MockApplicationState)(nil).GetUnitUUIDs), arg0, arg1)
	return &MockApplicationStateGetUnitUUIDsCall{Call: call}
}

// MockApplicationStateGetUnitUUIDsCall wrap *gomock.Call
type MockApplicationStateGetUnitUUIDsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateGetUnitUUIDsCall) Return(arg0 []unit.UUID, arg1 error) *MockApplicationStateGetUnitUUIDsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateGetUnitUUIDsCall) Do(f func(context.Context, []unit.Name) ([]unit.UUID, error)) *MockApplicationStateGetUnitUUIDsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateGetUnitUUIDsCall) DoAndReturn(f func(context.Context, []unit.Name) ([]unit.UUID, error)) *MockApplicationStateGetUnitUUIDsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementUnitLife mocks base method.
func (m *MockApplicationState) InitialWatchStatementUnitLife(arg0 string) (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementUnitLife", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementUnitLife indicates an expected call of InitialWatchStatementUnitLife.
func (mr *MockApplicationStateMockRecorder) InitialWatchStatementUnitLife(arg0 any) *MockApplicationStateInitialWatchStatementUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementUnitLife", reflect.TypeOf((*MockApplicationState)(nil).InitialWatchStatementUnitLife), arg0)
	return &MockApplicationStateInitialWatchStatementUnitLifeCall{Call: call}
}

// MockApplicationStateInitialWatchStatementUnitLifeCall wrap *gomock.Call
type MockApplicationStateInitialWatchStatementUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateInitialWatchStatementUnitLifeCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockApplicationStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateInitialWatchStatementUnitLifeCall) Do(f func(string) (string, eventsource.NamespaceQuery)) *MockApplicationStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateInitialWatchStatementUnitLifeCall) DoAndReturn(f func(string) (string, eventsource.NamespaceQuery)) *MockApplicationStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertUnit mocks base method.
func (m *MockApplicationState) InsertUnit(arg0 domain.AtomicContext, arg1 application.ID, arg2 application0.InsertUnitArg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertUnit indicates an expected call of InsertUnit.
func (mr *MockApplicationStateMockRecorder) InsertUnit(arg0, arg1, arg2 any) *MockApplicationStateInsertUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertUnit", reflect.TypeOf((*MockApplicationState)(nil).InsertUnit), arg0, arg1, arg2)
	return &MockApplicationStateInsertUnitCall{Call: call}
}

// MockApplicationStateInsertUnitCall wrap *gomock.Call
type MockApplicationStateInsertUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateInsertUnitCall) Return(arg0 error) *MockApplicationStateInsertUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateInsertUnitCall) Do(f func(domain.AtomicContext, application.ID, application0.InsertUnitArg) error) *MockApplicationStateInsertUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateInsertUnitCall) DoAndReturn(f func(domain.AtomicContext, application.ID, application0.InsertUnitArg) error) *MockApplicationStateInsertUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RunAtomic mocks base method.
func (m *MockApplicationState) RunAtomic(arg0 context.Context, arg1 func(domain.AtomicContext) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunAtomic", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunAtomic indicates an expected call of RunAtomic.
func (mr *MockApplicationStateMockRecorder) RunAtomic(arg0, arg1 any) *MockApplicationStateRunAtomicCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunAtomic", reflect.TypeOf((*MockApplicationState)(nil).RunAtomic), arg0, arg1)
	return &MockApplicationStateRunAtomicCall{Call: call}
}

// MockApplicationStateRunAtomicCall wrap *gomock.Call
type MockApplicationStateRunAtomicCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateRunAtomicCall) Return(arg0 error) *MockApplicationStateRunAtomicCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateRunAtomicCall) Do(f func(context.Context, func(domain.AtomicContext) error) error) *MockApplicationStateRunAtomicCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateRunAtomicCall) DoAndReturn(f func(context.Context, func(domain.AtomicContext) error) error) *MockApplicationStateRunAtomicCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationLife mocks base method.
func (m *MockApplicationState) SetApplicationLife(arg0 domain.AtomicContext, arg1 application.ID, arg2 life.Life) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationLife", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationLife indicates an expected call of SetApplicationLife.
func (mr *MockApplicationStateMockRecorder) SetApplicationLife(arg0, arg1, arg2 any) *MockApplicationStateSetApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationLife", reflect.TypeOf((*MockApplicationState)(nil).SetApplicationLife), arg0, arg1, arg2)
	return &MockApplicationStateSetApplicationLifeCall{Call: call}
}

// MockApplicationStateSetApplicationLifeCall wrap *gomock.Call
type MockApplicationStateSetApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetApplicationLifeCall) Return(arg0 error) *MockApplicationStateSetApplicationLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetApplicationLifeCall) Do(f func(domain.AtomicContext, application.ID, life.Life) error) *MockApplicationStateSetApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetApplicationLifeCall) DoAndReturn(f func(domain.AtomicContext, application.ID, life.Life) error) *MockApplicationStateSetApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationScalingState mocks base method.
func (m *MockApplicationState) SetApplicationScalingState(arg0 domain.AtomicContext, arg1 application.ID, arg2 *int, arg3 int, arg4 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationScalingState", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationScalingState indicates an expected call of SetApplicationScalingState.
func (mr *MockApplicationStateMockRecorder) SetApplicationScalingState(arg0, arg1, arg2, arg3, arg4 any) *MockApplicationStateSetApplicationScalingStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationScalingState", reflect.TypeOf((*MockApplicationState)(nil).SetApplicationScalingState), arg0, arg1, arg2, arg3, arg4)
	return &MockApplicationStateSetApplicationScalingStateCall{Call: call}
}

// MockApplicationStateSetApplicationScalingStateCall wrap *gomock.Call
type MockApplicationStateSetApplicationScalingStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetApplicationScalingStateCall) Return(arg0 error) *MockApplicationStateSetApplicationScalingStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetApplicationScalingStateCall) Do(f func(domain.AtomicContext, application.ID, *int, int, bool) error) *MockApplicationStateSetApplicationScalingStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetApplicationScalingStateCall) DoAndReturn(f func(domain.AtomicContext, application.ID, *int, int, bool) error) *MockApplicationStateSetApplicationScalingStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCloudContainerStatus mocks base method.
func (m *MockApplicationState) SetCloudContainerStatus(arg0 domain.AtomicContext, arg1 unit.UUID, arg2 application0.CloudContainerStatusStatusInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCloudContainerStatus", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCloudContainerStatus indicates an expected call of SetCloudContainerStatus.
func (mr *MockApplicationStateMockRecorder) SetCloudContainerStatus(arg0, arg1, arg2 any) *MockApplicationStateSetCloudContainerStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCloudContainerStatus", reflect.TypeOf((*MockApplicationState)(nil).SetCloudContainerStatus), arg0, arg1, arg2)
	return &MockApplicationStateSetCloudContainerStatusCall{Call: call}
}

// MockApplicationStateSetCloudContainerStatusCall wrap *gomock.Call
type MockApplicationStateSetCloudContainerStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetCloudContainerStatusCall) Return(arg0 error) *MockApplicationStateSetCloudContainerStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetCloudContainerStatusCall) Do(f func(domain.AtomicContext, unit.UUID, application0.CloudContainerStatusStatusInfo) error) *MockApplicationStateSetCloudContainerStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetCloudContainerStatusCall) DoAndReturn(f func(domain.AtomicContext, unit.UUID, application0.CloudContainerStatusStatusInfo) error) *MockApplicationStateSetCloudContainerStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetDesiredApplicationScale mocks base method.
func (m *MockApplicationState) SetDesiredApplicationScale(arg0 domain.AtomicContext, arg1 application.ID, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDesiredApplicationScale", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDesiredApplicationScale indicates an expected call of SetDesiredApplicationScale.
func (mr *MockApplicationStateMockRecorder) SetDesiredApplicationScale(arg0, arg1, arg2 any) *MockApplicationStateSetDesiredApplicationScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDesiredApplicationScale", reflect.TypeOf((*MockApplicationState)(nil).SetDesiredApplicationScale), arg0, arg1, arg2)
	return &MockApplicationStateSetDesiredApplicationScaleCall{Call: call}
}

// MockApplicationStateSetDesiredApplicationScaleCall wrap *gomock.Call
type MockApplicationStateSetDesiredApplicationScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetDesiredApplicationScaleCall) Return(arg0 error) *MockApplicationStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetDesiredApplicationScaleCall) Do(f func(domain.AtomicContext, application.ID, int) error) *MockApplicationStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetDesiredApplicationScaleCall) DoAndReturn(f func(domain.AtomicContext, application.ID, int) error) *MockApplicationStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitAgentStatus mocks base method.
func (m *MockApplicationState) SetUnitAgentStatus(arg0 domain.AtomicContext, arg1 unit.UUID, arg2 application0.UnitAgentStatusInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitAgentStatus", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitAgentStatus indicates an expected call of SetUnitAgentStatus.
func (mr *MockApplicationStateMockRecorder) SetUnitAgentStatus(arg0, arg1, arg2 any) *MockApplicationStateSetUnitAgentStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitAgentStatus", reflect.TypeOf((*MockApplicationState)(nil).SetUnitAgentStatus), arg0, arg1, arg2)
	return &MockApplicationStateSetUnitAgentStatusCall{Call: call}
}

// MockApplicationStateSetUnitAgentStatusCall wrap *gomock.Call
type MockApplicationStateSetUnitAgentStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetUnitAgentStatusCall) Return(arg0 error) *MockApplicationStateSetUnitAgentStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetUnitAgentStatusCall) Do(f func(domain.AtomicContext, unit.UUID, application0.UnitAgentStatusInfo) error) *MockApplicationStateSetUnitAgentStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetUnitAgentStatusCall) DoAndReturn(f func(domain.AtomicContext, unit.UUID, application0.UnitAgentStatusInfo) error) *MockApplicationStateSetUnitAgentStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitLife mocks base method.
func (m *MockApplicationState) SetUnitLife(arg0 domain.AtomicContext, arg1 unit.Name, arg2 life.Life) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitLife", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitLife indicates an expected call of SetUnitLife.
func (mr *MockApplicationStateMockRecorder) SetUnitLife(arg0, arg1, arg2 any) *MockApplicationStateSetUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitLife", reflect.TypeOf((*MockApplicationState)(nil).SetUnitLife), arg0, arg1, arg2)
	return &MockApplicationStateSetUnitLifeCall{Call: call}
}

// MockApplicationStateSetUnitLifeCall wrap *gomock.Call
type MockApplicationStateSetUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetUnitLifeCall) Return(arg0 error) *MockApplicationStateSetUnitLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetUnitLifeCall) Do(f func(domain.AtomicContext, unit.Name, life.Life) error) *MockApplicationStateSetUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetUnitLifeCall) DoAndReturn(f func(domain.AtomicContext, unit.Name, life.Life) error) *MockApplicationStateSetUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitPassword mocks base method.
func (m *MockApplicationState) SetUnitPassword(arg0 domain.AtomicContext, arg1 unit.UUID, arg2 application0.PasswordInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitPassword", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitPassword indicates an expected call of SetUnitPassword.
func (mr *MockApplicationStateMockRecorder) SetUnitPassword(arg0, arg1, arg2 any) *MockApplicationStateSetUnitPasswordCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitPassword", reflect.TypeOf((*MockApplicationState)(nil).SetUnitPassword), arg0, arg1, arg2)
	return &MockApplicationStateSetUnitPasswordCall{Call: call}
}

// MockApplicationStateSetUnitPasswordCall wrap *gomock.Call
type MockApplicationStateSetUnitPasswordCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetUnitPasswordCall) Return(arg0 error) *MockApplicationStateSetUnitPasswordCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetUnitPasswordCall) Do(f func(domain.AtomicContext, unit.UUID, application0.PasswordInfo) error) *MockApplicationStateSetUnitPasswordCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetUnitPasswordCall) DoAndReturn(f func(domain.AtomicContext, unit.UUID, application0.PasswordInfo) error) *MockApplicationStateSetUnitPasswordCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitWorkloadStatus mocks base method.
func (m *MockApplicationState) SetUnitWorkloadStatus(arg0 domain.AtomicContext, arg1 unit.UUID, arg2 application0.UnitWorkloadStatusInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitWorkloadStatus", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitWorkloadStatus indicates an expected call of SetUnitWorkloadStatus.
func (mr *MockApplicationStateMockRecorder) SetUnitWorkloadStatus(arg0, arg1, arg2 any) *MockApplicationStateSetUnitWorkloadStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitWorkloadStatus", reflect.TypeOf((*MockApplicationState)(nil).SetUnitWorkloadStatus), arg0, arg1, arg2)
	return &MockApplicationStateSetUnitWorkloadStatusCall{Call: call}
}

// MockApplicationStateSetUnitWorkloadStatusCall wrap *gomock.Call
type MockApplicationStateSetUnitWorkloadStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateSetUnitWorkloadStatusCall) Return(arg0 error) *MockApplicationStateSetUnitWorkloadStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateSetUnitWorkloadStatusCall) Do(f func(domain.AtomicContext, unit.UUID, application0.UnitWorkloadStatusInfo) error) *MockApplicationStateSetUnitWorkloadStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateSetUnitWorkloadStatusCall) DoAndReturn(f func(domain.AtomicContext, unit.UUID, application0.UnitWorkloadStatusInfo) error) *MockApplicationStateSetUnitWorkloadStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageDefaults mocks base method.
func (m *MockApplicationState) StorageDefaults(arg0 context.Context) (storage.StorageDefaults, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageDefaults", arg0)
	ret0, _ := ret[0].(storage.StorageDefaults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageDefaults indicates an expected call of StorageDefaults.
func (mr *MockApplicationStateMockRecorder) StorageDefaults(arg0 any) *MockApplicationStateStorageDefaultsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageDefaults", reflect.TypeOf((*MockApplicationState)(nil).StorageDefaults), arg0)
	return &MockApplicationStateStorageDefaultsCall{Call: call}
}

// MockApplicationStateStorageDefaultsCall wrap *gomock.Call
type MockApplicationStateStorageDefaultsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateStorageDefaultsCall) Return(arg0 storage.StorageDefaults, arg1 error) *MockApplicationStateStorageDefaultsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateStorageDefaultsCall) Do(f func(context.Context) (storage.StorageDefaults, error)) *MockApplicationStateStorageDefaultsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateStorageDefaultsCall) DoAndReturn(f func(context.Context) (storage.StorageDefaults, error)) *MockApplicationStateStorageDefaultsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateUnitContainer mocks base method.
func (m *MockApplicationState) UpdateUnitContainer(arg0 domain.AtomicContext, arg1 unit.Name, arg2 *application0.CloudContainer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUnitContainer", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateUnitContainer indicates an expected call of UpdateUnitContainer.
func (mr *MockApplicationStateMockRecorder) UpdateUnitContainer(arg0, arg1, arg2 any) *MockApplicationStateUpdateUnitContainerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUnitContainer", reflect.TypeOf((*MockApplicationState)(nil).UpdateUnitContainer), arg0, arg1, arg2)
	return &MockApplicationStateUpdateUnitContainerCall{Call: call}
}

// MockApplicationStateUpdateUnitContainerCall wrap *gomock.Call
type MockApplicationStateUpdateUnitContainerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateUpdateUnitContainerCall) Return(arg0 error) *MockApplicationStateUpdateUnitContainerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateUpdateUnitContainerCall) Do(f func(domain.AtomicContext, unit.Name, *application0.CloudContainer) error) *MockApplicationStateUpdateUnitContainerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateUpdateUnitContainerCall) DoAndReturn(f func(domain.AtomicContext, unit.Name, *application0.CloudContainer) error) *MockApplicationStateUpdateUnitContainerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertCloudService mocks base method.
func (m *MockApplicationState) UpsertCloudService(arg0 context.Context, arg1, arg2 string, arg3 network.SpaceAddresses) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertCloudService", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertCloudService indicates an expected call of UpsertCloudService.
func (mr *MockApplicationStateMockRecorder) UpsertCloudService(arg0, arg1, arg2, arg3 any) *MockApplicationStateUpsertCloudServiceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertCloudService", reflect.TypeOf((*MockApplicationState)(nil).UpsertCloudService), arg0, arg1, arg2, arg3)
	return &MockApplicationStateUpsertCloudServiceCall{Call: call}
}

// MockApplicationStateUpsertCloudServiceCall wrap *gomock.Call
type MockApplicationStateUpsertCloudServiceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockApplicationStateUpsertCloudServiceCall) Return(arg0 error) *MockApplicationStateUpsertCloudServiceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockApplicationStateUpsertCloudServiceCall) Do(f func(context.Context, string, string, network.SpaceAddresses) error) *MockApplicationStateUpsertCloudServiceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockApplicationStateUpsertCloudServiceCall) DoAndReturn(f func(context.Context, string, string, network.SpaceAddresses) error) *MockApplicationStateUpsertCloudServiceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharmState is a mock of CharmState interface.
type MockCharmState struct {
	ctrl     *gomock.Controller
	recorder *MockCharmStateMockRecorder
}

// MockCharmStateMockRecorder is the mock recorder for MockCharmState.
type MockCharmStateMockRecorder struct {
	mock *MockCharmState
}

// NewMockCharmState creates a new mock instance.
func NewMockCharmState(ctrl *gomock.Controller) *MockCharmState {
	mock := &MockCharmState{ctrl: ctrl}
	mock.recorder = &MockCharmStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharmState) EXPECT() *MockCharmStateMockRecorder {
	return m.recorder
}

// DeleteCharm mocks base method.
func (m *MockCharmState) DeleteCharm(arg0 context.Context, arg1 charm.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteCharm", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteCharm indicates an expected call of DeleteCharm.
func (mr *MockCharmStateMockRecorder) DeleteCharm(arg0, arg1 any) *MockCharmStateDeleteCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCharm", reflect.TypeOf((*MockCharmState)(nil).DeleteCharm), arg0, arg1)
	return &MockCharmStateDeleteCharmCall{Call: call}
}

// MockCharmStateDeleteCharmCall wrap *gomock.Call
type MockCharmStateDeleteCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateDeleteCharmCall) Return(arg0 error) *MockCharmStateDeleteCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateDeleteCharmCall) Do(f func(context.Context, charm.ID) error) *MockCharmStateDeleteCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateDeleteCharmCall) DoAndReturn(f func(context.Context, charm.ID) error) *MockCharmStateDeleteCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharm mocks base method.
func (m *MockCharmState) GetCharm(arg0 context.Context, arg1 charm.ID) (charm0.Charm, charm0.CharmOrigin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharm", arg0, arg1)
	ret0, _ := ret[0].(charm0.Charm)
	ret1, _ := ret[1].(charm0.CharmOrigin)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharm indicates an expected call of GetCharm.
func (mr *MockCharmStateMockRecorder) GetCharm(arg0, arg1 any) *MockCharmStateGetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharm", reflect.TypeOf((*MockCharmState)(nil).GetCharm), arg0, arg1)
	return &MockCharmStateGetCharmCall{Call: call}
}

// MockCharmStateGetCharmCall wrap *gomock.Call
type MockCharmStateGetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmCall) Return(arg0 charm0.Charm, arg1 charm0.CharmOrigin, arg2 error) *MockCharmStateGetCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmCall) Do(f func(context.Context, charm.ID) (charm0.Charm, charm0.CharmOrigin, error)) *MockCharmStateGetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Charm, charm0.CharmOrigin, error)) *MockCharmStateGetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmActions mocks base method.
func (m *MockCharmState) GetCharmActions(arg0 context.Context, arg1 charm.ID) (charm0.Actions, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmActions", arg0, arg1)
	ret0, _ := ret[0].(charm0.Actions)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmActions indicates an expected call of GetCharmActions.
func (mr *MockCharmStateMockRecorder) GetCharmActions(arg0, arg1 any) *MockCharmStateGetCharmActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmActions", reflect.TypeOf((*MockCharmState)(nil).GetCharmActions), arg0, arg1)
	return &MockCharmStateGetCharmActionsCall{Call: call}
}

// MockCharmStateGetCharmActionsCall wrap *gomock.Call
type MockCharmStateGetCharmActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmActionsCall) Return(arg0 charm0.Actions, arg1 error) *MockCharmStateGetCharmActionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmActionsCall) Do(f func(context.Context, charm.ID) (charm0.Actions, error)) *MockCharmStateGetCharmActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmActionsCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Actions, error)) *MockCharmStateGetCharmActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmArchivePath mocks base method.
func (m *MockCharmState) GetCharmArchivePath(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmArchivePath", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmArchivePath indicates an expected call of GetCharmArchivePath.
func (mr *MockCharmStateMockRecorder) GetCharmArchivePath(arg0, arg1 any) *MockCharmStateGetCharmArchivePathCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmArchivePath", reflect.TypeOf((*MockCharmState)(nil).GetCharmArchivePath), arg0, arg1)
	return &MockCharmStateGetCharmArchivePathCall{Call: call}
}

// MockCharmStateGetCharmArchivePathCall wrap *gomock.Call
type MockCharmStateGetCharmArchivePathCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmArchivePathCall) Return(arg0 string, arg1 error) *MockCharmStateGetCharmArchivePathCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmArchivePathCall) Do(f func(context.Context, charm.ID) (string, error)) *MockCharmStateGetCharmArchivePathCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmArchivePathCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockCharmStateGetCharmArchivePathCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmConfig mocks base method.
func (m *MockCharmState) GetCharmConfig(arg0 context.Context, arg1 charm.ID) (charm0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmConfig", arg0, arg1)
	ret0, _ := ret[0].(charm0.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmConfig indicates an expected call of GetCharmConfig.
func (mr *MockCharmStateMockRecorder) GetCharmConfig(arg0, arg1 any) *MockCharmStateGetCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmConfig", reflect.TypeOf((*MockCharmState)(nil).GetCharmConfig), arg0, arg1)
	return &MockCharmStateGetCharmConfigCall{Call: call}
}

// MockCharmStateGetCharmConfigCall wrap *gomock.Call
type MockCharmStateGetCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmConfigCall) Return(arg0 charm0.Config, arg1 error) *MockCharmStateGetCharmConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmConfigCall) Do(f func(context.Context, charm.ID) (charm0.Config, error)) *MockCharmStateGetCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmConfigCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Config, error)) *MockCharmStateGetCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmIDByRevision mocks base method.
func (m *MockCharmState) GetCharmIDByRevision(arg0 context.Context, arg1 string, arg2 int) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmIDByRevision", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmIDByRevision indicates an expected call of GetCharmIDByRevision.
func (mr *MockCharmStateMockRecorder) GetCharmIDByRevision(arg0, arg1, arg2 any) *MockCharmStateGetCharmIDByRevisionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmIDByRevision", reflect.TypeOf((*MockCharmState)(nil).GetCharmIDByRevision), arg0, arg1, arg2)
	return &MockCharmStateGetCharmIDByRevisionCall{Call: call}
}

// MockCharmStateGetCharmIDByRevisionCall wrap *gomock.Call
type MockCharmStateGetCharmIDByRevisionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmIDByRevisionCall) Return(arg0 charm.ID, arg1 error) *MockCharmStateGetCharmIDByRevisionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmIDByRevisionCall) Do(f func(context.Context, string, int) (charm.ID, error)) *MockCharmStateGetCharmIDByRevisionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmIDByRevisionCall) DoAndReturn(f func(context.Context, string, int) (charm.ID, error)) *MockCharmStateGetCharmIDByRevisionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmLXDProfile mocks base method.
func (m *MockCharmState) GetCharmLXDProfile(arg0 context.Context, arg1 charm.ID) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmLXDProfile", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmLXDProfile indicates an expected call of GetCharmLXDProfile.
func (mr *MockCharmStateMockRecorder) GetCharmLXDProfile(arg0, arg1 any) *MockCharmStateGetCharmLXDProfileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmLXDProfile", reflect.TypeOf((*MockCharmState)(nil).GetCharmLXDProfile), arg0, arg1)
	return &MockCharmStateGetCharmLXDProfileCall{Call: call}
}

// MockCharmStateGetCharmLXDProfileCall wrap *gomock.Call
type MockCharmStateGetCharmLXDProfileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmLXDProfileCall) Return(arg0 []byte, arg1 int, arg2 error) *MockCharmStateGetCharmLXDProfileCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmLXDProfileCall) Do(f func(context.Context, charm.ID) ([]byte, int, error)) *MockCharmStateGetCharmLXDProfileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmLXDProfileCall) DoAndReturn(f func(context.Context, charm.ID) ([]byte, int, error)) *MockCharmStateGetCharmLXDProfileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmManifest mocks base method.
func (m *MockCharmState) GetCharmManifest(arg0 context.Context, arg1 charm.ID) (charm0.Manifest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmManifest", arg0, arg1)
	ret0, _ := ret[0].(charm0.Manifest)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmManifest indicates an expected call of GetCharmManifest.
func (mr *MockCharmStateMockRecorder) GetCharmManifest(arg0, arg1 any) *MockCharmStateGetCharmManifestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmManifest", reflect.TypeOf((*MockCharmState)(nil).GetCharmManifest), arg0, arg1)
	return &MockCharmStateGetCharmManifestCall{Call: call}
}

// MockCharmStateGetCharmManifestCall wrap *gomock.Call
type MockCharmStateGetCharmManifestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmManifestCall) Return(arg0 charm0.Manifest, arg1 error) *MockCharmStateGetCharmManifestCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmManifestCall) Do(f func(context.Context, charm.ID) (charm0.Manifest, error)) *MockCharmStateGetCharmManifestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmManifestCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Manifest, error)) *MockCharmStateGetCharmManifestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadata mocks base method.
func (m *MockCharmState) GetCharmMetadata(arg0 context.Context, arg1 charm.ID) (charm0.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadata", arg0, arg1)
	ret0, _ := ret[0].(charm0.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadata indicates an expected call of GetCharmMetadata.
func (mr *MockCharmStateMockRecorder) GetCharmMetadata(arg0, arg1 any) *MockCharmStateGetCharmMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadata", reflect.TypeOf((*MockCharmState)(nil).GetCharmMetadata), arg0, arg1)
	return &MockCharmStateGetCharmMetadataCall{Call: call}
}

// MockCharmStateGetCharmMetadataCall wrap *gomock.Call
type MockCharmStateGetCharmMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmMetadataCall) Return(arg0 charm0.Metadata, arg1 error) *MockCharmStateGetCharmMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmMetadataCall) Do(f func(context.Context, charm.ID) (charm0.Metadata, error)) *MockCharmStateGetCharmMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmMetadataCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Metadata, error)) *MockCharmStateGetCharmMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataDescription mocks base method.
func (m *MockCharmState) GetCharmMetadataDescription(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataDescription", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataDescription indicates an expected call of GetCharmMetadataDescription.
func (mr *MockCharmStateMockRecorder) GetCharmMetadataDescription(arg0, arg1 any) *MockCharmStateGetCharmMetadataDescriptionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataDescription", reflect.TypeOf((*MockCharmState)(nil).GetCharmMetadataDescription), arg0, arg1)
	return &MockCharmStateGetCharmMetadataDescriptionCall{Call: call}
}

// MockCharmStateGetCharmMetadataDescriptionCall wrap *gomock.Call
type MockCharmStateGetCharmMetadataDescriptionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmMetadataDescriptionCall) Return(arg0 string, arg1 error) *MockCharmStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmMetadataDescriptionCall) Do(f func(context.Context, charm.ID) (string, error)) *MockCharmStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmMetadataDescriptionCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockCharmStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataName mocks base method.
func (m *MockCharmState) GetCharmMetadataName(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataName", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataName indicates an expected call of GetCharmMetadataName.
func (mr *MockCharmStateMockRecorder) GetCharmMetadataName(arg0, arg1 any) *MockCharmStateGetCharmMetadataNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataName", reflect.TypeOf((*MockCharmState)(nil).GetCharmMetadataName), arg0, arg1)
	return &MockCharmStateGetCharmMetadataNameCall{Call: call}
}

// MockCharmStateGetCharmMetadataNameCall wrap *gomock.Call
type MockCharmStateGetCharmMetadataNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateGetCharmMetadataNameCall) Return(arg0 string, arg1 error) *MockCharmStateGetCharmMetadataNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateGetCharmMetadataNameCall) Do(f func(context.Context, charm.ID) (string, error)) *MockCharmStateGetCharmMetadataNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateGetCharmMetadataNameCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockCharmStateGetCharmMetadataNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsCharmAvailable mocks base method.
func (m *MockCharmState) IsCharmAvailable(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCharmAvailable", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCharmAvailable indicates an expected call of IsCharmAvailable.
func (mr *MockCharmStateMockRecorder) IsCharmAvailable(arg0, arg1 any) *MockCharmStateIsCharmAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCharmAvailable", reflect.TypeOf((*MockCharmState)(nil).IsCharmAvailable), arg0, arg1)
	return &MockCharmStateIsCharmAvailableCall{Call: call}
}

// MockCharmStateIsCharmAvailableCall wrap *gomock.Call
type MockCharmStateIsCharmAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateIsCharmAvailableCall) Return(arg0 bool, arg1 error) *MockCharmStateIsCharmAvailableCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateIsCharmAvailableCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateIsCharmAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateIsCharmAvailableCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateIsCharmAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsControllerCharm mocks base method.
func (m *MockCharmState) IsControllerCharm(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsControllerCharm", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsControllerCharm indicates an expected call of IsControllerCharm.
func (mr *MockCharmStateMockRecorder) IsControllerCharm(arg0, arg1 any) *MockCharmStateIsControllerCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsControllerCharm", reflect.TypeOf((*MockCharmState)(nil).IsControllerCharm), arg0, arg1)
	return &MockCharmStateIsControllerCharmCall{Call: call}
}

// MockCharmStateIsControllerCharmCall wrap *gomock.Call
type MockCharmStateIsControllerCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateIsControllerCharmCall) Return(arg0 bool, arg1 error) *MockCharmStateIsControllerCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateIsControllerCharmCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateIsControllerCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateIsControllerCharmCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateIsControllerCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsSubordinateCharm mocks base method.
func (m *MockCharmState) IsSubordinateCharm(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSubordinateCharm", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsSubordinateCharm indicates an expected call of IsSubordinateCharm.
func (mr *MockCharmStateMockRecorder) IsSubordinateCharm(arg0, arg1 any) *MockCharmStateIsSubordinateCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSubordinateCharm", reflect.TypeOf((*MockCharmState)(nil).IsSubordinateCharm), arg0, arg1)
	return &MockCharmStateIsSubordinateCharmCall{Call: call}
}

// MockCharmStateIsSubordinateCharmCall wrap *gomock.Call
type MockCharmStateIsSubordinateCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateIsSubordinateCharmCall) Return(arg0 bool, arg1 error) *MockCharmStateIsSubordinateCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateIsSubordinateCharmCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateIsSubordinateCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateIsSubordinateCharmCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateIsSubordinateCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCharmsWithOrigin mocks base method.
func (m *MockCharmState) ListCharmsWithOrigin(arg0 context.Context) ([]charm0.CharmWithOrigin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharmsWithOrigin", arg0)
	ret0, _ := ret[0].([]charm0.CharmWithOrigin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharmsWithOrigin indicates an expected call of ListCharmsWithOrigin.
func (mr *MockCharmStateMockRecorder) ListCharmsWithOrigin(arg0 any) *MockCharmStateListCharmsWithOriginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharmsWithOrigin", reflect.TypeOf((*MockCharmState)(nil).ListCharmsWithOrigin), arg0)
	return &MockCharmStateListCharmsWithOriginCall{Call: call}
}

// MockCharmStateListCharmsWithOriginCall wrap *gomock.Call
type MockCharmStateListCharmsWithOriginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateListCharmsWithOriginCall) Return(arg0 []charm0.CharmWithOrigin, arg1 error) *MockCharmStateListCharmsWithOriginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateListCharmsWithOriginCall) Do(f func(context.Context) ([]charm0.CharmWithOrigin, error)) *MockCharmStateListCharmsWithOriginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateListCharmsWithOriginCall) DoAndReturn(f func(context.Context) ([]charm0.CharmWithOrigin, error)) *MockCharmStateListCharmsWithOriginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCharmsWithOriginByNames mocks base method.
func (m *MockCharmState) ListCharmsWithOriginByNames(arg0 context.Context, arg1 []string) ([]charm0.CharmWithOrigin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharmsWithOriginByNames", arg0, arg1)
	ret0, _ := ret[0].([]charm0.CharmWithOrigin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharmsWithOriginByNames indicates an expected call of ListCharmsWithOriginByNames.
func (mr *MockCharmStateMockRecorder) ListCharmsWithOriginByNames(arg0, arg1 any) *MockCharmStateListCharmsWithOriginByNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharmsWithOriginByNames", reflect.TypeOf((*MockCharmState)(nil).ListCharmsWithOriginByNames), arg0, arg1)
	return &MockCharmStateListCharmsWithOriginByNamesCall{Call: call}
}

// MockCharmStateListCharmsWithOriginByNamesCall wrap *gomock.Call
type MockCharmStateListCharmsWithOriginByNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateListCharmsWithOriginByNamesCall) Return(arg0 []charm0.CharmWithOrigin, arg1 error) *MockCharmStateListCharmsWithOriginByNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateListCharmsWithOriginByNamesCall) Do(f func(context.Context, []string) ([]charm0.CharmWithOrigin, error)) *MockCharmStateListCharmsWithOriginByNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateListCharmsWithOriginByNamesCall) DoAndReturn(f func(context.Context, []string) ([]charm0.CharmWithOrigin, error)) *MockCharmStateListCharmsWithOriginByNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReserveCharmRevision mocks base method.
func (m *MockCharmState) ReserveCharmRevision(arg0 context.Context, arg1 charm.ID, arg2 int) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReserveCharmRevision", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReserveCharmRevision indicates an expected call of ReserveCharmRevision.
func (mr *MockCharmStateMockRecorder) ReserveCharmRevision(arg0, arg1, arg2 any) *MockCharmStateReserveCharmRevisionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReserveCharmRevision", reflect.TypeOf((*MockCharmState)(nil).ReserveCharmRevision), arg0, arg1, arg2)
	return &MockCharmStateReserveCharmRevisionCall{Call: call}
}

// MockCharmStateReserveCharmRevisionCall wrap *gomock.Call
type MockCharmStateReserveCharmRevisionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateReserveCharmRevisionCall) Return(arg0 charm.ID, arg1 error) *MockCharmStateReserveCharmRevisionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateReserveCharmRevisionCall) Do(f func(context.Context, charm.ID, int) (charm.ID, error)) *MockCharmStateReserveCharmRevisionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateReserveCharmRevisionCall) DoAndReturn(f func(context.Context, charm.ID, int) (charm.ID, error)) *MockCharmStateReserveCharmRevisionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharm mocks base method.
func (m *MockCharmState) SetCharm(arg0 context.Context, arg1 charm0.Charm, arg2 charm0.SetStateArgs) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharm", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetCharm indicates an expected call of SetCharm.
func (mr *MockCharmStateMockRecorder) SetCharm(arg0, arg1, arg2 any) *MockCharmStateSetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharm", reflect.TypeOf((*MockCharmState)(nil).SetCharm), arg0, arg1, arg2)
	return &MockCharmStateSetCharmCall{Call: call}
}

// MockCharmStateSetCharmCall wrap *gomock.Call
type MockCharmStateSetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateSetCharmCall) Return(arg0 charm.ID, arg1 error) *MockCharmStateSetCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateSetCharmCall) Do(f func(context.Context, charm0.Charm, charm0.SetStateArgs) (charm.ID, error)) *MockCharmStateSetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateSetCharmCall) DoAndReturn(f func(context.Context, charm0.Charm, charm0.SetStateArgs) (charm.ID, error)) *MockCharmStateSetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharmAvailable mocks base method.
func (m *MockCharmState) SetCharmAvailable(arg0 context.Context, arg1 charm.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharmAvailable", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCharmAvailable indicates an expected call of SetCharmAvailable.
func (mr *MockCharmStateMockRecorder) SetCharmAvailable(arg0, arg1 any) *MockCharmStateSetCharmAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharmAvailable", reflect.TypeOf((*MockCharmState)(nil).SetCharmAvailable), arg0, arg1)
	return &MockCharmStateSetCharmAvailableCall{Call: call}
}

// MockCharmStateSetCharmAvailableCall wrap *gomock.Call
type MockCharmStateSetCharmAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateSetCharmAvailableCall) Return(arg0 error) *MockCharmStateSetCharmAvailableCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateSetCharmAvailableCall) Do(f func(context.Context, charm.ID) error) *MockCharmStateSetCharmAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateSetCharmAvailableCall) DoAndReturn(f func(context.Context, charm.ID) error) *MockCharmStateSetCharmAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SupportsContainers mocks base method.
func (m *MockCharmState) SupportsContainers(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportsContainers", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SupportsContainers indicates an expected call of SupportsContainers.
func (mr *MockCharmStateMockRecorder) SupportsContainers(arg0, arg1 any) *MockCharmStateSupportsContainersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportsContainers", reflect.TypeOf((*MockCharmState)(nil).SupportsContainers), arg0, arg1)
	return &MockCharmStateSupportsContainersCall{Call: call}
}

// MockCharmStateSupportsContainersCall wrap *gomock.Call
type MockCharmStateSupportsContainersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStateSupportsContainersCall) Return(arg0 bool, arg1 error) *MockCharmStateSupportsContainersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStateSupportsContainersCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateSupportsContainersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStateSupportsContainersCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockCharmStateSupportsContainersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDeleteSecretState is a mock of DeleteSecretState interface.
type MockDeleteSecretState struct {
	ctrl     *gomock.Controller
	recorder *MockDeleteSecretStateMockRecorder
}

// MockDeleteSecretStateMockRecorder is the mock recorder for MockDeleteSecretState.
type MockDeleteSecretStateMockRecorder struct {
	mock *MockDeleteSecretState
}

// NewMockDeleteSecretState creates a new mock instance.
func NewMockDeleteSecretState(ctrl *gomock.Controller) *MockDeleteSecretState {
	mock := &MockDeleteSecretState{ctrl: ctrl}
	mock.recorder = &MockDeleteSecretStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeleteSecretState) EXPECT() *MockDeleteSecretStateMockRecorder {
	return m.recorder
}

// DeleteSecret mocks base method.
func (m *MockDeleteSecretState) DeleteSecret(arg0 domain.AtomicContext, arg1 *secrets.URI, arg2 []int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteSecret", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteSecret indicates an expected call of DeleteSecret.
func (mr *MockDeleteSecretStateMockRecorder) DeleteSecret(arg0, arg1, arg2 any) *MockDeleteSecretStateDeleteSecretCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSecret", reflect.TypeOf((*MockDeleteSecretState)(nil).DeleteSecret), arg0, arg1, arg2)
	return &MockDeleteSecretStateDeleteSecretCall{Call: call}
}

// MockDeleteSecretStateDeleteSecretCall wrap *gomock.Call
type MockDeleteSecretStateDeleteSecretCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDeleteSecretStateDeleteSecretCall) Return(arg0 error) *MockDeleteSecretStateDeleteSecretCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDeleteSecretStateDeleteSecretCall) Do(f func(domain.AtomicContext, *secrets.URI, []int) error) *MockDeleteSecretStateDeleteSecretCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDeleteSecretStateDeleteSecretCall) DoAndReturn(f func(domain.AtomicContext, *secrets.URI, []int) error) *MockDeleteSecretStateDeleteSecretCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockResourceState is a mock of ResourceState interface.
type MockResourceState struct {
	ctrl     *gomock.Controller
	recorder *MockResourceStateMockRecorder
}

// MockResourceStateMockRecorder is the mock recorder for MockResourceState.
type MockResourceStateMockRecorder struct {
	mock *MockResourceState
}

// NewMockResourceState creates a new mock instance.
func NewMockResourceState(ctrl *gomock.Controller) *MockResourceState {
	mock := &MockResourceState{ctrl: ctrl}
	mock.recorder = &MockResourceStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResourceState) EXPECT() *MockResourceStateMockRecorder {
	return m.recorder
}

// GetApplicationResourceID mocks base method.
func (m *MockResourceState) GetApplicationResourceID(arg0 context.Context, arg1 resource.GetApplicationResourceIDArgs) (resources.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationResourceID", arg0, arg1)
	ret0, _ := ret[0].(resources.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationResourceID indicates an expected call of GetApplicationResourceID.
func (mr *MockResourceStateMockRecorder) GetApplicationResourceID(arg0, arg1 any) *MockResourceStateGetApplicationResourceIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationResourceID", reflect.TypeOf((*MockResourceState)(nil).GetApplicationResourceID), arg0, arg1)
	return &MockResourceStateGetApplicationResourceIDCall{Call: call}
}

// MockResourceStateGetApplicationResourceIDCall wrap *gomock.Call
type MockResourceStateGetApplicationResourceIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateGetApplicationResourceIDCall) Return(arg0 resources.ID, arg1 error) *MockResourceStateGetApplicationResourceIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateGetApplicationResourceIDCall) Do(f func(context.Context, resource.GetApplicationResourceIDArgs) (resources.ID, error)) *MockResourceStateGetApplicationResourceIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateGetApplicationResourceIDCall) DoAndReturn(f func(context.Context, resource.GetApplicationResourceIDArgs) (resources.ID, error)) *MockResourceStateGetApplicationResourceIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetResource mocks base method.
func (m *MockResourceState) GetResource(arg0 context.Context, arg1 resources.ID) (resource.Resource, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetResource", arg0, arg1)
	ret0, _ := ret[0].(resource.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetResource indicates an expected call of GetResource.
func (mr *MockResourceStateMockRecorder) GetResource(arg0, arg1 any) *MockResourceStateGetResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetResource", reflect.TypeOf((*MockResourceState)(nil).GetResource), arg0, arg1)
	return &MockResourceStateGetResourceCall{Call: call}
}

// MockResourceStateGetResourceCall wrap *gomock.Call
type MockResourceStateGetResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateGetResourceCall) Return(arg0 resource.Resource, arg1 error) *MockResourceStateGetResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateGetResourceCall) Do(f func(context.Context, resources.ID) (resource.Resource, error)) *MockResourceStateGetResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateGetResourceCall) DoAndReturn(f func(context.Context, resources.ID) (resource.Resource, error)) *MockResourceStateGetResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListResources mocks base method.
func (m *MockResourceState) ListResources(arg0 context.Context, arg1 application.ID) (resource.ApplicationResources, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListResources", arg0, arg1)
	ret0, _ := ret[0].(resource.ApplicationResources)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListResources indicates an expected call of ListResources.
func (mr *MockResourceStateMockRecorder) ListResources(arg0, arg1 any) *MockResourceStateListResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListResources", reflect.TypeOf((*MockResourceState)(nil).ListResources), arg0, arg1)
	return &MockResourceStateListResourcesCall{Call: call}
}

// MockResourceStateListResourcesCall wrap *gomock.Call
type MockResourceStateListResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateListResourcesCall) Return(arg0 resource.ApplicationResources, arg1 error) *MockResourceStateListResourcesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateListResourcesCall) Do(f func(context.Context, application.ID) (resource.ApplicationResources, error)) *MockResourceStateListResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateListResourcesCall) DoAndReturn(f func(context.Context, application.ID) (resource.ApplicationResources, error)) *MockResourceStateListResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenApplicationResource mocks base method.
func (m *MockResourceState) OpenApplicationResource(arg0 context.Context, arg1 resources.ID) (resource.Resource, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenApplicationResource", arg0, arg1)
	ret0, _ := ret[0].(resource.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenApplicationResource indicates an expected call of OpenApplicationResource.
func (mr *MockResourceStateMockRecorder) OpenApplicationResource(arg0, arg1 any) *MockResourceStateOpenApplicationResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenApplicationResource", reflect.TypeOf((*MockResourceState)(nil).OpenApplicationResource), arg0, arg1)
	return &MockResourceStateOpenApplicationResourceCall{Call: call}
}

// MockResourceStateOpenApplicationResourceCall wrap *gomock.Call
type MockResourceStateOpenApplicationResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateOpenApplicationResourceCall) Return(arg0 resource.Resource, arg1 error) *MockResourceStateOpenApplicationResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateOpenApplicationResourceCall) Do(f func(context.Context, resources.ID) (resource.Resource, error)) *MockResourceStateOpenApplicationResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateOpenApplicationResourceCall) DoAndReturn(f func(context.Context, resources.ID) (resource.Resource, error)) *MockResourceStateOpenApplicationResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenUnitResource mocks base method.
func (m *MockResourceState) OpenUnitResource(arg0 context.Context, arg1 resources.ID, arg2 unit.UUID) (resource.Resource, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenUnitResource", arg0, arg1, arg2)
	ret0, _ := ret[0].(resource.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenUnitResource indicates an expected call of OpenUnitResource.
func (mr *MockResourceStateMockRecorder) OpenUnitResource(arg0, arg1, arg2 any) *MockResourceStateOpenUnitResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenUnitResource", reflect.TypeOf((*MockResourceState)(nil).OpenUnitResource), arg0, arg1, arg2)
	return &MockResourceStateOpenUnitResourceCall{Call: call}
}

// MockResourceStateOpenUnitResourceCall wrap *gomock.Call
type MockResourceStateOpenUnitResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateOpenUnitResourceCall) Return(arg0 resource.Resource, arg1 error) *MockResourceStateOpenUnitResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateOpenUnitResourceCall) Do(f func(context.Context, resources.ID, unit.UUID) (resource.Resource, error)) *MockResourceStateOpenUnitResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateOpenUnitResourceCall) DoAndReturn(f func(context.Context, resources.ID, unit.UUID) (resource.Resource, error)) *MockResourceStateOpenUnitResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetRepositoryResources mocks base method.
func (m *MockResourceState) SetRepositoryResources(arg0 context.Context, arg1 resource.SetRepositoryResourcesArgs) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRepositoryResources", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRepositoryResources indicates an expected call of SetRepositoryResources.
func (mr *MockResourceStateMockRecorder) SetRepositoryResources(arg0, arg1 any) *MockResourceStateSetRepositoryResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRepositoryResources", reflect.TypeOf((*MockResourceState)(nil).SetRepositoryResources), arg0, arg1)
	return &MockResourceStateSetRepositoryResourcesCall{Call: call}
}

// MockResourceStateSetRepositoryResourcesCall wrap *gomock.Call
type MockResourceStateSetRepositoryResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateSetRepositoryResourcesCall) Return(arg0 error) *MockResourceStateSetRepositoryResourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateSetRepositoryResourcesCall) Do(f func(context.Context, resource.SetRepositoryResourcesArgs) error) *MockResourceStateSetRepositoryResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateSetRepositoryResourcesCall) DoAndReturn(f func(context.Context, resource.SetRepositoryResourcesArgs) error) *MockResourceStateSetRepositoryResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetResource mocks base method.
func (m *MockResourceState) SetResource(arg0 context.Context, arg1 resource.SetResourceArgs) (resource.Resource, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetResource", arg0, arg1)
	ret0, _ := ret[0].(resource.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetResource indicates an expected call of SetResource.
func (mr *MockResourceStateMockRecorder) SetResource(arg0, arg1 any) *MockResourceStateSetResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetResource", reflect.TypeOf((*MockResourceState)(nil).SetResource), arg0, arg1)
	return &MockResourceStateSetResourceCall{Call: call}
}

// MockResourceStateSetResourceCall wrap *gomock.Call
type MockResourceStateSetResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateSetResourceCall) Return(arg0 resource.Resource, arg1 error) *MockResourceStateSetResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateSetResourceCall) Do(f func(context.Context, resource.SetResourceArgs) (resource.Resource, error)) *MockResourceStateSetResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateSetResourceCall) DoAndReturn(f func(context.Context, resource.SetResourceArgs) (resource.Resource, error)) *MockResourceStateSetResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitResource mocks base method.
func (m *MockResourceState) SetUnitResource(arg0 context.Context, arg1 resource.SetUnitResourceArgs) (resource.SetUnitResourceResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitResource", arg0, arg1)
	ret0, _ := ret[0].(resource.SetUnitResourceResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetUnitResource indicates an expected call of SetUnitResource.
func (mr *MockResourceStateMockRecorder) SetUnitResource(arg0, arg1 any) *MockResourceStateSetUnitResourceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitResource", reflect.TypeOf((*MockResourceState)(nil).SetUnitResource), arg0, arg1)
	return &MockResourceStateSetUnitResourceCall{Call: call}
}

// MockResourceStateSetUnitResourceCall wrap *gomock.Call
type MockResourceStateSetUnitResourceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResourceStateSetUnitResourceCall) Return(arg0 resource.SetUnitResourceResult, arg1 error) *MockResourceStateSetUnitResourceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResourceStateSetUnitResourceCall) Do(f func(context.Context, resource.SetUnitResourceArgs) (resource.SetUnitResourceResult, error)) *MockResourceStateSetUnitResourceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResourceStateSetUnitResourceCall) DoAndReturn(f func(context.Context, resource.SetUnitResourceArgs) (resource.SetUnitResourceResult, error)) *MockResourceStateSetUnitResourceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockWatcherFactory is a mock of WatcherFactory interface.
type MockWatcherFactory struct {
	ctrl     *gomock.Controller
	recorder *MockWatcherFactoryMockRecorder
}

// MockWatcherFactoryMockRecorder is the mock recorder for MockWatcherFactory.
type MockWatcherFactoryMockRecorder struct {
	mock *MockWatcherFactory
}

// NewMockWatcherFactory creates a new mock instance.
func NewMockWatcherFactory(ctrl *gomock.Controller) *MockWatcherFactory {
	mock := &MockWatcherFactory{ctrl: ctrl}
	mock.recorder = &MockWatcherFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWatcherFactory) EXPECT() *MockWatcherFactoryMockRecorder {
	return m.recorder
}

// NewNamespaceMapperWatcher mocks base method.
func (m *MockWatcherFactory) NewNamespaceMapperWatcher(arg0 string, arg1 changestream.ChangeType, arg2 eventsource.NamespaceQuery, arg3 eventsource.Mapper) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewNamespaceMapperWatcher", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewNamespaceMapperWatcher indicates an expected call of NewNamespaceMapperWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewNamespaceMapperWatcher(arg0, arg1, arg2, arg3 any) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewNamespaceMapperWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewNamespaceMapperWatcher), arg0, arg1, arg2, arg3)
	return &MockWatcherFactoryNewNamespaceMapperWatcherCall{Call: call}
}

// MockWatcherFactoryNewNamespaceMapperWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewNamespaceMapperWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) Do(f func(string, changestream.ChangeType, eventsource.NamespaceQuery, eventsource.Mapper) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) DoAndReturn(f func(string, changestream.ChangeType, eventsource.NamespaceQuery, eventsource.Mapper) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewUUIDsWatcher mocks base method.
func (m *MockWatcherFactory) NewUUIDsWatcher(arg0 string, arg1 changestream.ChangeType) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewUUIDsWatcher", arg0, arg1)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewUUIDsWatcher indicates an expected call of NewUUIDsWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewUUIDsWatcher(arg0, arg1 any) *MockWatcherFactoryNewUUIDsWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewUUIDsWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewUUIDsWatcher), arg0, arg1)
	return &MockWatcherFactoryNewUUIDsWatcherCall{Call: call}
}

// MockWatcherFactoryNewUUIDsWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewUUIDsWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewUUIDsWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewUUIDsWatcherCall) Do(f func(string, changestream.ChangeType) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewUUIDsWatcherCall) DoAndReturn(f func(string, changestream.ChangeType) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewValueMapperWatcher mocks base method.
func (m *MockWatcherFactory) NewValueMapperWatcher(arg0, arg1 string, arg2 changestream.ChangeType, arg3 eventsource.Mapper) (watcher.Watcher[struct{}], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewValueMapperWatcher", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(watcher.Watcher[struct{}])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewValueMapperWatcher indicates an expected call of NewValueMapperWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewValueMapperWatcher(arg0, arg1, arg2, arg3 any) *MockWatcherFactoryNewValueMapperWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewValueMapperWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewValueMapperWatcher), arg0, arg1, arg2, arg3)
	return &MockWatcherFactoryNewValueMapperWatcherCall{Call: call}
}

// MockWatcherFactoryNewValueMapperWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewValueMapperWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewValueMapperWatcherCall) Return(arg0 watcher.Watcher[struct{}], arg1 error) *MockWatcherFactoryNewValueMapperWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewValueMapperWatcherCall) Do(f func(string, string, changestream.ChangeType, eventsource.Mapper) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewValueMapperWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewValueMapperWatcherCall) DoAndReturn(f func(string, string, changestream.ChangeType, eventsource.Mapper) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewValueMapperWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockAgentVersionGetter is a mock of AgentVersionGetter interface.
type MockAgentVersionGetter struct {
	ctrl     *gomock.Controller
	recorder *MockAgentVersionGetterMockRecorder
}

// MockAgentVersionGetterMockRecorder is the mock recorder for MockAgentVersionGetter.
type MockAgentVersionGetterMockRecorder struct {
	mock *MockAgentVersionGetter
}

// NewMockAgentVersionGetter creates a new mock instance.
func NewMockAgentVersionGetter(ctrl *gomock.Controller) *MockAgentVersionGetter {
	mock := &MockAgentVersionGetter{ctrl: ctrl}
	mock.recorder = &MockAgentVersionGetterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAgentVersionGetter) EXPECT() *MockAgentVersionGetterMockRecorder {
	return m.recorder
}

// GetModelTargetAgentVersion mocks base method.
func (m *MockAgentVersionGetter) GetModelTargetAgentVersion(arg0 context.Context, arg1 model.UUID) (version.Number, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModelTargetAgentVersion", arg0, arg1)
	ret0, _ := ret[0].(version.Number)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModelTargetAgentVersion indicates an expected call of GetModelTargetAgentVersion.
func (mr *MockAgentVersionGetterMockRecorder) GetModelTargetAgentVersion(arg0, arg1 any) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelTargetAgentVersion", reflect.TypeOf((*MockAgentVersionGetter)(nil).GetModelTargetAgentVersion), arg0, arg1)
	return &MockAgentVersionGetterGetModelTargetAgentVersionCall{Call: call}
}

// MockAgentVersionGetterGetModelTargetAgentVersionCall wrap *gomock.Call
type MockAgentVersionGetterGetModelTargetAgentVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) Return(arg0 version.Number, arg1 error) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) Do(f func(context.Context, model.UUID) (version.Number, error)) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) DoAndReturn(f func(context.Context, model.UUID) (version.Number, error)) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockProvider is a mock of Provider interface.
type MockProvider struct {
	ctrl     *gomock.Controller
	recorder *MockProviderMockRecorder
}

// MockProviderMockRecorder is the mock recorder for MockProvider.
type MockProviderMockRecorder struct {
	mock *MockProvider
}

// NewMockProvider creates a new mock instance.
func NewMockProvider(ctrl *gomock.Controller) *MockProvider {
	mock := &MockProvider{ctrl: ctrl}
	mock.recorder = &MockProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProvider) EXPECT() *MockProviderMockRecorder {
	return m.recorder
}

// SupportedFeatures mocks base method.
func (m *MockProvider) SupportedFeatures() (assumes.FeatureSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportedFeatures")
	ret0, _ := ret[0].(assumes.FeatureSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SupportedFeatures indicates an expected call of SupportedFeatures.
func (mr *MockProviderMockRecorder) SupportedFeatures() *MockProviderSupportedFeaturesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportedFeatures", reflect.TypeOf((*MockProvider)(nil).SupportedFeatures))
	return &MockProviderSupportedFeaturesCall{Call: call}
}

// MockProviderSupportedFeaturesCall wrap *gomock.Call
type MockProviderSupportedFeaturesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProviderSupportedFeaturesCall) Return(arg0 assumes.FeatureSet, arg1 error) *MockProviderSupportedFeaturesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProviderSupportedFeaturesCall) Do(f func() (assumes.FeatureSet, error)) *MockProviderSupportedFeaturesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProviderSupportedFeaturesCall) DoAndReturn(f func() (assumes.FeatureSet, error)) *MockProviderSupportedFeaturesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

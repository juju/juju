// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/domain/application/service (interfaces: AgentVersionGetter,CAASProvider,CharmStore,Provider,State,StatusHistory,WatcherFactory)
//
// Generated by this command:
//
//	mockgen -typed -package service -destination package_mock_test.go github.com/juju/juju/domain/application/service AgentVersionGetter,CAASProvider,CharmStore,Provider,State,StatusHistory,WatcherFactory
//

// Package service is a generated GoMock package.
package service

import (
	context "context"
	io "io"
	reflect "reflect"

	set "github.com/juju/collections/set"
	caas "github.com/juju/juju/caas"
	application "github.com/juju/juju/core/application"
	assumes "github.com/juju/juju/core/assumes"
	changestream "github.com/juju/juju/core/changestream"
	charm "github.com/juju/juju/core/charm"
	constraints "github.com/juju/juju/core/constraints"
	devices "github.com/juju/juju/core/devices"
	machine "github.com/juju/juju/core/machine"
	network "github.com/juju/juju/core/network"
	semversion "github.com/juju/juju/core/semversion"
	status "github.com/juju/juju/core/status"
	unit "github.com/juju/juju/core/unit"
	watcher "github.com/juju/juju/core/watcher"
	eventsource "github.com/juju/juju/core/watcher/eventsource"
	application0 "github.com/juju/juju/domain/application"
	architecture "github.com/juju/juju/domain/application/architecture"
	charm0 "github.com/juju/juju/domain/application/charm"
	store "github.com/juju/juju/domain/application/charm/store"
	internal "github.com/juju/juju/domain/application/internal"
	constraints0 "github.com/juju/juju/domain/constraints"
	life "github.com/juju/juju/domain/life"
	network0 "github.com/juju/juju/domain/network"
	environs "github.com/juju/juju/environs"
	statushistory "github.com/juju/juju/internal/statushistory"
	gomock "go.uber.org/mock/gomock"
)

// MockAgentVersionGetter is a mock of AgentVersionGetter interface.
type MockAgentVersionGetter struct {
	ctrl     *gomock.Controller
	recorder *MockAgentVersionGetterMockRecorder
}

// MockAgentVersionGetterMockRecorder is the mock recorder for MockAgentVersionGetter.
type MockAgentVersionGetterMockRecorder struct {
	mock *MockAgentVersionGetter
}

// NewMockAgentVersionGetter creates a new mock instance.
func NewMockAgentVersionGetter(ctrl *gomock.Controller) *MockAgentVersionGetter {
	mock := &MockAgentVersionGetter{ctrl: ctrl}
	mock.recorder = &MockAgentVersionGetterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAgentVersionGetter) EXPECT() *MockAgentVersionGetterMockRecorder {
	return m.recorder
}

// GetModelTargetAgentVersion mocks base method.
func (m *MockAgentVersionGetter) GetModelTargetAgentVersion(arg0 context.Context) (semversion.Number, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModelTargetAgentVersion", arg0)
	ret0, _ := ret[0].(semversion.Number)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModelTargetAgentVersion indicates an expected call of GetModelTargetAgentVersion.
func (mr *MockAgentVersionGetterMockRecorder) GetModelTargetAgentVersion(arg0 any) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelTargetAgentVersion", reflect.TypeOf((*MockAgentVersionGetter)(nil).GetModelTargetAgentVersion), arg0)
	return &MockAgentVersionGetterGetModelTargetAgentVersionCall{Call: call}
}

// MockAgentVersionGetterGetModelTargetAgentVersionCall wrap *gomock.Call
type MockAgentVersionGetterGetModelTargetAgentVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) Return(arg0 semversion.Number, arg1 error) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) Do(f func(context.Context) (semversion.Number, error)) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) DoAndReturn(f func(context.Context) (semversion.Number, error)) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCAASProvider is a mock of CAASProvider interface.
type MockCAASProvider struct {
	ctrl     *gomock.Controller
	recorder *MockCAASProviderMockRecorder
}

// MockCAASProviderMockRecorder is the mock recorder for MockCAASProvider.
type MockCAASProviderMockRecorder struct {
	mock *MockCAASProvider
}

// NewMockCAASProvider creates a new mock instance.
func NewMockCAASProvider(ctrl *gomock.Controller) *MockCAASProvider {
	mock := &MockCAASProvider{ctrl: ctrl}
	mock.recorder = &MockCAASProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCAASProvider) EXPECT() *MockCAASProviderMockRecorder {
	return m.recorder
}

// Application mocks base method.
func (m *MockCAASProvider) Application(arg0 string, arg1 caas.DeploymentType) caas.Application {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Application", arg0, arg1)
	ret0, _ := ret[0].(caas.Application)
	return ret0
}

// Application indicates an expected call of Application.
func (mr *MockCAASProviderMockRecorder) Application(arg0, arg1 any) *MockCAASProviderApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Application", reflect.TypeOf((*MockCAASProvider)(nil).Application), arg0, arg1)
	return &MockCAASProviderApplicationCall{Call: call}
}

// MockCAASProviderApplicationCall wrap *gomock.Call
type MockCAASProviderApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCAASProviderApplicationCall) Return(arg0 caas.Application) *MockCAASProviderApplicationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCAASProviderApplicationCall) Do(f func(string, caas.DeploymentType) caas.Application) *MockCAASProviderApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCAASProviderApplicationCall) DoAndReturn(f func(string, caas.DeploymentType) caas.Application) *MockCAASProviderApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SupportedFeatures mocks base method.
func (m *MockCAASProvider) SupportedFeatures() (assumes.FeatureSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportedFeatures")
	ret0, _ := ret[0].(assumes.FeatureSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SupportedFeatures indicates an expected call of SupportedFeatures.
func (mr *MockCAASProviderMockRecorder) SupportedFeatures() *MockCAASProviderSupportedFeaturesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportedFeatures", reflect.TypeOf((*MockCAASProvider)(nil).SupportedFeatures))
	return &MockCAASProviderSupportedFeaturesCall{Call: call}
}

// MockCAASProviderSupportedFeaturesCall wrap *gomock.Call
type MockCAASProviderSupportedFeaturesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCAASProviderSupportedFeaturesCall) Return(arg0 assumes.FeatureSet, arg1 error) *MockCAASProviderSupportedFeaturesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCAASProviderSupportedFeaturesCall) Do(f func() (assumes.FeatureSet, error)) *MockCAASProviderSupportedFeaturesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCAASProviderSupportedFeaturesCall) DoAndReturn(f func() (assumes.FeatureSet, error)) *MockCAASProviderSupportedFeaturesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharmStore is a mock of CharmStore interface.
type MockCharmStore struct {
	ctrl     *gomock.Controller
	recorder *MockCharmStoreMockRecorder
}

// MockCharmStoreMockRecorder is the mock recorder for MockCharmStore.
type MockCharmStoreMockRecorder struct {
	mock *MockCharmStore
}

// NewMockCharmStore creates a new mock instance.
func NewMockCharmStore(ctrl *gomock.Controller) *MockCharmStore {
	mock := &MockCharmStore{ctrl: ctrl}
	mock.recorder = &MockCharmStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharmStore) EXPECT() *MockCharmStoreMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockCharmStore) Get(arg0 context.Context, arg1 string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", arg0, arg1)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCharmStoreMockRecorder) Get(arg0, arg1 any) *MockCharmStoreGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCharmStore)(nil).Get), arg0, arg1)
	return &MockCharmStoreGetCall{Call: call}
}

// MockCharmStoreGetCall wrap *gomock.Call
type MockCharmStoreGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreGetCall) Return(arg0 io.ReadCloser, arg1 error) *MockCharmStoreGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreGetCall) Do(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreGetCall) DoAndReturn(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBySHA256Prefix mocks base method.
func (m *MockCharmStore) GetBySHA256Prefix(arg0 context.Context, arg1 string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBySHA256Prefix", arg0, arg1)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBySHA256Prefix indicates an expected call of GetBySHA256Prefix.
func (mr *MockCharmStoreMockRecorder) GetBySHA256Prefix(arg0, arg1 any) *MockCharmStoreGetBySHA256PrefixCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBySHA256Prefix", reflect.TypeOf((*MockCharmStore)(nil).GetBySHA256Prefix), arg0, arg1)
	return &MockCharmStoreGetBySHA256PrefixCall{Call: call}
}

// MockCharmStoreGetBySHA256PrefixCall wrap *gomock.Call
type MockCharmStoreGetBySHA256PrefixCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreGetBySHA256PrefixCall) Return(arg0 io.ReadCloser, arg1 error) *MockCharmStoreGetBySHA256PrefixCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreGetBySHA256PrefixCall) Do(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetBySHA256PrefixCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreGetBySHA256PrefixCall) DoAndReturn(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetBySHA256PrefixCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockCharmStore) Store(arg0 context.Context, arg1 string, arg2 int64, arg3 string) (store.StoreResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(store.StoreResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Store indicates an expected call of Store.
func (mr *MockCharmStoreMockRecorder) Store(arg0, arg1, arg2, arg3 any) *MockCharmStoreStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockCharmStore)(nil).Store), arg0, arg1, arg2, arg3)
	return &MockCharmStoreStoreCall{Call: call}
}

// MockCharmStoreStoreCall wrap *gomock.Call
type MockCharmStoreStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreStoreCall) Return(arg0 store.StoreResult, arg1 error) *MockCharmStoreStoreCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreStoreCall) Do(f func(context.Context, string, int64, string) (store.StoreResult, error)) *MockCharmStoreStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreStoreCall) DoAndReturn(f func(context.Context, string, int64, string) (store.StoreResult, error)) *MockCharmStoreStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreFromReader mocks base method.
func (m *MockCharmStore) StoreFromReader(arg0 context.Context, arg1 io.Reader, arg2 string) (store.StoreFromReaderResult, store.Digest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreFromReader", arg0, arg1, arg2)
	ret0, _ := ret[0].(store.StoreFromReaderResult)
	ret1, _ := ret[1].(store.Digest)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// StoreFromReader indicates an expected call of StoreFromReader.
func (mr *MockCharmStoreMockRecorder) StoreFromReader(arg0, arg1, arg2 any) *MockCharmStoreStoreFromReaderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreFromReader", reflect.TypeOf((*MockCharmStore)(nil).StoreFromReader), arg0, arg1, arg2)
	return &MockCharmStoreStoreFromReaderCall{Call: call}
}

// MockCharmStoreStoreFromReaderCall wrap *gomock.Call
type MockCharmStoreStoreFromReaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreStoreFromReaderCall) Return(arg0 store.StoreFromReaderResult, arg1 store.Digest, arg2 error) *MockCharmStoreStoreFromReaderCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreStoreFromReaderCall) Do(f func(context.Context, io.Reader, string) (store.StoreFromReaderResult, store.Digest, error)) *MockCharmStoreStoreFromReaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreStoreFromReaderCall) DoAndReturn(f func(context.Context, io.Reader, string) (store.StoreFromReaderResult, store.Digest, error)) *MockCharmStoreStoreFromReaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockProvider is a mock of Provider interface.
type MockProvider struct {
	ctrl     *gomock.Controller
	recorder *MockProviderMockRecorder
}

// MockProviderMockRecorder is the mock recorder for MockProvider.
type MockProviderMockRecorder struct {
	mock *MockProvider
}

// NewMockProvider creates a new mock instance.
func NewMockProvider(ctrl *gomock.Controller) *MockProvider {
	mock := &MockProvider{ctrl: ctrl}
	mock.recorder = &MockProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProvider) EXPECT() *MockProviderMockRecorder {
	return m.recorder
}

// ConstraintsValidator mocks base method.
func (m *MockProvider) ConstraintsValidator(arg0 context.Context) (constraints.Validator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConstraintsValidator", arg0)
	ret0, _ := ret[0].(constraints.Validator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConstraintsValidator indicates an expected call of ConstraintsValidator.
func (mr *MockProviderMockRecorder) ConstraintsValidator(arg0 any) *MockProviderConstraintsValidatorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConstraintsValidator", reflect.TypeOf((*MockProvider)(nil).ConstraintsValidator), arg0)
	return &MockProviderConstraintsValidatorCall{Call: call}
}

// MockProviderConstraintsValidatorCall wrap *gomock.Call
type MockProviderConstraintsValidatorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProviderConstraintsValidatorCall) Return(arg0 constraints.Validator, arg1 error) *MockProviderConstraintsValidatorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProviderConstraintsValidatorCall) Do(f func(context.Context) (constraints.Validator, error)) *MockProviderConstraintsValidatorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProviderConstraintsValidatorCall) DoAndReturn(f func(context.Context) (constraints.Validator, error)) *MockProviderConstraintsValidatorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrecheckInstance mocks base method.
func (m *MockProvider) PrecheckInstance(arg0 context.Context, arg1 environs.PrecheckInstanceParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrecheckInstance", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// PrecheckInstance indicates an expected call of PrecheckInstance.
func (mr *MockProviderMockRecorder) PrecheckInstance(arg0, arg1 any) *MockProviderPrecheckInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrecheckInstance", reflect.TypeOf((*MockProvider)(nil).PrecheckInstance), arg0, arg1)
	return &MockProviderPrecheckInstanceCall{Call: call}
}

// MockProviderPrecheckInstanceCall wrap *gomock.Call
type MockProviderPrecheckInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProviderPrecheckInstanceCall) Return(arg0 error) *MockProviderPrecheckInstanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProviderPrecheckInstanceCall) Do(f func(context.Context, environs.PrecheckInstanceParams) error) *MockProviderPrecheckInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProviderPrecheckInstanceCall) DoAndReturn(f func(context.Context, environs.PrecheckInstanceParams) error) *MockProviderPrecheckInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockState is a mock of State interface.
type MockState struct {
	ctrl     *gomock.Controller
	recorder *MockStateMockRecorder
}

// MockStateMockRecorder is the mock recorder for MockState.
type MockStateMockRecorder struct {
	mock *MockState
}

// NewMockState creates a new mock instance.
func NewMockState(ctrl *gomock.Controller) *MockState {
	mock := &MockState{ctrl: ctrl}
	mock.recorder = &MockStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockState) EXPECT() *MockStateMockRecorder {
	return m.recorder
}

// AddCAASUnits mocks base method.
func (m *MockState) AddCAASUnits(arg0 context.Context, arg1 application.UUID, arg2 ...application0.AddCAASUnitArg) ([]unit.Name, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddCAASUnits", varargs...)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddCAASUnits indicates an expected call of AddCAASUnits.
func (mr *MockStateMockRecorder) AddCAASUnits(arg0, arg1 any, arg2 ...any) *MockStateAddCAASUnitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCAASUnits", reflect.TypeOf((*MockState)(nil).AddCAASUnits), varargs...)
	return &MockStateAddCAASUnitsCall{Call: call}
}

// MockStateAddCAASUnitsCall wrap *gomock.Call
type MockStateAddCAASUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAddCAASUnitsCall) Return(arg0 []unit.Name, arg1 error) *MockStateAddCAASUnitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAddCAASUnitsCall) Do(f func(context.Context, application.UUID, ...application0.AddCAASUnitArg) ([]unit.Name, error)) *MockStateAddCAASUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAddCAASUnitsCall) DoAndReturn(f func(context.Context, application.UUID, ...application0.AddCAASUnitArg) ([]unit.Name, error)) *MockStateAddCAASUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddCharm mocks base method.
func (m *MockState) AddCharm(arg0 context.Context, arg1 charm0.Charm, arg2 *charm0.DownloadInfo, arg3 bool) (charm.ID, charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCharm", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(charm0.CharmLocator)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddCharm indicates an expected call of AddCharm.
func (mr *MockStateMockRecorder) AddCharm(arg0, arg1, arg2, arg3 any) *MockStateAddCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCharm", reflect.TypeOf((*MockState)(nil).AddCharm), arg0, arg1, arg2, arg3)
	return &MockStateAddCharmCall{Call: call}
}

// MockStateAddCharmCall wrap *gomock.Call
type MockStateAddCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAddCharmCall) Return(arg0 charm.ID, arg1 charm0.CharmLocator, arg2 error) *MockStateAddCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAddCharmCall) Do(f func(context.Context, charm0.Charm, *charm0.DownloadInfo, bool) (charm.ID, charm0.CharmLocator, error)) *MockStateAddCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAddCharmCall) DoAndReturn(f func(context.Context, charm0.Charm, *charm0.DownloadInfo, bool) (charm.ID, charm0.CharmLocator, error)) *MockStateAddCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddIAASSubordinateUnit mocks base method.
func (m *MockState) AddIAASSubordinateUnit(arg0 context.Context, arg1 application0.SubordinateUnitArg) (unit.Name, []machine.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddIAASSubordinateUnit", arg0, arg1)
	ret0, _ := ret[0].(unit.Name)
	ret1, _ := ret[1].([]machine.Name)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddIAASSubordinateUnit indicates an expected call of AddIAASSubordinateUnit.
func (mr *MockStateMockRecorder) AddIAASSubordinateUnit(arg0, arg1 any) *MockStateAddIAASSubordinateUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddIAASSubordinateUnit", reflect.TypeOf((*MockState)(nil).AddIAASSubordinateUnit), arg0, arg1)
	return &MockStateAddIAASSubordinateUnitCall{Call: call}
}

// MockStateAddIAASSubordinateUnitCall wrap *gomock.Call
type MockStateAddIAASSubordinateUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAddIAASSubordinateUnitCall) Return(arg0 unit.Name, arg1 []machine.Name, arg2 error) *MockStateAddIAASSubordinateUnitCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAddIAASSubordinateUnitCall) Do(f func(context.Context, application0.SubordinateUnitArg) (unit.Name, []machine.Name, error)) *MockStateAddIAASSubordinateUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAddIAASSubordinateUnitCall) DoAndReturn(f func(context.Context, application0.SubordinateUnitArg) (unit.Name, []machine.Name, error)) *MockStateAddIAASSubordinateUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddIAASUnits mocks base method.
func (m *MockState) AddIAASUnits(arg0 context.Context, arg1 application.UUID, arg2 ...application0.AddIAASUnitArg) ([]unit.Name, []machine.Name, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddIAASUnits", varargs...)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].([]machine.Name)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddIAASUnits indicates an expected call of AddIAASUnits.
func (mr *MockStateMockRecorder) AddIAASUnits(arg0, arg1 any, arg2 ...any) *MockStateAddIAASUnitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddIAASUnits", reflect.TypeOf((*MockState)(nil).AddIAASUnits), varargs...)
	return &MockStateAddIAASUnitsCall{Call: call}
}

// MockStateAddIAASUnitsCall wrap *gomock.Call
type MockStateAddIAASUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAddIAASUnitsCall) Return(arg0 []unit.Name, arg1 []machine.Name, arg2 error) *MockStateAddIAASUnitsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAddIAASUnitsCall) Do(f func(context.Context, application.UUID, ...application0.AddIAASUnitArg) ([]unit.Name, []machine.Name, error)) *MockStateAddIAASUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAddIAASUnitsCall) DoAndReturn(f func(context.Context, application.UUID, ...application0.AddIAASUnitArg) ([]unit.Name, []machine.Name, error)) *MockStateAddIAASUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CheckAllApplicationsAndUnitsAreAlive mocks base method.
func (m *MockState) CheckAllApplicationsAndUnitsAreAlive(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAllApplicationsAndUnitsAreAlive", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckAllApplicationsAndUnitsAreAlive indicates an expected call of CheckAllApplicationsAndUnitsAreAlive.
func (mr *MockStateMockRecorder) CheckAllApplicationsAndUnitsAreAlive(arg0 any) *MockStateCheckAllApplicationsAndUnitsAreAliveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAllApplicationsAndUnitsAreAlive", reflect.TypeOf((*MockState)(nil).CheckAllApplicationsAndUnitsAreAlive), arg0)
	return &MockStateCheckAllApplicationsAndUnitsAreAliveCall{Call: call}
}

// MockStateCheckAllApplicationsAndUnitsAreAliveCall wrap *gomock.Call
type MockStateCheckAllApplicationsAndUnitsAreAliveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateCheckAllApplicationsAndUnitsAreAliveCall) Return(arg0 error) *MockStateCheckAllApplicationsAndUnitsAreAliveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateCheckAllApplicationsAndUnitsAreAliveCall) Do(f func(context.Context) error) *MockStateCheckAllApplicationsAndUnitsAreAliveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateCheckAllApplicationsAndUnitsAreAliveCall) DoAndReturn(f func(context.Context) error) *MockStateCheckAllApplicationsAndUnitsAreAliveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateCAASApplication mocks base method.
func (m *MockState) CreateCAASApplication(arg0 context.Context, arg1 string, arg2 application0.AddCAASApplicationArg, arg3 []application0.AddCAASUnitArg) (application.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateCAASApplication", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateCAASApplication indicates an expected call of CreateCAASApplication.
func (mr *MockStateMockRecorder) CreateCAASApplication(arg0, arg1, arg2, arg3 any) *MockStateCreateCAASApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCAASApplication", reflect.TypeOf((*MockState)(nil).CreateCAASApplication), arg0, arg1, arg2, arg3)
	return &MockStateCreateCAASApplicationCall{Call: call}
}

// MockStateCreateCAASApplicationCall wrap *gomock.Call
type MockStateCreateCAASApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateCreateCAASApplicationCall) Return(arg0 application.UUID, arg1 error) *MockStateCreateCAASApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateCreateCAASApplicationCall) Do(f func(context.Context, string, application0.AddCAASApplicationArg, []application0.AddCAASUnitArg) (application.UUID, error)) *MockStateCreateCAASApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateCreateCAASApplicationCall) DoAndReturn(f func(context.Context, string, application0.AddCAASApplicationArg, []application0.AddCAASUnitArg) (application.UUID, error)) *MockStateCreateCAASApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateIAASApplication mocks base method.
func (m *MockState) CreateIAASApplication(arg0 context.Context, arg1 string, arg2 application0.AddIAASApplicationArg, arg3 []application0.AddIAASUnitArg) (application.UUID, []machine.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateIAASApplication", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].([]machine.Name)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateIAASApplication indicates an expected call of CreateIAASApplication.
func (mr *MockStateMockRecorder) CreateIAASApplication(arg0, arg1, arg2, arg3 any) *MockStateCreateIAASApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIAASApplication", reflect.TypeOf((*MockState)(nil).CreateIAASApplication), arg0, arg1, arg2, arg3)
	return &MockStateCreateIAASApplicationCall{Call: call}
}

// MockStateCreateIAASApplicationCall wrap *gomock.Call
type MockStateCreateIAASApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateCreateIAASApplicationCall) Return(arg0 application.UUID, arg1 []machine.Name, arg2 error) *MockStateCreateIAASApplicationCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateCreateIAASApplicationCall) Do(f func(context.Context, string, application0.AddIAASApplicationArg, []application0.AddIAASUnitArg) (application.UUID, []machine.Name, error)) *MockStateCreateIAASApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateCreateIAASApplicationCall) DoAndReturn(f func(context.Context, string, application0.AddIAASApplicationArg, []application0.AddIAASUnitArg) (application.UUID, []machine.Name, error)) *MockStateCreateIAASApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EndpointsExist mocks base method.
func (m *MockState) EndpointsExist(arg0 context.Context, arg1 application.UUID, arg2 set.Strings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EndpointsExist", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// EndpointsExist indicates an expected call of EndpointsExist.
func (mr *MockStateMockRecorder) EndpointsExist(arg0, arg1, arg2 any) *MockStateEndpointsExistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndpointsExist", reflect.TypeOf((*MockState)(nil).EndpointsExist), arg0, arg1, arg2)
	return &MockStateEndpointsExistCall{Call: call}
}

// MockStateEndpointsExistCall wrap *gomock.Call
type MockStateEndpointsExistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateEndpointsExistCall) Return(arg0 error) *MockStateEndpointsExistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateEndpointsExistCall) Do(f func(context.Context, application.UUID, set.Strings) error) *MockStateEndpointsExistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateEndpointsExistCall) DoAndReturn(f func(context.Context, application.UUID, set.Strings) error) *MockStateEndpointsExistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAddressesHash mocks base method.
func (m *MockState) GetAddressesHash(arg0 context.Context, arg1 application.UUID, arg2 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddressesHash", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAddressesHash indicates an expected call of GetAddressesHash.
func (mr *MockStateMockRecorder) GetAddressesHash(arg0, arg1, arg2 any) *MockStateGetAddressesHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddressesHash", reflect.TypeOf((*MockState)(nil).GetAddressesHash), arg0, arg1, arg2)
	return &MockStateGetAddressesHashCall{Call: call}
}

// MockStateGetAddressesHashCall wrap *gomock.Call
type MockStateGetAddressesHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAddressesHashCall) Return(arg0 string, arg1 error) *MockStateGetAddressesHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAddressesHashCall) Do(f func(context.Context, application.UUID, string) (string, error)) *MockStateGetAddressesHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAddressesHashCall) DoAndReturn(f func(context.Context, application.UUID, string) (string, error)) *MockStateGetAddressesHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAllEndpointBindings mocks base method.
func (m *MockState) GetAllEndpointBindings(arg0 context.Context) (map[string]map[string]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllEndpointBindings", arg0)
	ret0, _ := ret[0].(map[string]map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllEndpointBindings indicates an expected call of GetAllEndpointBindings.
func (mr *MockStateMockRecorder) GetAllEndpointBindings(arg0 any) *MockStateGetAllEndpointBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllEndpointBindings", reflect.TypeOf((*MockState)(nil).GetAllEndpointBindings), arg0)
	return &MockStateGetAllEndpointBindingsCall{Call: call}
}

// MockStateGetAllEndpointBindingsCall wrap *gomock.Call
type MockStateGetAllEndpointBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAllEndpointBindingsCall) Return(arg0 map[string]map[string]string, arg1 error) *MockStateGetAllEndpointBindingsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAllEndpointBindingsCall) Do(f func(context.Context) (map[string]map[string]string, error)) *MockStateGetAllEndpointBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAllEndpointBindingsCall) DoAndReturn(f func(context.Context) (map[string]map[string]string, error)) *MockStateGetAllEndpointBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAllUnitCloudContainerIDsForApplication mocks base method.
func (m *MockState) GetAllUnitCloudContainerIDsForApplication(arg0 context.Context, arg1 application.UUID) (map[unit.Name]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllUnitCloudContainerIDsForApplication", arg0, arg1)
	ret0, _ := ret[0].(map[unit.Name]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllUnitCloudContainerIDsForApplication indicates an expected call of GetAllUnitCloudContainerIDsForApplication.
func (mr *MockStateMockRecorder) GetAllUnitCloudContainerIDsForApplication(arg0, arg1 any) *MockStateGetAllUnitCloudContainerIDsForApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUnitCloudContainerIDsForApplication", reflect.TypeOf((*MockState)(nil).GetAllUnitCloudContainerIDsForApplication), arg0, arg1)
	return &MockStateGetAllUnitCloudContainerIDsForApplicationCall{Call: call}
}

// MockStateGetAllUnitCloudContainerIDsForApplicationCall wrap *gomock.Call
type MockStateGetAllUnitCloudContainerIDsForApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAllUnitCloudContainerIDsForApplicationCall) Return(arg0 map[unit.Name]string, arg1 error) *MockStateGetAllUnitCloudContainerIDsForApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAllUnitCloudContainerIDsForApplicationCall) Do(f func(context.Context, application.UUID) (map[unit.Name]string, error)) *MockStateGetAllUnitCloudContainerIDsForApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAllUnitCloudContainerIDsForApplicationCall) DoAndReturn(f func(context.Context, application.UUID) (map[unit.Name]string, error)) *MockStateGetAllUnitCloudContainerIDsForApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAllUnitLifeForApplication mocks base method.
func (m *MockState) GetAllUnitLifeForApplication(arg0 context.Context, arg1 application.UUID) (map[string]int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllUnitLifeForApplication", arg0, arg1)
	ret0, _ := ret[0].(map[string]int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllUnitLifeForApplication indicates an expected call of GetAllUnitLifeForApplication.
func (mr *MockStateMockRecorder) GetAllUnitLifeForApplication(arg0, arg1 any) *MockStateGetAllUnitLifeForApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUnitLifeForApplication", reflect.TypeOf((*MockState)(nil).GetAllUnitLifeForApplication), arg0, arg1)
	return &MockStateGetAllUnitLifeForApplicationCall{Call: call}
}

// MockStateGetAllUnitLifeForApplicationCall wrap *gomock.Call
type MockStateGetAllUnitLifeForApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAllUnitLifeForApplicationCall) Return(arg0 map[string]int, arg1 error) *MockStateGetAllUnitLifeForApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAllUnitLifeForApplicationCall) Do(f func(context.Context, application.UUID) (map[string]int, error)) *MockStateGetAllUnitLifeForApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAllUnitLifeForApplicationCall) DoAndReturn(f func(context.Context, application.UUID) (map[string]int, error)) *MockStateGetAllUnitLifeForApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAllUnitNames mocks base method.
func (m *MockState) GetAllUnitNames(arg0 context.Context) ([]unit.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllUnitNames", arg0)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllUnitNames indicates an expected call of GetAllUnitNames.
func (mr *MockStateMockRecorder) GetAllUnitNames(arg0 any) *MockStateGetAllUnitNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUnitNames", reflect.TypeOf((*MockState)(nil).GetAllUnitNames), arg0)
	return &MockStateGetAllUnitNamesCall{Call: call}
}

// MockStateGetAllUnitNamesCall wrap *gomock.Call
type MockStateGetAllUnitNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAllUnitNamesCall) Return(arg0 []unit.Name, arg1 error) *MockStateGetAllUnitNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAllUnitNamesCall) Do(f func(context.Context) ([]unit.Name, error)) *MockStateGetAllUnitNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAllUnitNamesCall) DoAndReturn(f func(context.Context) ([]unit.Name, error)) *MockStateGetAllUnitNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationCharmOrigin mocks base method.
func (m *MockState) GetApplicationCharmOrigin(arg0 context.Context, arg1 application.UUID) (application0.CharmOrigin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationCharmOrigin", arg0, arg1)
	ret0, _ := ret[0].(application0.CharmOrigin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationCharmOrigin indicates an expected call of GetApplicationCharmOrigin.
func (mr *MockStateMockRecorder) GetApplicationCharmOrigin(arg0, arg1 any) *MockStateGetApplicationCharmOriginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationCharmOrigin", reflect.TypeOf((*MockState)(nil).GetApplicationCharmOrigin), arg0, arg1)
	return &MockStateGetApplicationCharmOriginCall{Call: call}
}

// MockStateGetApplicationCharmOriginCall wrap *gomock.Call
type MockStateGetApplicationCharmOriginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationCharmOriginCall) Return(arg0 application0.CharmOrigin, arg1 error) *MockStateGetApplicationCharmOriginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationCharmOriginCall) Do(f func(context.Context, application.UUID) (application0.CharmOrigin, error)) *MockStateGetApplicationCharmOriginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationCharmOriginCall) DoAndReturn(f func(context.Context, application.UUID) (application0.CharmOrigin, error)) *MockStateGetApplicationCharmOriginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationConfigAndSettings mocks base method.
func (m *MockState) GetApplicationConfigAndSettings(arg0 context.Context, arg1 application.UUID) (map[string]application0.ApplicationConfig, application0.ApplicationSettings, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationConfigAndSettings", arg0, arg1)
	ret0, _ := ret[0].(map[string]application0.ApplicationConfig)
	ret1, _ := ret[1].(application0.ApplicationSettings)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApplicationConfigAndSettings indicates an expected call of GetApplicationConfigAndSettings.
func (mr *MockStateMockRecorder) GetApplicationConfigAndSettings(arg0, arg1 any) *MockStateGetApplicationConfigAndSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationConfigAndSettings", reflect.TypeOf((*MockState)(nil).GetApplicationConfigAndSettings), arg0, arg1)
	return &MockStateGetApplicationConfigAndSettingsCall{Call: call}
}

// MockStateGetApplicationConfigAndSettingsCall wrap *gomock.Call
type MockStateGetApplicationConfigAndSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationConfigAndSettingsCall) Return(arg0 map[string]application0.ApplicationConfig, arg1 application0.ApplicationSettings, arg2 error) *MockStateGetApplicationConfigAndSettingsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationConfigAndSettingsCall) Do(f func(context.Context, application.UUID) (map[string]application0.ApplicationConfig, application0.ApplicationSettings, error)) *MockStateGetApplicationConfigAndSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationConfigAndSettingsCall) DoAndReturn(f func(context.Context, application.UUID) (map[string]application0.ApplicationConfig, application0.ApplicationSettings, error)) *MockStateGetApplicationConfigAndSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationConfigHash mocks base method.
func (m *MockState) GetApplicationConfigHash(arg0 context.Context, arg1 application.UUID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationConfigHash", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationConfigHash indicates an expected call of GetApplicationConfigHash.
func (mr *MockStateMockRecorder) GetApplicationConfigHash(arg0, arg1 any) *MockStateGetApplicationConfigHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationConfigHash", reflect.TypeOf((*MockState)(nil).GetApplicationConfigHash), arg0, arg1)
	return &MockStateGetApplicationConfigHashCall{Call: call}
}

// MockStateGetApplicationConfigHashCall wrap *gomock.Call
type MockStateGetApplicationConfigHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationConfigHashCall) Return(arg0 string, arg1 error) *MockStateGetApplicationConfigHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationConfigHashCall) Do(f func(context.Context, application.UUID) (string, error)) *MockStateGetApplicationConfigHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationConfigHashCall) DoAndReturn(f func(context.Context, application.UUID) (string, error)) *MockStateGetApplicationConfigHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationConfigWithDefaults mocks base method.
func (m *MockState) GetApplicationConfigWithDefaults(arg0 context.Context, arg1 application.UUID) (map[string]application0.ApplicationConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationConfigWithDefaults", arg0, arg1)
	ret0, _ := ret[0].(map[string]application0.ApplicationConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationConfigWithDefaults indicates an expected call of GetApplicationConfigWithDefaults.
func (mr *MockStateMockRecorder) GetApplicationConfigWithDefaults(arg0, arg1 any) *MockStateGetApplicationConfigWithDefaultsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationConfigWithDefaults", reflect.TypeOf((*MockState)(nil).GetApplicationConfigWithDefaults), arg0, arg1)
	return &MockStateGetApplicationConfigWithDefaultsCall{Call: call}
}

// MockStateGetApplicationConfigWithDefaultsCall wrap *gomock.Call
type MockStateGetApplicationConfigWithDefaultsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationConfigWithDefaultsCall) Return(arg0 map[string]application0.ApplicationConfig, arg1 error) *MockStateGetApplicationConfigWithDefaultsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationConfigWithDefaultsCall) Do(f func(context.Context, application.UUID) (map[string]application0.ApplicationConfig, error)) *MockStateGetApplicationConfigWithDefaultsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationConfigWithDefaultsCall) DoAndReturn(f func(context.Context, application.UUID) (map[string]application0.ApplicationConfig, error)) *MockStateGetApplicationConfigWithDefaultsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationConstraints mocks base method.
func (m *MockState) GetApplicationConstraints(arg0 context.Context, arg1 application.UUID) (constraints0.Constraints, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationConstraints", arg0, arg1)
	ret0, _ := ret[0].(constraints0.Constraints)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationConstraints indicates an expected call of GetApplicationConstraints.
func (mr *MockStateMockRecorder) GetApplicationConstraints(arg0, arg1 any) *MockStateGetApplicationConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationConstraints", reflect.TypeOf((*MockState)(nil).GetApplicationConstraints), arg0, arg1)
	return &MockStateGetApplicationConstraintsCall{Call: call}
}

// MockStateGetApplicationConstraintsCall wrap *gomock.Call
type MockStateGetApplicationConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationConstraintsCall) Return(arg0 constraints0.Constraints, arg1 error) *MockStateGetApplicationConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationConstraintsCall) Do(f func(context.Context, application.UUID) (constraints0.Constraints, error)) *MockStateGetApplicationConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationConstraintsCall) DoAndReturn(f func(context.Context, application.UUID) (constraints0.Constraints, error)) *MockStateGetApplicationConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationEndpointBindings mocks base method.
func (m *MockState) GetApplicationEndpointBindings(arg0 context.Context, arg1 application.UUID) (map[string]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationEndpointBindings", arg0, arg1)
	ret0, _ := ret[0].(map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationEndpointBindings indicates an expected call of GetApplicationEndpointBindings.
func (mr *MockStateMockRecorder) GetApplicationEndpointBindings(arg0, arg1 any) *MockStateGetApplicationEndpointBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationEndpointBindings", reflect.TypeOf((*MockState)(nil).GetApplicationEndpointBindings), arg0, arg1)
	return &MockStateGetApplicationEndpointBindingsCall{Call: call}
}

// MockStateGetApplicationEndpointBindingsCall wrap *gomock.Call
type MockStateGetApplicationEndpointBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationEndpointBindingsCall) Return(arg0 map[string]string, arg1 error) *MockStateGetApplicationEndpointBindingsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationEndpointBindingsCall) Do(f func(context.Context, application.UUID) (map[string]string, error)) *MockStateGetApplicationEndpointBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationEndpointBindingsCall) DoAndReturn(f func(context.Context, application.UUID) (map[string]string, error)) *MockStateGetApplicationEndpointBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationEndpointNames mocks base method.
func (m *MockState) GetApplicationEndpointNames(arg0 context.Context, arg1 application.UUID) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationEndpointNames", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationEndpointNames indicates an expected call of GetApplicationEndpointNames.
func (mr *MockStateMockRecorder) GetApplicationEndpointNames(arg0, arg1 any) *MockStateGetApplicationEndpointNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationEndpointNames", reflect.TypeOf((*MockState)(nil).GetApplicationEndpointNames), arg0, arg1)
	return &MockStateGetApplicationEndpointNamesCall{Call: call}
}

// MockStateGetApplicationEndpointNamesCall wrap *gomock.Call
type MockStateGetApplicationEndpointNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationEndpointNamesCall) Return(arg0 []string, arg1 error) *MockStateGetApplicationEndpointNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationEndpointNamesCall) Do(f func(context.Context, application.UUID) ([]string, error)) *MockStateGetApplicationEndpointNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationEndpointNamesCall) DoAndReturn(f func(context.Context, application.UUID) ([]string, error)) *MockStateGetApplicationEndpointNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationLife mocks base method.
func (m *MockState) GetApplicationLife(arg0 context.Context, arg1 application.UUID) (life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationLife", arg0, arg1)
	ret0, _ := ret[0].(life.Life)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationLife indicates an expected call of GetApplicationLife.
func (mr *MockStateMockRecorder) GetApplicationLife(arg0, arg1 any) *MockStateGetApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationLife", reflect.TypeOf((*MockState)(nil).GetApplicationLife), arg0, arg1)
	return &MockStateGetApplicationLifeCall{Call: call}
}

// MockStateGetApplicationLifeCall wrap *gomock.Call
type MockStateGetApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationLifeCall) Return(arg0 life.Life, arg1 error) *MockStateGetApplicationLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationLifeCall) Do(f func(context.Context, application.UUID) (life.Life, error)) *MockStateGetApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationLifeCall) DoAndReturn(f func(context.Context, application.UUID) (life.Life, error)) *MockStateGetApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationLifeByName mocks base method.
func (m *MockState) GetApplicationLifeByName(arg0 context.Context, arg1 string) (application.UUID, life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationLifeByName", arg0, arg1)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].(life.Life)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApplicationLifeByName indicates an expected call of GetApplicationLifeByName.
func (mr *MockStateMockRecorder) GetApplicationLifeByName(arg0, arg1 any) *MockStateGetApplicationLifeByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationLifeByName", reflect.TypeOf((*MockState)(nil).GetApplicationLifeByName), arg0, arg1)
	return &MockStateGetApplicationLifeByNameCall{Call: call}
}

// MockStateGetApplicationLifeByNameCall wrap *gomock.Call
type MockStateGetApplicationLifeByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationLifeByNameCall) Return(arg0 application.UUID, arg1 life.Life, arg2 error) *MockStateGetApplicationLifeByNameCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationLifeByNameCall) Do(f func(context.Context, string) (application.UUID, life.Life, error)) *MockStateGetApplicationLifeByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationLifeByNameCall) DoAndReturn(f func(context.Context, string) (application.UUID, life.Life, error)) *MockStateGetApplicationLifeByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationName mocks base method.
func (m *MockState) GetApplicationName(arg0 context.Context, arg1 application.UUID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationName", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationName indicates an expected call of GetApplicationName.
func (mr *MockStateMockRecorder) GetApplicationName(arg0, arg1 any) *MockStateGetApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationName", reflect.TypeOf((*MockState)(nil).GetApplicationName), arg0, arg1)
	return &MockStateGetApplicationNameCall{Call: call}
}

// MockStateGetApplicationNameCall wrap *gomock.Call
type MockStateGetApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationNameCall) Return(arg0 string, arg1 error) *MockStateGetApplicationNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationNameCall) Do(f func(context.Context, application.UUID) (string, error)) *MockStateGetApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationNameCall) DoAndReturn(f func(context.Context, application.UUID) (string, error)) *MockStateGetApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationScaleState mocks base method.
func (m *MockState) GetApplicationScaleState(arg0 context.Context, arg1 application.UUID) (application0.ScaleState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationScaleState", arg0, arg1)
	ret0, _ := ret[0].(application0.ScaleState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationScaleState indicates an expected call of GetApplicationScaleState.
func (mr *MockStateMockRecorder) GetApplicationScaleState(arg0, arg1 any) *MockStateGetApplicationScaleStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationScaleState", reflect.TypeOf((*MockState)(nil).GetApplicationScaleState), arg0, arg1)
	return &MockStateGetApplicationScaleStateCall{Call: call}
}

// MockStateGetApplicationScaleStateCall wrap *gomock.Call
type MockStateGetApplicationScaleStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationScaleStateCall) Return(arg0 application0.ScaleState, arg1 error) *MockStateGetApplicationScaleStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationScaleStateCall) Do(f func(context.Context, application.UUID) (application0.ScaleState, error)) *MockStateGetApplicationScaleStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationScaleStateCall) DoAndReturn(f func(context.Context, application.UUID) (application0.ScaleState, error)) *MockStateGetApplicationScaleStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationTrustSetting mocks base method.
func (m *MockState) GetApplicationTrustSetting(arg0 context.Context, arg1 application.UUID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationTrustSetting", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationTrustSetting indicates an expected call of GetApplicationTrustSetting.
func (mr *MockStateMockRecorder) GetApplicationTrustSetting(arg0, arg1 any) *MockStateGetApplicationTrustSettingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationTrustSetting", reflect.TypeOf((*MockState)(nil).GetApplicationTrustSetting), arg0, arg1)
	return &MockStateGetApplicationTrustSettingCall{Call: call}
}

// MockStateGetApplicationTrustSettingCall wrap *gomock.Call
type MockStateGetApplicationTrustSettingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationTrustSettingCall) Return(arg0 bool, arg1 error) *MockStateGetApplicationTrustSettingCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationTrustSettingCall) Do(f func(context.Context, application.UUID) (bool, error)) *MockStateGetApplicationTrustSettingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationTrustSettingCall) DoAndReturn(f func(context.Context, application.UUID) (bool, error)) *MockStateGetApplicationTrustSettingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUUIDAndNameByUnitName mocks base method.
func (m *MockState) GetApplicationUUIDAndNameByUnitName(arg0 context.Context, arg1 unit.Name) (application.UUID, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationUUIDAndNameByUnitName", arg0, arg1)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApplicationUUIDAndNameByUnitName indicates an expected call of GetApplicationUUIDAndNameByUnitName.
func (mr *MockStateMockRecorder) GetApplicationUUIDAndNameByUnitName(arg0, arg1 any) *MockStateGetApplicationUUIDAndNameByUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUUIDAndNameByUnitName", reflect.TypeOf((*MockState)(nil).GetApplicationUUIDAndNameByUnitName), arg0, arg1)
	return &MockStateGetApplicationUUIDAndNameByUnitNameCall{Call: call}
}

// MockStateGetApplicationUUIDAndNameByUnitNameCall wrap *gomock.Call
type MockStateGetApplicationUUIDAndNameByUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationUUIDAndNameByUnitNameCall) Return(arg0 application.UUID, arg1 string, arg2 error) *MockStateGetApplicationUUIDAndNameByUnitNameCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationUUIDAndNameByUnitNameCall) Do(f func(context.Context, unit.Name) (application.UUID, string, error)) *MockStateGetApplicationUUIDAndNameByUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationUUIDAndNameByUnitNameCall) DoAndReturn(f func(context.Context, unit.Name) (application.UUID, string, error)) *MockStateGetApplicationUUIDAndNameByUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUUIDByName mocks base method.
func (m *MockState) GetApplicationUUIDByName(arg0 context.Context, arg1 string) (application.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationUUIDByName", arg0, arg1)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationUUIDByName indicates an expected call of GetApplicationUUIDByName.
func (mr *MockStateMockRecorder) GetApplicationUUIDByName(arg0, arg1 any) *MockStateGetApplicationUUIDByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUUIDByName", reflect.TypeOf((*MockState)(nil).GetApplicationUUIDByName), arg0, arg1)
	return &MockStateGetApplicationUUIDByNameCall{Call: call}
}

// MockStateGetApplicationUUIDByNameCall wrap *gomock.Call
type MockStateGetApplicationUUIDByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationUUIDByNameCall) Return(arg0 application.UUID, arg1 error) *MockStateGetApplicationUUIDByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationUUIDByNameCall) Do(f func(context.Context, string) (application.UUID, error)) *MockStateGetApplicationUUIDByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationUUIDByNameCall) DoAndReturn(f func(context.Context, string) (application.UUID, error)) *MockStateGetApplicationUUIDByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUUIDByUnitName mocks base method.
func (m *MockState) GetApplicationUUIDByUnitName(arg0 context.Context, arg1 unit.Name) (application.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationUUIDByUnitName", arg0, arg1)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationUUIDByUnitName indicates an expected call of GetApplicationUUIDByUnitName.
func (mr *MockStateMockRecorder) GetApplicationUUIDByUnitName(arg0, arg1 any) *MockStateGetApplicationUUIDByUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUUIDByUnitName", reflect.TypeOf((*MockState)(nil).GetApplicationUUIDByUnitName), arg0, arg1)
	return &MockStateGetApplicationUUIDByUnitNameCall{Call: call}
}

// MockStateGetApplicationUUIDByUnitNameCall wrap *gomock.Call
type MockStateGetApplicationUUIDByUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationUUIDByUnitNameCall) Return(arg0 application.UUID, arg1 error) *MockStateGetApplicationUUIDByUnitNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationUUIDByUnitNameCall) Do(f func(context.Context, unit.Name) (application.UUID, error)) *MockStateGetApplicationUUIDByUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationUUIDByUnitNameCall) DoAndReturn(f func(context.Context, unit.Name) (application.UUID, error)) *MockStateGetApplicationUUIDByUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUnitLife mocks base method.
func (m *MockState) GetApplicationUnitLife(arg0 context.Context, arg1 string, arg2 ...unit.UUID) (map[string]int, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetApplicationUnitLife", varargs...)
	ret0, _ := ret[0].(map[string]int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationUnitLife indicates an expected call of GetApplicationUnitLife.
func (mr *MockStateMockRecorder) GetApplicationUnitLife(arg0, arg1 any, arg2 ...any) *MockStateGetApplicationUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUnitLife", reflect.TypeOf((*MockState)(nil).GetApplicationUnitLife), varargs...)
	return &MockStateGetApplicationUnitLifeCall{Call: call}
}

// MockStateGetApplicationUnitLifeCall wrap *gomock.Call
type MockStateGetApplicationUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationUnitLifeCall) Return(arg0 map[string]int, arg1 error) *MockStateGetApplicationUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationUnitLifeCall) Do(f func(context.Context, string, ...unit.UUID) (map[string]int, error)) *MockStateGetApplicationUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationUnitLifeCall) DoAndReturn(f func(context.Context, string, ...unit.UUID) (map[string]int, error)) *MockStateGetApplicationUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUnitsForExport mocks base method.
func (m *MockState) GetApplicationUnitsForExport(arg0 context.Context, arg1 application.UUID) ([]application0.ExportUnit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationUnitsForExport", arg0, arg1)
	ret0, _ := ret[0].([]application0.ExportUnit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationUnitsForExport indicates an expected call of GetApplicationUnitsForExport.
func (mr *MockStateMockRecorder) GetApplicationUnitsForExport(arg0, arg1 any) *MockStateGetApplicationUnitsForExportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUnitsForExport", reflect.TypeOf((*MockState)(nil).GetApplicationUnitsForExport), arg0, arg1)
	return &MockStateGetApplicationUnitsForExportCall{Call: call}
}

// MockStateGetApplicationUnitsForExportCall wrap *gomock.Call
type MockStateGetApplicationUnitsForExportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationUnitsForExportCall) Return(arg0 []application0.ExportUnit, arg1 error) *MockStateGetApplicationUnitsForExportCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationUnitsForExportCall) Do(f func(context.Context, application.UUID) ([]application0.ExportUnit, error)) *MockStateGetApplicationUnitsForExportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationUnitsForExportCall) DoAndReturn(f func(context.Context, application.UUID) ([]application0.ExportUnit, error)) *MockStateGetApplicationUnitsForExportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationsBoundToSpace mocks base method.
func (m *MockState) GetApplicationsBoundToSpace(arg0 context.Context, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationsBoundToSpace", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationsBoundToSpace indicates an expected call of GetApplicationsBoundToSpace.
func (mr *MockStateMockRecorder) GetApplicationsBoundToSpace(arg0, arg1 any) *MockStateGetApplicationsBoundToSpaceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationsBoundToSpace", reflect.TypeOf((*MockState)(nil).GetApplicationsBoundToSpace), arg0, arg1)
	return &MockStateGetApplicationsBoundToSpaceCall{Call: call}
}

// MockStateGetApplicationsBoundToSpaceCall wrap *gomock.Call
type MockStateGetApplicationsBoundToSpaceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationsBoundToSpaceCall) Return(arg0 []string, arg1 error) *MockStateGetApplicationsBoundToSpaceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationsBoundToSpaceCall) Do(f func(context.Context, string) ([]string, error)) *MockStateGetApplicationsBoundToSpaceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationsBoundToSpaceCall) DoAndReturn(f func(context.Context, string) ([]string, error)) *MockStateGetApplicationsBoundToSpaceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationsForExport mocks base method.
func (m *MockState) GetApplicationsForExport(arg0 context.Context) ([]application0.ExportApplication, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationsForExport", arg0)
	ret0, _ := ret[0].([]application0.ExportApplication)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationsForExport indicates an expected call of GetApplicationsForExport.
func (mr *MockStateMockRecorder) GetApplicationsForExport(arg0 any) *MockStateGetApplicationsForExportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationsForExport", reflect.TypeOf((*MockState)(nil).GetApplicationsForExport), arg0)
	return &MockStateGetApplicationsForExportCall{Call: call}
}

// MockStateGetApplicationsForExportCall wrap *gomock.Call
type MockStateGetApplicationsForExportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationsForExportCall) Return(arg0 []application0.ExportApplication, arg1 error) *MockStateGetApplicationsForExportCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationsForExportCall) Do(f func(context.Context) ([]application0.ExportApplication, error)) *MockStateGetApplicationsForExportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationsForExportCall) DoAndReturn(f func(context.Context) ([]application0.ExportApplication, error)) *MockStateGetApplicationsForExportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationsForRevisionUpdater mocks base method.
func (m *MockState) GetApplicationsForRevisionUpdater(arg0 context.Context) ([]application0.RevisionUpdaterApplication, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationsForRevisionUpdater", arg0)
	ret0, _ := ret[0].([]application0.RevisionUpdaterApplication)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationsForRevisionUpdater indicates an expected call of GetApplicationsForRevisionUpdater.
func (mr *MockStateMockRecorder) GetApplicationsForRevisionUpdater(arg0 any) *MockStateGetApplicationsForRevisionUpdaterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationsForRevisionUpdater", reflect.TypeOf((*MockState)(nil).GetApplicationsForRevisionUpdater), arg0)
	return &MockStateGetApplicationsForRevisionUpdaterCall{Call: call}
}

// MockStateGetApplicationsForRevisionUpdaterCall wrap *gomock.Call
type MockStateGetApplicationsForRevisionUpdaterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationsForRevisionUpdaterCall) Return(arg0 []application0.RevisionUpdaterApplication, arg1 error) *MockStateGetApplicationsForRevisionUpdaterCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationsForRevisionUpdaterCall) Do(f func(context.Context) ([]application0.RevisionUpdaterApplication, error)) *MockStateGetApplicationsForRevisionUpdaterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationsForRevisionUpdaterCall) DoAndReturn(f func(context.Context) ([]application0.RevisionUpdaterApplication, error)) *MockStateGetApplicationsForRevisionUpdaterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationsWithPendingCharmsFromUUIDs mocks base method.
func (m *MockState) GetApplicationsWithPendingCharmsFromUUIDs(arg0 context.Context, arg1 []application.UUID) ([]application.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationsWithPendingCharmsFromUUIDs", arg0, arg1)
	ret0, _ := ret[0].([]application.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationsWithPendingCharmsFromUUIDs indicates an expected call of GetApplicationsWithPendingCharmsFromUUIDs.
func (mr *MockStateMockRecorder) GetApplicationsWithPendingCharmsFromUUIDs(arg0, arg1 any) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationsWithPendingCharmsFromUUIDs", reflect.TypeOf((*MockState)(nil).GetApplicationsWithPendingCharmsFromUUIDs), arg0, arg1)
	return &MockStateGetApplicationsWithPendingCharmsFromUUIDsCall{Call: call}
}

// MockStateGetApplicationsWithPendingCharmsFromUUIDsCall wrap *gomock.Call
type MockStateGetApplicationsWithPendingCharmsFromUUIDsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall) Return(arg0 []application.UUID, arg1 error) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall) Do(f func(context.Context, []application.UUID) ([]application.UUID, error)) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall) DoAndReturn(f func(context.Context, []application.UUID) ([]application.UUID, error)) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAsyncCharmDownloadInfo mocks base method.
func (m *MockState) GetAsyncCharmDownloadInfo(arg0 context.Context, arg1 application.UUID) (application0.CharmDownloadInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAsyncCharmDownloadInfo", arg0, arg1)
	ret0, _ := ret[0].(application0.CharmDownloadInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAsyncCharmDownloadInfo indicates an expected call of GetAsyncCharmDownloadInfo.
func (mr *MockStateMockRecorder) GetAsyncCharmDownloadInfo(arg0, arg1 any) *MockStateGetAsyncCharmDownloadInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAsyncCharmDownloadInfo", reflect.TypeOf((*MockState)(nil).GetAsyncCharmDownloadInfo), arg0, arg1)
	return &MockStateGetAsyncCharmDownloadInfoCall{Call: call}
}

// MockStateGetAsyncCharmDownloadInfoCall wrap *gomock.Call
type MockStateGetAsyncCharmDownloadInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAsyncCharmDownloadInfoCall) Return(arg0 application0.CharmDownloadInfo, arg1 error) *MockStateGetAsyncCharmDownloadInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAsyncCharmDownloadInfoCall) Do(f func(context.Context, application.UUID) (application0.CharmDownloadInfo, error)) *MockStateGetAsyncCharmDownloadInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAsyncCharmDownloadInfoCall) DoAndReturn(f func(context.Context, application.UUID) (application0.CharmDownloadInfo, error)) *MockStateGetAsyncCharmDownloadInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAvailableCharmArchiveSHA256 mocks base method.
func (m *MockState) GetAvailableCharmArchiveSHA256(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAvailableCharmArchiveSHA256", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAvailableCharmArchiveSHA256 indicates an expected call of GetAvailableCharmArchiveSHA256.
func (mr *MockStateMockRecorder) GetAvailableCharmArchiveSHA256(arg0, arg1 any) *MockStateGetAvailableCharmArchiveSHA256Call {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAvailableCharmArchiveSHA256", reflect.TypeOf((*MockState)(nil).GetAvailableCharmArchiveSHA256), arg0, arg1)
	return &MockStateGetAvailableCharmArchiveSHA256Call{Call: call}
}

// MockStateGetAvailableCharmArchiveSHA256Call wrap *gomock.Call
type MockStateGetAvailableCharmArchiveSHA256Call struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAvailableCharmArchiveSHA256Call) Return(arg0 string, arg1 error) *MockStateGetAvailableCharmArchiveSHA256Call {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAvailableCharmArchiveSHA256Call) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetAvailableCharmArchiveSHA256Call {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAvailableCharmArchiveSHA256Call) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetAvailableCharmArchiveSHA256Call {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCAASUnitRegistered mocks base method.
func (m *MockState) GetCAASUnitRegistered(arg0 context.Context, arg1 unit.Name) (bool, unit.UUID, network0.NetNodeUUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCAASUnitRegistered", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(unit.UUID)
	ret2, _ := ret[2].(network0.NetNodeUUID)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetCAASUnitRegistered indicates an expected call of GetCAASUnitRegistered.
func (mr *MockStateMockRecorder) GetCAASUnitRegistered(arg0, arg1 any) *MockStateGetCAASUnitRegisteredCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCAASUnitRegistered", reflect.TypeOf((*MockState)(nil).GetCAASUnitRegistered), arg0, arg1)
	return &MockStateGetCAASUnitRegisteredCall{Call: call}
}

// MockStateGetCAASUnitRegisteredCall wrap *gomock.Call
type MockStateGetCAASUnitRegisteredCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCAASUnitRegisteredCall) Return(arg0 bool, arg1 unit.UUID, arg2 network0.NetNodeUUID, arg3 error) *MockStateGetCAASUnitRegisteredCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCAASUnitRegisteredCall) Do(f func(context.Context, unit.Name) (bool, unit.UUID, network0.NetNodeUUID, error)) *MockStateGetCAASUnitRegisteredCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCAASUnitRegisteredCall) DoAndReturn(f func(context.Context, unit.Name) (bool, unit.UUID, network0.NetNodeUUID, error)) *MockStateGetCAASUnitRegisteredCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharm mocks base method.
func (m *MockState) GetCharm(arg0 context.Context, arg1 charm.ID) (charm0.Charm, *charm0.DownloadInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharm", arg0, arg1)
	ret0, _ := ret[0].(charm0.Charm)
	ret1, _ := ret[1].(*charm0.DownloadInfo)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharm indicates an expected call of GetCharm.
func (mr *MockStateMockRecorder) GetCharm(arg0, arg1 any) *MockStateGetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharm", reflect.TypeOf((*MockState)(nil).GetCharm), arg0, arg1)
	return &MockStateGetCharmCall{Call: call}
}

// MockStateGetCharmCall wrap *gomock.Call
type MockStateGetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmCall) Return(arg0 charm0.Charm, arg1 *charm0.DownloadInfo, arg2 error) *MockStateGetCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmCall) Do(f func(context.Context, charm.ID) (charm0.Charm, *charm0.DownloadInfo, error)) *MockStateGetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Charm, *charm0.DownloadInfo, error)) *MockStateGetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmActions mocks base method.
func (m *MockState) GetCharmActions(arg0 context.Context, arg1 charm.ID) (charm0.Actions, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmActions", arg0, arg1)
	ret0, _ := ret[0].(charm0.Actions)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmActions indicates an expected call of GetCharmActions.
func (mr *MockStateMockRecorder) GetCharmActions(arg0, arg1 any) *MockStateGetCharmActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmActions", reflect.TypeOf((*MockState)(nil).GetCharmActions), arg0, arg1)
	return &MockStateGetCharmActionsCall{Call: call}
}

// MockStateGetCharmActionsCall wrap *gomock.Call
type MockStateGetCharmActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmActionsCall) Return(arg0 charm0.Actions, arg1 error) *MockStateGetCharmActionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmActionsCall) Do(f func(context.Context, charm.ID) (charm0.Actions, error)) *MockStateGetCharmActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmActionsCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Actions, error)) *MockStateGetCharmActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmArchiveMetadata mocks base method.
func (m *MockState) GetCharmArchiveMetadata(arg0 context.Context, arg1 charm.ID) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmArchiveMetadata", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmArchiveMetadata indicates an expected call of GetCharmArchiveMetadata.
func (mr *MockStateMockRecorder) GetCharmArchiveMetadata(arg0, arg1 any) *MockStateGetCharmArchiveMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmArchiveMetadata", reflect.TypeOf((*MockState)(nil).GetCharmArchiveMetadata), arg0, arg1)
	return &MockStateGetCharmArchiveMetadataCall{Call: call}
}

// MockStateGetCharmArchiveMetadataCall wrap *gomock.Call
type MockStateGetCharmArchiveMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmArchiveMetadataCall) Return(arg0, arg1 string, arg2 error) *MockStateGetCharmArchiveMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmArchiveMetadataCall) Do(f func(context.Context, charm.ID) (string, string, error)) *MockStateGetCharmArchiveMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmArchiveMetadataCall) DoAndReturn(f func(context.Context, charm.ID) (string, string, error)) *MockStateGetCharmArchiveMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmArchivePath mocks base method.
func (m *MockState) GetCharmArchivePath(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmArchivePath", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmArchivePath indicates an expected call of GetCharmArchivePath.
func (mr *MockStateMockRecorder) GetCharmArchivePath(arg0, arg1 any) *MockStateGetCharmArchivePathCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmArchivePath", reflect.TypeOf((*MockState)(nil).GetCharmArchivePath), arg0, arg1)
	return &MockStateGetCharmArchivePathCall{Call: call}
}

// MockStateGetCharmArchivePathCall wrap *gomock.Call
type MockStateGetCharmArchivePathCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmArchivePathCall) Return(arg0 string, arg1 error) *MockStateGetCharmArchivePathCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmArchivePathCall) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmArchivePathCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmArchivePathCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmArchivePathCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmByApplicationUUID mocks base method.
func (m *MockState) GetCharmByApplicationUUID(arg0 context.Context, arg1 application.UUID) (charm0.Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmByApplicationUUID", arg0, arg1)
	ret0, _ := ret[0].(charm0.Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmByApplicationUUID indicates an expected call of GetCharmByApplicationUUID.
func (mr *MockStateMockRecorder) GetCharmByApplicationUUID(arg0, arg1 any) *MockStateGetCharmByApplicationUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmByApplicationUUID", reflect.TypeOf((*MockState)(nil).GetCharmByApplicationUUID), arg0, arg1)
	return &MockStateGetCharmByApplicationUUIDCall{Call: call}
}

// MockStateGetCharmByApplicationUUIDCall wrap *gomock.Call
type MockStateGetCharmByApplicationUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmByApplicationUUIDCall) Return(arg0 charm0.Charm, arg1 error) *MockStateGetCharmByApplicationUUIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmByApplicationUUIDCall) Do(f func(context.Context, application.UUID) (charm0.Charm, error)) *MockStateGetCharmByApplicationUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmByApplicationUUIDCall) DoAndReturn(f func(context.Context, application.UUID) (charm0.Charm, error)) *MockStateGetCharmByApplicationUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmConfig mocks base method.
func (m *MockState) GetCharmConfig(arg0 context.Context, arg1 charm.ID) (charm0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmConfig", arg0, arg1)
	ret0, _ := ret[0].(charm0.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmConfig indicates an expected call of GetCharmConfig.
func (mr *MockStateMockRecorder) GetCharmConfig(arg0, arg1 any) *MockStateGetCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmConfig", reflect.TypeOf((*MockState)(nil).GetCharmConfig), arg0, arg1)
	return &MockStateGetCharmConfigCall{Call: call}
}

// MockStateGetCharmConfigCall wrap *gomock.Call
type MockStateGetCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmConfigCall) Return(arg0 charm0.Config, arg1 error) *MockStateGetCharmConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmConfigCall) Do(f func(context.Context, charm.ID) (charm0.Config, error)) *MockStateGetCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmConfigCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Config, error)) *MockStateGetCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmConfigByApplicationUUID mocks base method.
func (m *MockState) GetCharmConfigByApplicationUUID(arg0 context.Context, arg1 application.UUID) (charm.ID, charm0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmConfigByApplicationUUID", arg0, arg1)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(charm0.Config)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmConfigByApplicationUUID indicates an expected call of GetCharmConfigByApplicationUUID.
func (mr *MockStateMockRecorder) GetCharmConfigByApplicationUUID(arg0, arg1 any) *MockStateGetCharmConfigByApplicationUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmConfigByApplicationUUID", reflect.TypeOf((*MockState)(nil).GetCharmConfigByApplicationUUID), arg0, arg1)
	return &MockStateGetCharmConfigByApplicationUUIDCall{Call: call}
}

// MockStateGetCharmConfigByApplicationUUIDCall wrap *gomock.Call
type MockStateGetCharmConfigByApplicationUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmConfigByApplicationUUIDCall) Return(arg0 charm.ID, arg1 charm0.Config, arg2 error) *MockStateGetCharmConfigByApplicationUUIDCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmConfigByApplicationUUIDCall) Do(f func(context.Context, application.UUID) (charm.ID, charm0.Config, error)) *MockStateGetCharmConfigByApplicationUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmConfigByApplicationUUIDCall) DoAndReturn(f func(context.Context, application.UUID) (charm.ID, charm0.Config, error)) *MockStateGetCharmConfigByApplicationUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmDownloadInfo mocks base method.
func (m *MockState) GetCharmDownloadInfo(arg0 context.Context, arg1 charm.ID) (*charm0.DownloadInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmDownloadInfo", arg0, arg1)
	ret0, _ := ret[0].(*charm0.DownloadInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmDownloadInfo indicates an expected call of GetCharmDownloadInfo.
func (mr *MockStateMockRecorder) GetCharmDownloadInfo(arg0, arg1 any) *MockStateGetCharmDownloadInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmDownloadInfo", reflect.TypeOf((*MockState)(nil).GetCharmDownloadInfo), arg0, arg1)
	return &MockStateGetCharmDownloadInfoCall{Call: call}
}

// MockStateGetCharmDownloadInfoCall wrap *gomock.Call
type MockStateGetCharmDownloadInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmDownloadInfoCall) Return(arg0 *charm0.DownloadInfo, arg1 error) *MockStateGetCharmDownloadInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmDownloadInfoCall) Do(f func(context.Context, charm.ID) (*charm0.DownloadInfo, error)) *MockStateGetCharmDownloadInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmDownloadInfoCall) DoAndReturn(f func(context.Context, charm.ID) (*charm0.DownloadInfo, error)) *MockStateGetCharmDownloadInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmID mocks base method.
func (m *MockState) GetCharmID(arg0 context.Context, arg1 string, arg2 int, arg3 charm0.CharmSource) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmID", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmID indicates an expected call of GetCharmID.
func (mr *MockStateMockRecorder) GetCharmID(arg0, arg1, arg2, arg3 any) *MockStateGetCharmIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmID", reflect.TypeOf((*MockState)(nil).GetCharmID), arg0, arg1, arg2, arg3)
	return &MockStateGetCharmIDCall{Call: call}
}

// MockStateGetCharmIDCall wrap *gomock.Call
type MockStateGetCharmIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmIDCall) Return(arg0 charm.ID, arg1 error) *MockStateGetCharmIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmIDCall) Do(f func(context.Context, string, int, charm0.CharmSource) (charm.ID, error)) *MockStateGetCharmIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmIDCall) DoAndReturn(f func(context.Context, string, int, charm0.CharmSource) (charm.ID, error)) *MockStateGetCharmIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmIDByApplicationName mocks base method.
func (m *MockState) GetCharmIDByApplicationName(arg0 context.Context, arg1 string) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmIDByApplicationName", arg0, arg1)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmIDByApplicationName indicates an expected call of GetCharmIDByApplicationName.
func (mr *MockStateMockRecorder) GetCharmIDByApplicationName(arg0, arg1 any) *MockStateGetCharmIDByApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmIDByApplicationName", reflect.TypeOf((*MockState)(nil).GetCharmIDByApplicationName), arg0, arg1)
	return &MockStateGetCharmIDByApplicationNameCall{Call: call}
}

// MockStateGetCharmIDByApplicationNameCall wrap *gomock.Call
type MockStateGetCharmIDByApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmIDByApplicationNameCall) Return(arg0 charm.ID, arg1 error) *MockStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmIDByApplicationNameCall) Do(f func(context.Context, string) (charm.ID, error)) *MockStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmIDByApplicationNameCall) DoAndReturn(f func(context.Context, string) (charm.ID, error)) *MockStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmLXDProfile mocks base method.
func (m *MockState) GetCharmLXDProfile(arg0 context.Context, arg1 charm.ID) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmLXDProfile", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmLXDProfile indicates an expected call of GetCharmLXDProfile.
func (mr *MockStateMockRecorder) GetCharmLXDProfile(arg0, arg1 any) *MockStateGetCharmLXDProfileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmLXDProfile", reflect.TypeOf((*MockState)(nil).GetCharmLXDProfile), arg0, arg1)
	return &MockStateGetCharmLXDProfileCall{Call: call}
}

// MockStateGetCharmLXDProfileCall wrap *gomock.Call
type MockStateGetCharmLXDProfileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmLXDProfileCall) Return(arg0 []byte, arg1 int, arg2 error) *MockStateGetCharmLXDProfileCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmLXDProfileCall) Do(f func(context.Context, charm.ID) ([]byte, int, error)) *MockStateGetCharmLXDProfileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmLXDProfileCall) DoAndReturn(f func(context.Context, charm.ID) ([]byte, int, error)) *MockStateGetCharmLXDProfileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmLocatorByCharmID mocks base method.
func (m *MockState) GetCharmLocatorByCharmID(arg0 context.Context, arg1 charm.ID) (charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmLocatorByCharmID", arg0, arg1)
	ret0, _ := ret[0].(charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmLocatorByCharmID indicates an expected call of GetCharmLocatorByCharmID.
func (mr *MockStateMockRecorder) GetCharmLocatorByCharmID(arg0, arg1 any) *MockStateGetCharmLocatorByCharmIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmLocatorByCharmID", reflect.TypeOf((*MockState)(nil).GetCharmLocatorByCharmID), arg0, arg1)
	return &MockStateGetCharmLocatorByCharmIDCall{Call: call}
}

// MockStateGetCharmLocatorByCharmIDCall wrap *gomock.Call
type MockStateGetCharmLocatorByCharmIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmLocatorByCharmIDCall) Return(arg0 charm0.CharmLocator, arg1 error) *MockStateGetCharmLocatorByCharmIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmLocatorByCharmIDCall) Do(f func(context.Context, charm.ID) (charm0.CharmLocator, error)) *MockStateGetCharmLocatorByCharmIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmLocatorByCharmIDCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.CharmLocator, error)) *MockStateGetCharmLocatorByCharmIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmManifest mocks base method.
func (m *MockState) GetCharmManifest(arg0 context.Context, arg1 charm.ID) (charm0.Manifest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmManifest", arg0, arg1)
	ret0, _ := ret[0].(charm0.Manifest)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmManifest indicates an expected call of GetCharmManifest.
func (mr *MockStateMockRecorder) GetCharmManifest(arg0, arg1 any) *MockStateGetCharmManifestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmManifest", reflect.TypeOf((*MockState)(nil).GetCharmManifest), arg0, arg1)
	return &MockStateGetCharmManifestCall{Call: call}
}

// MockStateGetCharmManifestCall wrap *gomock.Call
type MockStateGetCharmManifestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmManifestCall) Return(arg0 charm0.Manifest, arg1 error) *MockStateGetCharmManifestCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmManifestCall) Do(f func(context.Context, charm.ID) (charm0.Manifest, error)) *MockStateGetCharmManifestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmManifestCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Manifest, error)) *MockStateGetCharmManifestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadata mocks base method.
func (m *MockState) GetCharmMetadata(arg0 context.Context, arg1 charm.ID) (charm0.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadata", arg0, arg1)
	ret0, _ := ret[0].(charm0.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadata indicates an expected call of GetCharmMetadata.
func (mr *MockStateMockRecorder) GetCharmMetadata(arg0, arg1 any) *MockStateGetCharmMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadata", reflect.TypeOf((*MockState)(nil).GetCharmMetadata), arg0, arg1)
	return &MockStateGetCharmMetadataCall{Call: call}
}

// MockStateGetCharmMetadataCall wrap *gomock.Call
type MockStateGetCharmMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataCall) Return(arg0 charm0.Metadata, arg1 error) *MockStateGetCharmMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataCall) Do(f func(context.Context, charm.ID) (charm0.Metadata, error)) *MockStateGetCharmMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Metadata, error)) *MockStateGetCharmMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataDescription mocks base method.
func (m *MockState) GetCharmMetadataDescription(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataDescription", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataDescription indicates an expected call of GetCharmMetadataDescription.
func (mr *MockStateMockRecorder) GetCharmMetadataDescription(arg0, arg1 any) *MockStateGetCharmMetadataDescriptionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataDescription", reflect.TypeOf((*MockState)(nil).GetCharmMetadataDescription), arg0, arg1)
	return &MockStateGetCharmMetadataDescriptionCall{Call: call}
}

// MockStateGetCharmMetadataDescriptionCall wrap *gomock.Call
type MockStateGetCharmMetadataDescriptionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataDescriptionCall) Return(arg0 string, arg1 error) *MockStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataDescriptionCall) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataDescriptionCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataName mocks base method.
func (m *MockState) GetCharmMetadataName(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataName", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataName indicates an expected call of GetCharmMetadataName.
func (mr *MockStateMockRecorder) GetCharmMetadataName(arg0, arg1 any) *MockStateGetCharmMetadataNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataName", reflect.TypeOf((*MockState)(nil).GetCharmMetadataName), arg0, arg1)
	return &MockStateGetCharmMetadataNameCall{Call: call}
}

// MockStateGetCharmMetadataNameCall wrap *gomock.Call
type MockStateGetCharmMetadataNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataNameCall) Return(arg0 string, arg1 error) *MockStateGetCharmMetadataNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataNameCall) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataNameCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataResources mocks base method.
func (m *MockState) GetCharmMetadataResources(arg0 context.Context, arg1 charm.ID) (map[string]charm0.Resource, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataResources", arg0, arg1)
	ret0, _ := ret[0].(map[string]charm0.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataResources indicates an expected call of GetCharmMetadataResources.
func (mr *MockStateMockRecorder) GetCharmMetadataResources(arg0, arg1 any) *MockStateGetCharmMetadataResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataResources", reflect.TypeOf((*MockState)(nil).GetCharmMetadataResources), arg0, arg1)
	return &MockStateGetCharmMetadataResourcesCall{Call: call}
}

// MockStateGetCharmMetadataResourcesCall wrap *gomock.Call
type MockStateGetCharmMetadataResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataResourcesCall) Return(arg0 map[string]charm0.Resource, arg1 error) *MockStateGetCharmMetadataResourcesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataResourcesCall) Do(f func(context.Context, charm.ID) (map[string]charm0.Resource, error)) *MockStateGetCharmMetadataResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataResourcesCall) DoAndReturn(f func(context.Context, charm.ID) (map[string]charm0.Resource, error)) *MockStateGetCharmMetadataResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataStorage mocks base method.
func (m *MockState) GetCharmMetadataStorage(arg0 context.Context, arg1 charm.ID) (map[string]charm0.Storage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataStorage", arg0, arg1)
	ret0, _ := ret[0].(map[string]charm0.Storage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataStorage indicates an expected call of GetCharmMetadataStorage.
func (mr *MockStateMockRecorder) GetCharmMetadataStorage(arg0, arg1 any) *MockStateGetCharmMetadataStorageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataStorage", reflect.TypeOf((*MockState)(nil).GetCharmMetadataStorage), arg0, arg1)
	return &MockStateGetCharmMetadataStorageCall{Call: call}
}

// MockStateGetCharmMetadataStorageCall wrap *gomock.Call
type MockStateGetCharmMetadataStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataStorageCall) Return(arg0 map[string]charm0.Storage, arg1 error) *MockStateGetCharmMetadataStorageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataStorageCall) Do(f func(context.Context, charm.ID) (map[string]charm0.Storage, error)) *MockStateGetCharmMetadataStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataStorageCall) DoAndReturn(f func(context.Context, charm.ID) (map[string]charm0.Storage, error)) *MockStateGetCharmMetadataStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmModifiedVersion mocks base method.
func (m *MockState) GetCharmModifiedVersion(arg0 context.Context, arg1 application.UUID) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmModifiedVersion", arg0, arg1)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmModifiedVersion indicates an expected call of GetCharmModifiedVersion.
func (mr *MockStateMockRecorder) GetCharmModifiedVersion(arg0, arg1 any) *MockStateGetCharmModifiedVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmModifiedVersion", reflect.TypeOf((*MockState)(nil).GetCharmModifiedVersion), arg0, arg1)
	return &MockStateGetCharmModifiedVersionCall{Call: call}
}

// MockStateGetCharmModifiedVersionCall wrap *gomock.Call
type MockStateGetCharmModifiedVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmModifiedVersionCall) Return(arg0 int, arg1 error) *MockStateGetCharmModifiedVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmModifiedVersionCall) Do(f func(context.Context, application.UUID) (int, error)) *MockStateGetCharmModifiedVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmModifiedVersionCall) DoAndReturn(f func(context.Context, application.UUID) (int, error)) *MockStateGetCharmModifiedVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetDeviceConstraints mocks base method.
func (m *MockState) GetDeviceConstraints(arg0 context.Context, arg1 application.UUID) (map[string]devices.Constraints, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDeviceConstraints", arg0, arg1)
	ret0, _ := ret[0].(map[string]devices.Constraints)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDeviceConstraints indicates an expected call of GetDeviceConstraints.
func (mr *MockStateMockRecorder) GetDeviceConstraints(arg0, arg1 any) *MockStateGetDeviceConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDeviceConstraints", reflect.TypeOf((*MockState)(nil).GetDeviceConstraints), arg0, arg1)
	return &MockStateGetDeviceConstraintsCall{Call: call}
}

// MockStateGetDeviceConstraintsCall wrap *gomock.Call
type MockStateGetDeviceConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetDeviceConstraintsCall) Return(arg0 map[string]devices.Constraints, arg1 error) *MockStateGetDeviceConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetDeviceConstraintsCall) Do(f func(context.Context, application.UUID) (map[string]devices.Constraints, error)) *MockStateGetDeviceConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetDeviceConstraintsCall) DoAndReturn(f func(context.Context, application.UUID) (map[string]devices.Constraints, error)) *MockStateGetDeviceConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetExposedEndpoints mocks base method.
func (m *MockState) GetExposedEndpoints(arg0 context.Context, arg1 application.UUID) (map[string]application0.ExposedEndpoint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetExposedEndpoints", arg0, arg1)
	ret0, _ := ret[0].(map[string]application0.ExposedEndpoint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExposedEndpoints indicates an expected call of GetExposedEndpoints.
func (mr *MockStateMockRecorder) GetExposedEndpoints(arg0, arg1 any) *MockStateGetExposedEndpointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExposedEndpoints", reflect.TypeOf((*MockState)(nil).GetExposedEndpoints), arg0, arg1)
	return &MockStateGetExposedEndpointsCall{Call: call}
}

// MockStateGetExposedEndpointsCall wrap *gomock.Call
type MockStateGetExposedEndpointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetExposedEndpointsCall) Return(arg0 map[string]application0.ExposedEndpoint, arg1 error) *MockStateGetExposedEndpointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetExposedEndpointsCall) Do(f func(context.Context, application.UUID) (map[string]application0.ExposedEndpoint, error)) *MockStateGetExposedEndpointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetExposedEndpointsCall) DoAndReturn(f func(context.Context, application.UUID) (map[string]application0.ExposedEndpoint, error)) *MockStateGetExposedEndpointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLatestPendingCharmhubCharm mocks base method.
func (m *MockState) GetLatestPendingCharmhubCharm(arg0 context.Context, arg1 string, arg2 architecture.Architecture) (charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestPendingCharmhubCharm", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestPendingCharmhubCharm indicates an expected call of GetLatestPendingCharmhubCharm.
func (mr *MockStateMockRecorder) GetLatestPendingCharmhubCharm(arg0, arg1, arg2 any) *MockStateGetLatestPendingCharmhubCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestPendingCharmhubCharm", reflect.TypeOf((*MockState)(nil).GetLatestPendingCharmhubCharm), arg0, arg1, arg2)
	return &MockStateGetLatestPendingCharmhubCharmCall{Call: call}
}

// MockStateGetLatestPendingCharmhubCharmCall wrap *gomock.Call
type MockStateGetLatestPendingCharmhubCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetLatestPendingCharmhubCharmCall) Return(arg0 charm0.CharmLocator, arg1 error) *MockStateGetLatestPendingCharmhubCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetLatestPendingCharmhubCharmCall) Do(f func(context.Context, string, architecture.Architecture) (charm0.CharmLocator, error)) *MockStateGetLatestPendingCharmhubCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetLatestPendingCharmhubCharmCall) DoAndReturn(f func(context.Context, string, architecture.Architecture) (charm0.CharmLocator, error)) *MockStateGetLatestPendingCharmhubCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMachineNetNodeUUIDFromName mocks base method.
func (m *MockState) GetMachineNetNodeUUIDFromName(arg0 context.Context, arg1 machine.Name) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMachineNetNodeUUIDFromName", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMachineNetNodeUUIDFromName indicates an expected call of GetMachineNetNodeUUIDFromName.
func (mr *MockStateMockRecorder) GetMachineNetNodeUUIDFromName(arg0, arg1 any) *MockStateGetMachineNetNodeUUIDFromNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMachineNetNodeUUIDFromName", reflect.TypeOf((*MockState)(nil).GetMachineNetNodeUUIDFromName), arg0, arg1)
	return &MockStateGetMachineNetNodeUUIDFromNameCall{Call: call}
}

// MockStateGetMachineNetNodeUUIDFromNameCall wrap *gomock.Call
type MockStateGetMachineNetNodeUUIDFromNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetMachineNetNodeUUIDFromNameCall) Return(arg0 string, arg1 error) *MockStateGetMachineNetNodeUUIDFromNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetMachineNetNodeUUIDFromNameCall) Do(f func(context.Context, machine.Name) (string, error)) *MockStateGetMachineNetNodeUUIDFromNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetMachineNetNodeUUIDFromNameCall) DoAndReturn(f func(context.Context, machine.Name) (string, error)) *MockStateGetMachineNetNodeUUIDFromNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMachineUUIDAndNetNodeForName mocks base method.
func (m *MockState) GetMachineUUIDAndNetNodeForName(arg0 context.Context, arg1 string) (machine.UUID, network0.NetNodeUUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMachineUUIDAndNetNodeForName", arg0, arg1)
	ret0, _ := ret[0].(machine.UUID)
	ret1, _ := ret[1].(network0.NetNodeUUID)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetMachineUUIDAndNetNodeForName indicates an expected call of GetMachineUUIDAndNetNodeForName.
func (mr *MockStateMockRecorder) GetMachineUUIDAndNetNodeForName(arg0, arg1 any) *MockStateGetMachineUUIDAndNetNodeForNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMachineUUIDAndNetNodeForName", reflect.TypeOf((*MockState)(nil).GetMachineUUIDAndNetNodeForName), arg0, arg1)
	return &MockStateGetMachineUUIDAndNetNodeForNameCall{Call: call}
}

// MockStateGetMachineUUIDAndNetNodeForNameCall wrap *gomock.Call
type MockStateGetMachineUUIDAndNetNodeForNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetMachineUUIDAndNetNodeForNameCall) Return(arg0 machine.UUID, arg1 network0.NetNodeUUID, arg2 error) *MockStateGetMachineUUIDAndNetNodeForNameCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetMachineUUIDAndNetNodeForNameCall) Do(f func(context.Context, string) (machine.UUID, network0.NetNodeUUID, error)) *MockStateGetMachineUUIDAndNetNodeForNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetMachineUUIDAndNetNodeForNameCall) DoAndReturn(f func(context.Context, string) (machine.UUID, network0.NetNodeUUID, error)) *MockStateGetMachineUUIDAndNetNodeForNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMachinesForApplication mocks base method.
func (m *MockState) GetMachinesForApplication(arg0 context.Context, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMachinesForApplication", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMachinesForApplication indicates an expected call of GetMachinesForApplication.
func (mr *MockStateMockRecorder) GetMachinesForApplication(arg0, arg1 any) *MockStateGetMachinesForApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMachinesForApplication", reflect.TypeOf((*MockState)(nil).GetMachinesForApplication), arg0, arg1)
	return &MockStateGetMachinesForApplicationCall{Call: call}
}

// MockStateGetMachinesForApplicationCall wrap *gomock.Call
type MockStateGetMachinesForApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetMachinesForApplicationCall) Return(arg0 []string, arg1 error) *MockStateGetMachinesForApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetMachinesForApplicationCall) Do(f func(context.Context, string) ([]string, error)) *MockStateGetMachinesForApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetMachinesForApplicationCall) DoAndReturn(f func(context.Context, string) ([]string, error)) *MockStateGetMachinesForApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetModelConstraints mocks base method.
func (m *MockState) GetModelConstraints(arg0 context.Context) (constraints0.Constraints, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModelConstraints", arg0)
	ret0, _ := ret[0].(constraints0.Constraints)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModelConstraints indicates an expected call of GetModelConstraints.
func (mr *MockStateMockRecorder) GetModelConstraints(arg0 any) *MockStateGetModelConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelConstraints", reflect.TypeOf((*MockState)(nil).GetModelConstraints), arg0)
	return &MockStateGetModelConstraintsCall{Call: call}
}

// MockStateGetModelConstraintsCall wrap *gomock.Call
type MockStateGetModelConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetModelConstraintsCall) Return(arg0 constraints0.Constraints, arg1 error) *MockStateGetModelConstraintsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetModelConstraintsCall) Do(f func(context.Context) (constraints0.Constraints, error)) *MockStateGetModelConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetModelConstraintsCall) DoAndReturn(f func(context.Context) (constraints0.Constraints, error)) *MockStateGetModelConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNetNodeUUIDByUnitName mocks base method.
func (m *MockState) GetNetNodeUUIDByUnitName(arg0 context.Context, arg1 unit.Name) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNetNodeUUIDByUnitName", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNetNodeUUIDByUnitName indicates an expected call of GetNetNodeUUIDByUnitName.
func (mr *MockStateMockRecorder) GetNetNodeUUIDByUnitName(arg0, arg1 any) *MockStateGetNetNodeUUIDByUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNetNodeUUIDByUnitName", reflect.TypeOf((*MockState)(nil).GetNetNodeUUIDByUnitName), arg0, arg1)
	return &MockStateGetNetNodeUUIDByUnitNameCall{Call: call}
}

// MockStateGetNetNodeUUIDByUnitNameCall wrap *gomock.Call
type MockStateGetNetNodeUUIDByUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetNetNodeUUIDByUnitNameCall) Return(arg0 string, arg1 error) *MockStateGetNetNodeUUIDByUnitNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetNetNodeUUIDByUnitNameCall) Do(f func(context.Context, unit.Name) (string, error)) *MockStateGetNetNodeUUIDByUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetNetNodeUUIDByUnitNameCall) DoAndReturn(f func(context.Context, unit.Name) (string, error)) *MockStateGetNetNodeUUIDByUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSpaceUUIDByName mocks base method.
func (m *MockState) GetSpaceUUIDByName(arg0 context.Context, arg1 string) (network.SpaceUUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSpaceUUIDByName", arg0, arg1)
	ret0, _ := ret[0].(network.SpaceUUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSpaceUUIDByName indicates an expected call of GetSpaceUUIDByName.
func (mr *MockStateMockRecorder) GetSpaceUUIDByName(arg0, arg1 any) *MockStateGetSpaceUUIDByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSpaceUUIDByName", reflect.TypeOf((*MockState)(nil).GetSpaceUUIDByName), arg0, arg1)
	return &MockStateGetSpaceUUIDByNameCall{Call: call}
}

// MockStateGetSpaceUUIDByNameCall wrap *gomock.Call
type MockStateGetSpaceUUIDByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetSpaceUUIDByNameCall) Return(arg0 network.SpaceUUID, arg1 error) *MockStateGetSpaceUUIDByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetSpaceUUIDByNameCall) Do(f func(context.Context, string) (network.SpaceUUID, error)) *MockStateGetSpaceUUIDByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetSpaceUUIDByNameCall) DoAndReturn(f func(context.Context, string) (network.SpaceUUID, error)) *MockStateGetSpaceUUIDByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitK8sPodInfo mocks base method.
func (m *MockState) GetUnitK8sPodInfo(arg0 context.Context, arg1 unit.Name) (application0.K8sPodInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitK8sPodInfo", arg0, arg1)
	ret0, _ := ret[0].(application0.K8sPodInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitK8sPodInfo indicates an expected call of GetUnitK8sPodInfo.
func (mr *MockStateMockRecorder) GetUnitK8sPodInfo(arg0, arg1 any) *MockStateGetUnitK8sPodInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitK8sPodInfo", reflect.TypeOf((*MockState)(nil).GetUnitK8sPodInfo), arg0, arg1)
	return &MockStateGetUnitK8sPodInfoCall{Call: call}
}

// MockStateGetUnitK8sPodInfoCall wrap *gomock.Call
type MockStateGetUnitK8sPodInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitK8sPodInfoCall) Return(arg0 application0.K8sPodInfo, arg1 error) *MockStateGetUnitK8sPodInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitK8sPodInfoCall) Do(f func(context.Context, unit.Name) (application0.K8sPodInfo, error)) *MockStateGetUnitK8sPodInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitK8sPodInfoCall) DoAndReturn(f func(context.Context, unit.Name) (application0.K8sPodInfo, error)) *MockStateGetUnitK8sPodInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitLife mocks base method.
func (m *MockState) GetUnitLife(arg0 context.Context, arg1 unit.Name) (life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitLife", arg0, arg1)
	ret0, _ := ret[0].(life.Life)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitLife indicates an expected call of GetUnitLife.
func (mr *MockStateMockRecorder) GetUnitLife(arg0, arg1 any) *MockStateGetUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitLife", reflect.TypeOf((*MockState)(nil).GetUnitLife), arg0, arg1)
	return &MockStateGetUnitLifeCall{Call: call}
}

// MockStateGetUnitLifeCall wrap *gomock.Call
type MockStateGetUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitLifeCall) Return(arg0 life.Life, arg1 error) *MockStateGetUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitLifeCall) Do(f func(context.Context, unit.Name) (life.Life, error)) *MockStateGetUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitLifeCall) DoAndReturn(f func(context.Context, unit.Name) (life.Life, error)) *MockStateGetUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitMachineName mocks base method.
func (m *MockState) GetUnitMachineName(arg0 context.Context, arg1 unit.Name) (machine.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitMachineName", arg0, arg1)
	ret0, _ := ret[0].(machine.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitMachineName indicates an expected call of GetUnitMachineName.
func (mr *MockStateMockRecorder) GetUnitMachineName(arg0, arg1 any) *MockStateGetUnitMachineNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitMachineName", reflect.TypeOf((*MockState)(nil).GetUnitMachineName), arg0, arg1)
	return &MockStateGetUnitMachineNameCall{Call: call}
}

// MockStateGetUnitMachineNameCall wrap *gomock.Call
type MockStateGetUnitMachineNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitMachineNameCall) Return(arg0 machine.Name, arg1 error) *MockStateGetUnitMachineNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitMachineNameCall) Do(f func(context.Context, unit.Name) (machine.Name, error)) *MockStateGetUnitMachineNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitMachineNameCall) DoAndReturn(f func(context.Context, unit.Name) (machine.Name, error)) *MockStateGetUnitMachineNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitMachineUUID mocks base method.
func (m *MockState) GetUnitMachineUUID(arg0 context.Context, arg1 unit.Name) (machine.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitMachineUUID", arg0, arg1)
	ret0, _ := ret[0].(machine.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitMachineUUID indicates an expected call of GetUnitMachineUUID.
func (mr *MockStateMockRecorder) GetUnitMachineUUID(arg0, arg1 any) *MockStateGetUnitMachineUUIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitMachineUUID", reflect.TypeOf((*MockState)(nil).GetUnitMachineUUID), arg0, arg1)
	return &MockStateGetUnitMachineUUIDCall{Call: call}
}

// MockStateGetUnitMachineUUIDCall wrap *gomock.Call
type MockStateGetUnitMachineUUIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitMachineUUIDCall) Return(arg0 machine.UUID, arg1 error) *MockStateGetUnitMachineUUIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitMachineUUIDCall) Do(f func(context.Context, unit.Name) (machine.UUID, error)) *MockStateGetUnitMachineUUIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitMachineUUIDCall) DoAndReturn(f func(context.Context, unit.Name) (machine.UUID, error)) *MockStateGetUnitMachineUUIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitNamesForApplication mocks base method.
func (m *MockState) GetUnitNamesForApplication(arg0 context.Context, arg1 application.UUID) ([]unit.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitNamesForApplication", arg0, arg1)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitNamesForApplication indicates an expected call of GetUnitNamesForApplication.
func (mr *MockStateMockRecorder) GetUnitNamesForApplication(arg0, arg1 any) *MockStateGetUnitNamesForApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitNamesForApplication", reflect.TypeOf((*MockState)(nil).GetUnitNamesForApplication), arg0, arg1)
	return &MockStateGetUnitNamesForApplicationCall{Call: call}
}

// MockStateGetUnitNamesForApplicationCall wrap *gomock.Call
type MockStateGetUnitNamesForApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitNamesForApplicationCall) Return(arg0 []unit.Name, arg1 error) *MockStateGetUnitNamesForApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitNamesForApplicationCall) Do(f func(context.Context, application.UUID) ([]unit.Name, error)) *MockStateGetUnitNamesForApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitNamesForApplicationCall) DoAndReturn(f func(context.Context, application.UUID) ([]unit.Name, error)) *MockStateGetUnitNamesForApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitNamesForNetNode mocks base method.
func (m *MockState) GetUnitNamesForNetNode(arg0 context.Context, arg1 string) ([]unit.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitNamesForNetNode", arg0, arg1)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitNamesForNetNode indicates an expected call of GetUnitNamesForNetNode.
func (mr *MockStateMockRecorder) GetUnitNamesForNetNode(arg0, arg1 any) *MockStateGetUnitNamesForNetNodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitNamesForNetNode", reflect.TypeOf((*MockState)(nil).GetUnitNamesForNetNode), arg0, arg1)
	return &MockStateGetUnitNamesForNetNodeCall{Call: call}
}

// MockStateGetUnitNamesForNetNodeCall wrap *gomock.Call
type MockStateGetUnitNamesForNetNodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitNamesForNetNodeCall) Return(arg0 []unit.Name, arg1 error) *MockStateGetUnitNamesForNetNodeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitNamesForNetNodeCall) Do(f func(context.Context, string) ([]unit.Name, error)) *MockStateGetUnitNamesForNetNodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitNamesForNetNodeCall) DoAndReturn(f func(context.Context, string) ([]unit.Name, error)) *MockStateGetUnitNamesForNetNodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitNetNodesByName mocks base method.
func (m *MockState) GetUnitNetNodesByName(arg0 context.Context, arg1 unit.Name) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitNetNodesByName", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitNetNodesByName indicates an expected call of GetUnitNetNodesByName.
func (mr *MockStateMockRecorder) GetUnitNetNodesByName(arg0, arg1 any) *MockStateGetUnitNetNodesByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitNetNodesByName", reflect.TypeOf((*MockState)(nil).GetUnitNetNodesByName), arg0, arg1)
	return &MockStateGetUnitNetNodesByNameCall{Call: call}
}

// MockStateGetUnitNetNodesByNameCall wrap *gomock.Call
type MockStateGetUnitNetNodesByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitNetNodesByNameCall) Return(arg0 []string, arg1 error) *MockStateGetUnitNetNodesByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitNetNodesByNameCall) Do(f func(context.Context, unit.Name) ([]string, error)) *MockStateGetUnitNetNodesByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitNetNodesByNameCall) DoAndReturn(f func(context.Context, unit.Name) ([]string, error)) *MockStateGetUnitNetNodesByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitPrincipal mocks base method.
func (m *MockState) GetUnitPrincipal(arg0 context.Context, arg1 unit.Name) (unit.Name, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitPrincipal", arg0, arg1)
	ret0, _ := ret[0].(unit.Name)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUnitPrincipal indicates an expected call of GetUnitPrincipal.
func (mr *MockStateMockRecorder) GetUnitPrincipal(arg0, arg1 any) *MockStateGetUnitPrincipalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitPrincipal", reflect.TypeOf((*MockState)(nil).GetUnitPrincipal), arg0, arg1)
	return &MockStateGetUnitPrincipalCall{Call: call}
}

// MockStateGetUnitPrincipalCall wrap *gomock.Call
type MockStateGetUnitPrincipalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitPrincipalCall) Return(arg0 unit.Name, arg1 bool, arg2 error) *MockStateGetUnitPrincipalCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitPrincipalCall) Do(f func(context.Context, unit.Name) (unit.Name, bool, error)) *MockStateGetUnitPrincipalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitPrincipalCall) DoAndReturn(f func(context.Context, unit.Name) (unit.Name, bool, error)) *MockStateGetUnitPrincipalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitRefreshAttributes mocks base method.
func (m *MockState) GetUnitRefreshAttributes(arg0 context.Context, arg1 unit.Name) (application0.UnitAttributes, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitRefreshAttributes", arg0, arg1)
	ret0, _ := ret[0].(application0.UnitAttributes)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitRefreshAttributes indicates an expected call of GetUnitRefreshAttributes.
func (mr *MockStateMockRecorder) GetUnitRefreshAttributes(arg0, arg1 any) *MockStateGetUnitRefreshAttributesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitRefreshAttributes", reflect.TypeOf((*MockState)(nil).GetUnitRefreshAttributes), arg0, arg1)
	return &MockStateGetUnitRefreshAttributesCall{Call: call}
}

// MockStateGetUnitRefreshAttributesCall wrap *gomock.Call
type MockStateGetUnitRefreshAttributesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitRefreshAttributesCall) Return(arg0 application0.UnitAttributes, arg1 error) *MockStateGetUnitRefreshAttributesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitRefreshAttributesCall) Do(f func(context.Context, unit.Name) (application0.UnitAttributes, error)) *MockStateGetUnitRefreshAttributesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitRefreshAttributesCall) DoAndReturn(f func(context.Context, unit.Name) (application0.UnitAttributes, error)) *MockStateGetUnitRefreshAttributesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitSubordinates mocks base method.
func (m *MockState) GetUnitSubordinates(arg0 context.Context, arg1 unit.Name) ([]unit.Name, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitSubordinates", arg0, arg1)
	ret0, _ := ret[0].([]unit.Name)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitSubordinates indicates an expected call of GetUnitSubordinates.
func (mr *MockStateMockRecorder) GetUnitSubordinates(arg0, arg1 any) *MockStateGetUnitSubordinatesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitSubordinates", reflect.TypeOf((*MockState)(nil).GetUnitSubordinates), arg0, arg1)
	return &MockStateGetUnitSubordinatesCall{Call: call}
}

// MockStateGetUnitSubordinatesCall wrap *gomock.Call
type MockStateGetUnitSubordinatesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitSubordinatesCall) Return(arg0 []unit.Name, arg1 error) *MockStateGetUnitSubordinatesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitSubordinatesCall) Do(f func(context.Context, unit.Name) ([]unit.Name, error)) *MockStateGetUnitSubordinatesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitSubordinatesCall) DoAndReturn(f func(context.Context, unit.Name) ([]unit.Name, error)) *MockStateGetUnitSubordinatesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitUUIDAndNetNodeForName mocks base method.
func (m *MockState) GetUnitUUIDAndNetNodeForName(arg0 context.Context, arg1 unit.Name) (unit.UUID, network0.NetNodeUUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitUUIDAndNetNodeForName", arg0, arg1)
	ret0, _ := ret[0].(unit.UUID)
	ret1, _ := ret[1].(network0.NetNodeUUID)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUnitUUIDAndNetNodeForName indicates an expected call of GetUnitUUIDAndNetNodeForName.
func (mr *MockStateMockRecorder) GetUnitUUIDAndNetNodeForName(arg0, arg1 any) *MockStateGetUnitUUIDAndNetNodeForNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitUUIDAndNetNodeForName", reflect.TypeOf((*MockState)(nil).GetUnitUUIDAndNetNodeForName), arg0, arg1)
	return &MockStateGetUnitUUIDAndNetNodeForNameCall{Call: call}
}

// MockStateGetUnitUUIDAndNetNodeForNameCall wrap *gomock.Call
type MockStateGetUnitUUIDAndNetNodeForNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitUUIDAndNetNodeForNameCall) Return(arg0 unit.UUID, arg1 network0.NetNodeUUID, arg2 error) *MockStateGetUnitUUIDAndNetNodeForNameCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitUUIDAndNetNodeForNameCall) Do(f func(context.Context, unit.Name) (unit.UUID, network0.NetNodeUUID, error)) *MockStateGetUnitUUIDAndNetNodeForNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitUUIDAndNetNodeForNameCall) DoAndReturn(f func(context.Context, unit.Name) (unit.UUID, network0.NetNodeUUID, error)) *MockStateGetUnitUUIDAndNetNodeForNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitUUIDByName mocks base method.
func (m *MockState) GetUnitUUIDByName(arg0 context.Context, arg1 unit.Name) (unit.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitUUIDByName", arg0, arg1)
	ret0, _ := ret[0].(unit.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitUUIDByName indicates an expected call of GetUnitUUIDByName.
func (mr *MockStateMockRecorder) GetUnitUUIDByName(arg0, arg1 any) *MockStateGetUnitUUIDByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitUUIDByName", reflect.TypeOf((*MockState)(nil).GetUnitUUIDByName), arg0, arg1)
	return &MockStateGetUnitUUIDByNameCall{Call: call}
}

// MockStateGetUnitUUIDByNameCall wrap *gomock.Call
type MockStateGetUnitUUIDByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitUUIDByNameCall) Return(arg0 unit.UUID, arg1 error) *MockStateGetUnitUUIDByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitUUIDByNameCall) Do(f func(context.Context, unit.Name) (unit.UUID, error)) *MockStateGetUnitUUIDByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitUUIDByNameCall) DoAndReturn(f func(context.Context, unit.Name) (unit.UUID, error)) *MockStateGetUnitUUIDByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitWorkloadVersion mocks base method.
func (m *MockState) GetUnitWorkloadVersion(arg0 context.Context, arg1 unit.Name) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitWorkloadVersion", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitWorkloadVersion indicates an expected call of GetUnitWorkloadVersion.
func (mr *MockStateMockRecorder) GetUnitWorkloadVersion(arg0, arg1 any) *MockStateGetUnitWorkloadVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitWorkloadVersion", reflect.TypeOf((*MockState)(nil).GetUnitWorkloadVersion), arg0, arg1)
	return &MockStateGetUnitWorkloadVersionCall{Call: call}
}

// MockStateGetUnitWorkloadVersionCall wrap *gomock.Call
type MockStateGetUnitWorkloadVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitWorkloadVersionCall) Return(arg0 string, arg1 error) *MockStateGetUnitWorkloadVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitWorkloadVersionCall) Do(f func(context.Context, unit.Name) (string, error)) *MockStateGetUnitWorkloadVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitWorkloadVersionCall) DoAndReturn(f func(context.Context, unit.Name) (string, error)) *MockStateGetUnitWorkloadVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitsK8sPodInfo mocks base method.
func (m *MockState) GetUnitsK8sPodInfo(arg0 context.Context) (map[string]internal.UnitK8sInformation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitsK8sPodInfo", arg0)
	ret0, _ := ret[0].(map[string]internal.UnitK8sInformation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitsK8sPodInfo indicates an expected call of GetUnitsK8sPodInfo.
func (mr *MockStateMockRecorder) GetUnitsK8sPodInfo(arg0 any) *MockStateGetUnitsK8sPodInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitsK8sPodInfo", reflect.TypeOf((*MockState)(nil).GetUnitsK8sPodInfo), arg0)
	return &MockStateGetUnitsK8sPodInfoCall{Call: call}
}

// MockStateGetUnitsK8sPodInfoCall wrap *gomock.Call
type MockStateGetUnitsK8sPodInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitsK8sPodInfoCall) Return(arg0 map[string]internal.UnitK8sInformation, arg1 error) *MockStateGetUnitsK8sPodInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitsK8sPodInfoCall) Do(f func(context.Context) (map[string]internal.UnitK8sInformation, error)) *MockStateGetUnitsK8sPodInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitsK8sPodInfoCall) DoAndReturn(f func(context.Context) (map[string]internal.UnitK8sInformation, error)) *MockStateGetUnitsK8sPodInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementApplicationConfigHash mocks base method.
func (m *MockState) InitialWatchStatementApplicationConfigHash(arg0 string) (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementApplicationConfigHash", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementApplicationConfigHash indicates an expected call of InitialWatchStatementApplicationConfigHash.
func (mr *MockStateMockRecorder) InitialWatchStatementApplicationConfigHash(arg0 any) *MockStateInitialWatchStatementApplicationConfigHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementApplicationConfigHash", reflect.TypeOf((*MockState)(nil).InitialWatchStatementApplicationConfigHash), arg0)
	return &MockStateInitialWatchStatementApplicationConfigHashCall{Call: call}
}

// MockStateInitialWatchStatementApplicationConfigHashCall wrap *gomock.Call
type MockStateInitialWatchStatementApplicationConfigHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementApplicationConfigHashCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementApplicationConfigHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementApplicationConfigHashCall) Do(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationConfigHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementApplicationConfigHashCall) DoAndReturn(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationConfigHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementApplications mocks base method.
func (m *MockState) InitialWatchStatementApplications() (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementApplications")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementApplications indicates an expected call of InitialWatchStatementApplications.
func (mr *MockStateMockRecorder) InitialWatchStatementApplications() *MockStateInitialWatchStatementApplicationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementApplications", reflect.TypeOf((*MockState)(nil).InitialWatchStatementApplications))
	return &MockStateInitialWatchStatementApplicationsCall{Call: call}
}

// MockStateInitialWatchStatementApplicationsCall wrap *gomock.Call
type MockStateInitialWatchStatementApplicationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementApplicationsCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementApplicationsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementApplicationsCall) Do(f func() (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementApplicationsCall) DoAndReturn(f func() (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementApplicationsWithPendingCharms mocks base method.
func (m *MockState) InitialWatchStatementApplicationsWithPendingCharms() (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementApplicationsWithPendingCharms")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementApplicationsWithPendingCharms indicates an expected call of InitialWatchStatementApplicationsWithPendingCharms.
func (mr *MockStateMockRecorder) InitialWatchStatementApplicationsWithPendingCharms() *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementApplicationsWithPendingCharms", reflect.TypeOf((*MockState)(nil).InitialWatchStatementApplicationsWithPendingCharms))
	return &MockStateInitialWatchStatementApplicationsWithPendingCharmsCall{Call: call}
}

// MockStateInitialWatchStatementApplicationsWithPendingCharmsCall wrap *gomock.Call
type MockStateInitialWatchStatementApplicationsWithPendingCharmsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall) Do(f func() (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall) DoAndReturn(f func() (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementUnitAddressesHash mocks base method.
func (m *MockState) InitialWatchStatementUnitAddressesHash(arg0 application.UUID, arg1 string) (string, string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementUnitAddressesHash", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(eventsource.NamespaceQuery)
	return ret0, ret1, ret2
}

// InitialWatchStatementUnitAddressesHash indicates an expected call of InitialWatchStatementUnitAddressesHash.
func (mr *MockStateMockRecorder) InitialWatchStatementUnitAddressesHash(arg0, arg1 any) *MockStateInitialWatchStatementUnitAddressesHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementUnitAddressesHash", reflect.TypeOf((*MockState)(nil).InitialWatchStatementUnitAddressesHash), arg0, arg1)
	return &MockStateInitialWatchStatementUnitAddressesHashCall{Call: call}
}

// MockStateInitialWatchStatementUnitAddressesHashCall wrap *gomock.Call
type MockStateInitialWatchStatementUnitAddressesHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementUnitAddressesHashCall) Return(arg0, arg1 string, arg2 eventsource.NamespaceQuery) *MockStateInitialWatchStatementUnitAddressesHashCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementUnitAddressesHashCall) Do(f func(application.UUID, string) (string, string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitAddressesHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementUnitAddressesHashCall) DoAndReturn(f func(application.UUID, string) (string, string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitAddressesHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementUnitInsertDeleteOnNetNode mocks base method.
func (m *MockState) InitialWatchStatementUnitInsertDeleteOnNetNode(arg0 string) (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementUnitInsertDeleteOnNetNode", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementUnitInsertDeleteOnNetNode indicates an expected call of InitialWatchStatementUnitInsertDeleteOnNetNode.
func (mr *MockStateMockRecorder) InitialWatchStatementUnitInsertDeleteOnNetNode(arg0 any) *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementUnitInsertDeleteOnNetNode", reflect.TypeOf((*MockState)(nil).InitialWatchStatementUnitInsertDeleteOnNetNode), arg0)
	return &MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall{Call: call}
}

// MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall wrap *gomock.Call
type MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall) Do(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall) DoAndReturn(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitInsertDeleteOnNetNodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementUnitLife mocks base method.
func (m *MockState) InitialWatchStatementUnitLife(arg0 string) (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementUnitLife", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementUnitLife indicates an expected call of InitialWatchStatementUnitLife.
func (mr *MockStateMockRecorder) InitialWatchStatementUnitLife(arg0 any) *MockStateInitialWatchStatementUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementUnitLife", reflect.TypeOf((*MockState)(nil).InitialWatchStatementUnitLife), arg0)
	return &MockStateInitialWatchStatementUnitLifeCall{Call: call}
}

// MockStateInitialWatchStatementUnitLifeCall wrap *gomock.Call
type MockStateInitialWatchStatementUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementUnitLifeCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementUnitLifeCall) Do(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementUnitLifeCall) DoAndReturn(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertMigratingApplication mocks base method.
func (m *MockState) InsertMigratingApplication(arg0 context.Context, arg1 string, arg2 application0.InsertApplicationArgs) (application.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMigratingApplication", arg0, arg1, arg2)
	ret0, _ := ret[0].(application.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMigratingApplication indicates an expected call of InsertMigratingApplication.
func (mr *MockStateMockRecorder) InsertMigratingApplication(arg0, arg1, arg2 any) *MockStateInsertMigratingApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMigratingApplication", reflect.TypeOf((*MockState)(nil).InsertMigratingApplication), arg0, arg1, arg2)
	return &MockStateInsertMigratingApplicationCall{Call: call}
}

// MockStateInsertMigratingApplicationCall wrap *gomock.Call
type MockStateInsertMigratingApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInsertMigratingApplicationCall) Return(arg0 application.UUID, arg1 error) *MockStateInsertMigratingApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInsertMigratingApplicationCall) Do(f func(context.Context, string, application0.InsertApplicationArgs) (application.UUID, error)) *MockStateInsertMigratingApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInsertMigratingApplicationCall) DoAndReturn(f func(context.Context, string, application0.InsertApplicationArgs) (application.UUID, error)) *MockStateInsertMigratingApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertMigratingCAASUnits mocks base method.
func (m *MockState) InsertMigratingCAASUnits(arg0 context.Context, arg1 application.UUID, arg2 ...application0.ImportUnitArg) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertMigratingCAASUnits", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertMigratingCAASUnits indicates an expected call of InsertMigratingCAASUnits.
func (mr *MockStateMockRecorder) InsertMigratingCAASUnits(arg0, arg1 any, arg2 ...any) *MockStateInsertMigratingCAASUnitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMigratingCAASUnits", reflect.TypeOf((*MockState)(nil).InsertMigratingCAASUnits), varargs...)
	return &MockStateInsertMigratingCAASUnitsCall{Call: call}
}

// MockStateInsertMigratingCAASUnitsCall wrap *gomock.Call
type MockStateInsertMigratingCAASUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInsertMigratingCAASUnitsCall) Return(arg0 error) *MockStateInsertMigratingCAASUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInsertMigratingCAASUnitsCall) Do(f func(context.Context, application.UUID, ...application0.ImportUnitArg) error) *MockStateInsertMigratingCAASUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInsertMigratingCAASUnitsCall) DoAndReturn(f func(context.Context, application.UUID, ...application0.ImportUnitArg) error) *MockStateInsertMigratingCAASUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertMigratingIAASUnits mocks base method.
func (m *MockState) InsertMigratingIAASUnits(arg0 context.Context, arg1 application.UUID, arg2 ...application0.ImportUnitArg) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertMigratingIAASUnits", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertMigratingIAASUnits indicates an expected call of InsertMigratingIAASUnits.
func (mr *MockStateMockRecorder) InsertMigratingIAASUnits(arg0, arg1 any, arg2 ...any) *MockStateInsertMigratingIAASUnitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMigratingIAASUnits", reflect.TypeOf((*MockState)(nil).InsertMigratingIAASUnits), varargs...)
	return &MockStateInsertMigratingIAASUnitsCall{Call: call}
}

// MockStateInsertMigratingIAASUnitsCall wrap *gomock.Call
type MockStateInsertMigratingIAASUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInsertMigratingIAASUnitsCall) Return(arg0 error) *MockStateInsertMigratingIAASUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInsertMigratingIAASUnitsCall) Do(f func(context.Context, application.UUID, ...application0.ImportUnitArg) error) *MockStateInsertMigratingIAASUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInsertMigratingIAASUnitsCall) DoAndReturn(f func(context.Context, application.UUID, ...application0.ImportUnitArg) error) *MockStateInsertMigratingIAASUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsApplicationExposed mocks base method.
func (m *MockState) IsApplicationExposed(arg0 context.Context, arg1 application.UUID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsApplicationExposed", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsApplicationExposed indicates an expected call of IsApplicationExposed.
func (mr *MockStateMockRecorder) IsApplicationExposed(arg0, arg1 any) *MockStateIsApplicationExposedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicationExposed", reflect.TypeOf((*MockState)(nil).IsApplicationExposed), arg0, arg1)
	return &MockStateIsApplicationExposedCall{Call: call}
}

// MockStateIsApplicationExposedCall wrap *gomock.Call
type MockStateIsApplicationExposedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsApplicationExposedCall) Return(arg0 bool, arg1 error) *MockStateIsApplicationExposedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsApplicationExposedCall) Do(f func(context.Context, application.UUID) (bool, error)) *MockStateIsApplicationExposedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsApplicationExposedCall) DoAndReturn(f func(context.Context, application.UUID) (bool, error)) *MockStateIsApplicationExposedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsCharmAvailable mocks base method.
func (m *MockState) IsCharmAvailable(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCharmAvailable", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCharmAvailable indicates an expected call of IsCharmAvailable.
func (mr *MockStateMockRecorder) IsCharmAvailable(arg0, arg1 any) *MockStateIsCharmAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCharmAvailable", reflect.TypeOf((*MockState)(nil).IsCharmAvailable), arg0, arg1)
	return &MockStateIsCharmAvailableCall{Call: call}
}

// MockStateIsCharmAvailableCall wrap *gomock.Call
type MockStateIsCharmAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsCharmAvailableCall) Return(arg0 bool, arg1 error) *MockStateIsCharmAvailableCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsCharmAvailableCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateIsCharmAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsCharmAvailableCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateIsCharmAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsControllerApplication mocks base method.
func (m *MockState) IsControllerApplication(arg0 context.Context, arg1 application.UUID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsControllerApplication", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsControllerApplication indicates an expected call of IsControllerApplication.
func (mr *MockStateMockRecorder) IsControllerApplication(arg0, arg1 any) *MockStateIsControllerApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsControllerApplication", reflect.TypeOf((*MockState)(nil).IsControllerApplication), arg0, arg1)
	return &MockStateIsControllerApplicationCall{Call: call}
}

// MockStateIsControllerApplicationCall wrap *gomock.Call
type MockStateIsControllerApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsControllerApplicationCall) Return(arg0 bool, arg1 error) *MockStateIsControllerApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsControllerApplicationCall) Do(f func(context.Context, application.UUID) (bool, error)) *MockStateIsControllerApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsControllerApplicationCall) DoAndReturn(f func(context.Context, application.UUID) (bool, error)) *MockStateIsControllerApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsControllerCharm mocks base method.
func (m *MockState) IsControllerCharm(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsControllerCharm", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsControllerCharm indicates an expected call of IsControllerCharm.
func (mr *MockStateMockRecorder) IsControllerCharm(arg0, arg1 any) *MockStateIsControllerCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsControllerCharm", reflect.TypeOf((*MockState)(nil).IsControllerCharm), arg0, arg1)
	return &MockStateIsControllerCharmCall{Call: call}
}

// MockStateIsControllerCharmCall wrap *gomock.Call
type MockStateIsControllerCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsControllerCharmCall) Return(arg0 bool, arg1 error) *MockStateIsControllerCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsControllerCharmCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateIsControllerCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsControllerCharmCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateIsControllerCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsImportingModel mocks base method.
func (m *MockState) IsImportingModel(arg0 context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsImportingModel", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsImportingModel indicates an expected call of IsImportingModel.
func (mr *MockStateMockRecorder) IsImportingModel(arg0 any) *MockStateIsImportingModelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsImportingModel", reflect.TypeOf((*MockState)(nil).IsImportingModel), arg0)
	return &MockStateIsImportingModelCall{Call: call}
}

// MockStateIsImportingModelCall wrap *gomock.Call
type MockStateIsImportingModelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsImportingModelCall) Return(arg0 bool, arg1 error) *MockStateIsImportingModelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsImportingModelCall) Do(f func(context.Context) (bool, error)) *MockStateIsImportingModelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsImportingModelCall) DoAndReturn(f func(context.Context) (bool, error)) *MockStateIsImportingModelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsMachineController mocks base method.
func (m *MockState) IsMachineController(arg0 context.Context, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsMachineController", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsMachineController indicates an expected call of IsMachineController.
func (mr *MockStateMockRecorder) IsMachineController(arg0, arg1 any) *MockStateIsMachineControllerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsMachineController", reflect.TypeOf((*MockState)(nil).IsMachineController), arg0, arg1)
	return &MockStateIsMachineControllerCall{Call: call}
}

// MockStateIsMachineControllerCall wrap *gomock.Call
type MockStateIsMachineControllerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsMachineControllerCall) Return(arg0 bool, arg1 error) *MockStateIsMachineControllerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsMachineControllerCall) Do(f func(context.Context, string) (bool, error)) *MockStateIsMachineControllerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsMachineControllerCall) DoAndReturn(f func(context.Context, string) (bool, error)) *MockStateIsMachineControllerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsSubordinateApplication mocks base method.
func (m *MockState) IsSubordinateApplication(arg0 context.Context, arg1 application.UUID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSubordinateApplication", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsSubordinateApplication indicates an expected call of IsSubordinateApplication.
func (mr *MockStateMockRecorder) IsSubordinateApplication(arg0, arg1 any) *MockStateIsSubordinateApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSubordinateApplication", reflect.TypeOf((*MockState)(nil).IsSubordinateApplication), arg0, arg1)
	return &MockStateIsSubordinateApplicationCall{Call: call}
}

// MockStateIsSubordinateApplicationCall wrap *gomock.Call
type MockStateIsSubordinateApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsSubordinateApplicationCall) Return(arg0 bool, arg1 error) *MockStateIsSubordinateApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsSubordinateApplicationCall) Do(f func(context.Context, application.UUID) (bool, error)) *MockStateIsSubordinateApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsSubordinateApplicationCall) DoAndReturn(f func(context.Context, application.UUID) (bool, error)) *MockStateIsSubordinateApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsSubordinateCharm mocks base method.
func (m *MockState) IsSubordinateCharm(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSubordinateCharm", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsSubordinateCharm indicates an expected call of IsSubordinateCharm.
func (mr *MockStateMockRecorder) IsSubordinateCharm(arg0, arg1 any) *MockStateIsSubordinateCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSubordinateCharm", reflect.TypeOf((*MockState)(nil).IsSubordinateCharm), arg0, arg1)
	return &MockStateIsSubordinateCharmCall{Call: call}
}

// MockStateIsSubordinateCharmCall wrap *gomock.Call
type MockStateIsSubordinateCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsSubordinateCharmCall) Return(arg0 bool, arg1 error) *MockStateIsSubordinateCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsSubordinateCharmCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateIsSubordinateCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsSubordinateCharmCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateIsSubordinateCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCharmLocators mocks base method.
func (m *MockState) ListCharmLocators(arg0 context.Context) ([]charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharmLocators", arg0)
	ret0, _ := ret[0].([]charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharmLocators indicates an expected call of ListCharmLocators.
func (mr *MockStateMockRecorder) ListCharmLocators(arg0 any) *MockStateListCharmLocatorsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharmLocators", reflect.TypeOf((*MockState)(nil).ListCharmLocators), arg0)
	return &MockStateListCharmLocatorsCall{Call: call}
}

// MockStateListCharmLocatorsCall wrap *gomock.Call
type MockStateListCharmLocatorsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateListCharmLocatorsCall) Return(arg0 []charm0.CharmLocator, arg1 error) *MockStateListCharmLocatorsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateListCharmLocatorsCall) Do(f func(context.Context) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateListCharmLocatorsCall) DoAndReturn(f func(context.Context) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCharmLocatorsByNames mocks base method.
func (m *MockState) ListCharmLocatorsByNames(arg0 context.Context, arg1 []string) ([]charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharmLocatorsByNames", arg0, arg1)
	ret0, _ := ret[0].([]charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharmLocatorsByNames indicates an expected call of ListCharmLocatorsByNames.
func (mr *MockStateMockRecorder) ListCharmLocatorsByNames(arg0, arg1 any) *MockStateListCharmLocatorsByNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharmLocatorsByNames", reflect.TypeOf((*MockState)(nil).ListCharmLocatorsByNames), arg0, arg1)
	return &MockStateListCharmLocatorsByNamesCall{Call: call}
}

// MockStateListCharmLocatorsByNamesCall wrap *gomock.Call
type MockStateListCharmLocatorsByNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateListCharmLocatorsByNamesCall) Return(arg0 []charm0.CharmLocator, arg1 error) *MockStateListCharmLocatorsByNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateListCharmLocatorsByNamesCall) Do(f func(context.Context, []string) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsByNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateListCharmLocatorsByNamesCall) DoAndReturn(f func(context.Context, []string) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsByNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeApplicationEndpointBindings mocks base method.
func (m *MockState) MergeApplicationEndpointBindings(arg0 context.Context, arg1 string, arg2 map[string]string, arg3 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeApplicationEndpointBindings", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// MergeApplicationEndpointBindings indicates an expected call of MergeApplicationEndpointBindings.
func (mr *MockStateMockRecorder) MergeApplicationEndpointBindings(arg0, arg1, arg2, arg3 any) *MockStateMergeApplicationEndpointBindingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeApplicationEndpointBindings", reflect.TypeOf((*MockState)(nil).MergeApplicationEndpointBindings), arg0, arg1, arg2, arg3)
	return &MockStateMergeApplicationEndpointBindingsCall{Call: call}
}

// MockStateMergeApplicationEndpointBindingsCall wrap *gomock.Call
type MockStateMergeApplicationEndpointBindingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateMergeApplicationEndpointBindingsCall) Return(arg0 error) *MockStateMergeApplicationEndpointBindingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateMergeApplicationEndpointBindingsCall) Do(f func(context.Context, string, map[string]string, bool) error) *MockStateMergeApplicationEndpointBindingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateMergeApplicationEndpointBindingsCall) DoAndReturn(f func(context.Context, string, map[string]string, bool) error) *MockStateMergeApplicationEndpointBindingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeExposeSettings mocks base method.
func (m *MockState) MergeExposeSettings(arg0 context.Context, arg1 application.UUID, arg2 map[string]application0.ExposedEndpoint) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MergeExposeSettings", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// MergeExposeSettings indicates an expected call of MergeExposeSettings.
func (mr *MockStateMockRecorder) MergeExposeSettings(arg0, arg1, arg2 any) *MockStateMergeExposeSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeExposeSettings", reflect.TypeOf((*MockState)(nil).MergeExposeSettings), arg0, arg1, arg2)
	return &MockStateMergeExposeSettingsCall{Call: call}
}

// MockStateMergeExposeSettingsCall wrap *gomock.Call
type MockStateMergeExposeSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateMergeExposeSettingsCall) Return(arg0 error) *MockStateMergeExposeSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateMergeExposeSettingsCall) Do(f func(context.Context, application.UUID, map[string]application0.ExposedEndpoint) error) *MockStateMergeExposeSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateMergeExposeSettingsCall) DoAndReturn(f func(context.Context, application.UUID, map[string]application0.ExposedEndpoint) error) *MockStateMergeExposeSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchApplication mocks base method.
func (m *MockState) NamespaceForWatchApplication() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchApplication")
	ret0, _ := ret[0].(string)
	return ret0
}

// NamespaceForWatchApplication indicates an expected call of NamespaceForWatchApplication.
func (mr *MockStateMockRecorder) NamespaceForWatchApplication() *MockStateNamespaceForWatchApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchApplication", reflect.TypeOf((*MockState)(nil).NamespaceForWatchApplication))
	return &MockStateNamespaceForWatchApplicationCall{Call: call}
}

// MockStateNamespaceForWatchApplicationCall wrap *gomock.Call
type MockStateNamespaceForWatchApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchApplicationCall) Return(arg0 string) *MockStateNamespaceForWatchApplicationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchApplicationCall) Do(f func() string) *MockStateNamespaceForWatchApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchApplicationCall) DoAndReturn(f func() string) *MockStateNamespaceForWatchApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchApplicationConfig mocks base method.
func (m *MockState) NamespaceForWatchApplicationConfig() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchApplicationConfig")
	ret0, _ := ret[0].(string)
	return ret0
}

// NamespaceForWatchApplicationConfig indicates an expected call of NamespaceForWatchApplicationConfig.
func (mr *MockStateMockRecorder) NamespaceForWatchApplicationConfig() *MockStateNamespaceForWatchApplicationConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchApplicationConfig", reflect.TypeOf((*MockState)(nil).NamespaceForWatchApplicationConfig))
	return &MockStateNamespaceForWatchApplicationConfigCall{Call: call}
}

// MockStateNamespaceForWatchApplicationConfigCall wrap *gomock.Call
type MockStateNamespaceForWatchApplicationConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchApplicationConfigCall) Return(arg0 string) *MockStateNamespaceForWatchApplicationConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchApplicationConfigCall) Do(f func() string) *MockStateNamespaceForWatchApplicationConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchApplicationConfigCall) DoAndReturn(f func() string) *MockStateNamespaceForWatchApplicationConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchApplicationExposed mocks base method.
func (m *MockState) NamespaceForWatchApplicationExposed() (string, string) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchApplicationExposed")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	return ret0, ret1
}

// NamespaceForWatchApplicationExposed indicates an expected call of NamespaceForWatchApplicationExposed.
func (mr *MockStateMockRecorder) NamespaceForWatchApplicationExposed() *MockStateNamespaceForWatchApplicationExposedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchApplicationExposed", reflect.TypeOf((*MockState)(nil).NamespaceForWatchApplicationExposed))
	return &MockStateNamespaceForWatchApplicationExposedCall{Call: call}
}

// MockStateNamespaceForWatchApplicationExposedCall wrap *gomock.Call
type MockStateNamespaceForWatchApplicationExposedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchApplicationExposedCall) Return(arg0, arg1 string) *MockStateNamespaceForWatchApplicationExposedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchApplicationExposedCall) Do(f func() (string, string)) *MockStateNamespaceForWatchApplicationExposedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchApplicationExposedCall) DoAndReturn(f func() (string, string)) *MockStateNamespaceForWatchApplicationExposedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchApplicationScale mocks base method.
func (m *MockState) NamespaceForWatchApplicationScale() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchApplicationScale")
	ret0, _ := ret[0].(string)
	return ret0
}

// NamespaceForWatchApplicationScale indicates an expected call of NamespaceForWatchApplicationScale.
func (mr *MockStateMockRecorder) NamespaceForWatchApplicationScale() *MockStateNamespaceForWatchApplicationScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchApplicationScale", reflect.TypeOf((*MockState)(nil).NamespaceForWatchApplicationScale))
	return &MockStateNamespaceForWatchApplicationScaleCall{Call: call}
}

// MockStateNamespaceForWatchApplicationScaleCall wrap *gomock.Call
type MockStateNamespaceForWatchApplicationScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchApplicationScaleCall) Return(arg0 string) *MockStateNamespaceForWatchApplicationScaleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchApplicationScaleCall) Do(f func() string) *MockStateNamespaceForWatchApplicationScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchApplicationScaleCall) DoAndReturn(f func() string) *MockStateNamespaceForWatchApplicationScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchApplicationSetting mocks base method.
func (m *MockState) NamespaceForWatchApplicationSetting() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchApplicationSetting")
	ret0, _ := ret[0].(string)
	return ret0
}

// NamespaceForWatchApplicationSetting indicates an expected call of NamespaceForWatchApplicationSetting.
func (mr *MockStateMockRecorder) NamespaceForWatchApplicationSetting() *MockStateNamespaceForWatchApplicationSettingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchApplicationSetting", reflect.TypeOf((*MockState)(nil).NamespaceForWatchApplicationSetting))
	return &MockStateNamespaceForWatchApplicationSettingCall{Call: call}
}

// MockStateNamespaceForWatchApplicationSettingCall wrap *gomock.Call
type MockStateNamespaceForWatchApplicationSettingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchApplicationSettingCall) Return(arg0 string) *MockStateNamespaceForWatchApplicationSettingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchApplicationSettingCall) Do(f func() string) *MockStateNamespaceForWatchApplicationSettingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchApplicationSettingCall) DoAndReturn(f func() string) *MockStateNamespaceForWatchApplicationSettingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchCharm mocks base method.
func (m *MockState) NamespaceForWatchCharm() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchCharm")
	ret0, _ := ret[0].(string)
	return ret0
}

// NamespaceForWatchCharm indicates an expected call of NamespaceForWatchCharm.
func (mr *MockStateMockRecorder) NamespaceForWatchCharm() *MockStateNamespaceForWatchCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchCharm", reflect.TypeOf((*MockState)(nil).NamespaceForWatchCharm))
	return &MockStateNamespaceForWatchCharmCall{Call: call}
}

// MockStateNamespaceForWatchCharmCall wrap *gomock.Call
type MockStateNamespaceForWatchCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchCharmCall) Return(arg0 string) *MockStateNamespaceForWatchCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchCharmCall) Do(f func() string) *MockStateNamespaceForWatchCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchCharmCall) DoAndReturn(f func() string) *MockStateNamespaceForWatchCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchNetNodeAddress mocks base method.
func (m *MockState) NamespaceForWatchNetNodeAddress() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchNetNodeAddress")
	ret0, _ := ret[0].(string)
	return ret0
}

// NamespaceForWatchNetNodeAddress indicates an expected call of NamespaceForWatchNetNodeAddress.
func (mr *MockStateMockRecorder) NamespaceForWatchNetNodeAddress() *MockStateNamespaceForWatchNetNodeAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchNetNodeAddress", reflect.TypeOf((*MockState)(nil).NamespaceForWatchNetNodeAddress))
	return &MockStateNamespaceForWatchNetNodeAddressCall{Call: call}
}

// MockStateNamespaceForWatchNetNodeAddressCall wrap *gomock.Call
type MockStateNamespaceForWatchNetNodeAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchNetNodeAddressCall) Return(arg0 string) *MockStateNamespaceForWatchNetNodeAddressCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchNetNodeAddressCall) Do(f func() string) *MockStateNamespaceForWatchNetNodeAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchNetNodeAddressCall) DoAndReturn(f func() string) *MockStateNamespaceForWatchNetNodeAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NamespaceForWatchUnitForLegacyUniter mocks base method.
func (m *MockState) NamespaceForWatchUnitForLegacyUniter() (string, string, string) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NamespaceForWatchUnitForLegacyUniter")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(string)
	return ret0, ret1, ret2
}

// NamespaceForWatchUnitForLegacyUniter indicates an expected call of NamespaceForWatchUnitForLegacyUniter.
func (mr *MockStateMockRecorder) NamespaceForWatchUnitForLegacyUniter() *MockStateNamespaceForWatchUnitForLegacyUniterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NamespaceForWatchUnitForLegacyUniter", reflect.TypeOf((*MockState)(nil).NamespaceForWatchUnitForLegacyUniter))
	return &MockStateNamespaceForWatchUnitForLegacyUniterCall{Call: call}
}

// MockStateNamespaceForWatchUnitForLegacyUniterCall wrap *gomock.Call
type MockStateNamespaceForWatchUnitForLegacyUniterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateNamespaceForWatchUnitForLegacyUniterCall) Return(arg0, arg1, arg2 string) *MockStateNamespaceForWatchUnitForLegacyUniterCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateNamespaceForWatchUnitForLegacyUniterCall) Do(f func() (string, string, string)) *MockStateNamespaceForWatchUnitForLegacyUniterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateNamespaceForWatchUnitForLegacyUniterCall) DoAndReturn(f func() (string, string, string)) *MockStateNamespaceForWatchUnitForLegacyUniterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterCAASUnit mocks base method.
func (m *MockState) RegisterCAASUnit(arg0 context.Context, arg1 string, arg2 application0.RegisterCAASUnitArg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterCAASUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterCAASUnit indicates an expected call of RegisterCAASUnit.
func (mr *MockStateMockRecorder) RegisterCAASUnit(arg0, arg1, arg2 any) *MockStateRegisterCAASUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterCAASUnit", reflect.TypeOf((*MockState)(nil).RegisterCAASUnit), arg0, arg1, arg2)
	return &MockStateRegisterCAASUnitCall{Call: call}
}

// MockStateRegisterCAASUnitCall wrap *gomock.Call
type MockStateRegisterCAASUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateRegisterCAASUnitCall) Return(arg0 error) *MockStateRegisterCAASUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateRegisterCAASUnitCall) Do(f func(context.Context, string, application0.RegisterCAASUnitArg) error) *MockStateRegisterCAASUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateRegisterCAASUnitCall) DoAndReturn(f func(context.Context, string, application0.RegisterCAASUnitArg) error) *MockStateRegisterCAASUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveCharmDownload mocks base method.
func (m *MockState) ResolveCharmDownload(arg0 context.Context, arg1 charm.ID, arg2 application0.ResolvedCharmDownload) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveCharmDownload", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResolveCharmDownload indicates an expected call of ResolveCharmDownload.
func (mr *MockStateMockRecorder) ResolveCharmDownload(arg0, arg1, arg2 any) *MockStateResolveCharmDownloadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveCharmDownload", reflect.TypeOf((*MockState)(nil).ResolveCharmDownload), arg0, arg1, arg2)
	return &MockStateResolveCharmDownloadCall{Call: call}
}

// MockStateResolveCharmDownloadCall wrap *gomock.Call
type MockStateResolveCharmDownloadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateResolveCharmDownloadCall) Return(arg0 error) *MockStateResolveCharmDownloadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateResolveCharmDownloadCall) Do(f func(context.Context, charm.ID, application0.ResolvedCharmDownload) error) *MockStateResolveCharmDownloadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateResolveCharmDownloadCall) DoAndReturn(f func(context.Context, charm.ID, application0.ResolvedCharmDownload) error) *MockStateResolveCharmDownloadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveMigratingUploadedCharm mocks base method.
func (m *MockState) ResolveMigratingUploadedCharm(arg0 context.Context, arg1 charm.ID, arg2 charm0.ResolvedMigratingUploadedCharm) (charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveMigratingUploadedCharm", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveMigratingUploadedCharm indicates an expected call of ResolveMigratingUploadedCharm.
func (mr *MockStateMockRecorder) ResolveMigratingUploadedCharm(arg0, arg1, arg2 any) *MockStateResolveMigratingUploadedCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveMigratingUploadedCharm", reflect.TypeOf((*MockState)(nil).ResolveMigratingUploadedCharm), arg0, arg1, arg2)
	return &MockStateResolveMigratingUploadedCharmCall{Call: call}
}

// MockStateResolveMigratingUploadedCharmCall wrap *gomock.Call
type MockStateResolveMigratingUploadedCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateResolveMigratingUploadedCharmCall) Return(arg0 charm0.CharmLocator, arg1 error) *MockStateResolveMigratingUploadedCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateResolveMigratingUploadedCharmCall) Do(f func(context.Context, charm.ID, charm0.ResolvedMigratingUploadedCharm) (charm0.CharmLocator, error)) *MockStateResolveMigratingUploadedCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateResolveMigratingUploadedCharmCall) DoAndReturn(f func(context.Context, charm.ID, charm0.ResolvedMigratingUploadedCharm) (charm0.CharmLocator, error)) *MockStateResolveMigratingUploadedCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationCharm mocks base method.
func (m *MockState) SetApplicationCharm(arg0 context.Context, arg1 application.UUID, arg2 charm.ID, arg3 application0.SetCharmParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationCharm", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationCharm indicates an expected call of SetApplicationCharm.
func (mr *MockStateMockRecorder) SetApplicationCharm(arg0, arg1, arg2, arg3 any) *MockStateSetApplicationCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationCharm", reflect.TypeOf((*MockState)(nil).SetApplicationCharm), arg0, arg1, arg2, arg3)
	return &MockStateSetApplicationCharmCall{Call: call}
}

// MockStateSetApplicationCharmCall wrap *gomock.Call
type MockStateSetApplicationCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetApplicationCharmCall) Return(arg0 error) *MockStateSetApplicationCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetApplicationCharmCall) Do(f func(context.Context, application.UUID, charm.ID, application0.SetCharmParams) error) *MockStateSetApplicationCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetApplicationCharmCall) DoAndReturn(f func(context.Context, application.UUID, charm.ID, application0.SetCharmParams) error) *MockStateSetApplicationCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationConstraints mocks base method.
func (m *MockState) SetApplicationConstraints(arg0 context.Context, arg1 application.UUID, arg2 constraints0.Constraints) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationConstraints", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationConstraints indicates an expected call of SetApplicationConstraints.
func (mr *MockStateMockRecorder) SetApplicationConstraints(arg0, arg1, arg2 any) *MockStateSetApplicationConstraintsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationConstraints", reflect.TypeOf((*MockState)(nil).SetApplicationConstraints), arg0, arg1, arg2)
	return &MockStateSetApplicationConstraintsCall{Call: call}
}

// MockStateSetApplicationConstraintsCall wrap *gomock.Call
type MockStateSetApplicationConstraintsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetApplicationConstraintsCall) Return(arg0 error) *MockStateSetApplicationConstraintsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetApplicationConstraintsCall) Do(f func(context.Context, application.UUID, constraints0.Constraints) error) *MockStateSetApplicationConstraintsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetApplicationConstraintsCall) DoAndReturn(f func(context.Context, application.UUID, constraints0.Constraints) error) *MockStateSetApplicationConstraintsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationScalingState mocks base method.
func (m *MockState) SetApplicationScalingState(arg0 context.Context, arg1 string, arg2 int, arg3 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationScalingState", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationScalingState indicates an expected call of SetApplicationScalingState.
func (mr *MockStateMockRecorder) SetApplicationScalingState(arg0, arg1, arg2, arg3 any) *MockStateSetApplicationScalingStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationScalingState", reflect.TypeOf((*MockState)(nil).SetApplicationScalingState), arg0, arg1, arg2, arg3)
	return &MockStateSetApplicationScalingStateCall{Call: call}
}

// MockStateSetApplicationScalingStateCall wrap *gomock.Call
type MockStateSetApplicationScalingStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetApplicationScalingStateCall) Return(arg0 error) *MockStateSetApplicationScalingStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetApplicationScalingStateCall) Do(f func(context.Context, string, int, bool) error) *MockStateSetApplicationScalingStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetApplicationScalingStateCall) DoAndReturn(f func(context.Context, string, int, bool) error) *MockStateSetApplicationScalingStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharmAvailable mocks base method.
func (m *MockState) SetCharmAvailable(arg0 context.Context, arg1 charm.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharmAvailable", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCharmAvailable indicates an expected call of SetCharmAvailable.
func (mr *MockStateMockRecorder) SetCharmAvailable(arg0, arg1 any) *MockStateSetCharmAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharmAvailable", reflect.TypeOf((*MockState)(nil).SetCharmAvailable), arg0, arg1)
	return &MockStateSetCharmAvailableCall{Call: call}
}

// MockStateSetCharmAvailableCall wrap *gomock.Call
type MockStateSetCharmAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetCharmAvailableCall) Return(arg0 error) *MockStateSetCharmAvailableCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetCharmAvailableCall) Do(f func(context.Context, charm.ID) error) *MockStateSetCharmAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetCharmAvailableCall) DoAndReturn(f func(context.Context, charm.ID) error) *MockStateSetCharmAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetDesiredApplicationScale mocks base method.
func (m *MockState) SetDesiredApplicationScale(arg0 context.Context, arg1 application.UUID, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDesiredApplicationScale", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDesiredApplicationScale indicates an expected call of SetDesiredApplicationScale.
func (mr *MockStateMockRecorder) SetDesiredApplicationScale(arg0, arg1, arg2 any) *MockStateSetDesiredApplicationScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDesiredApplicationScale", reflect.TypeOf((*MockState)(nil).SetDesiredApplicationScale), arg0, arg1, arg2)
	return &MockStateSetDesiredApplicationScaleCall{Call: call}
}

// MockStateSetDesiredApplicationScaleCall wrap *gomock.Call
type MockStateSetDesiredApplicationScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetDesiredApplicationScaleCall) Return(arg0 error) *MockStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetDesiredApplicationScaleCall) Do(f func(context.Context, application.UUID, int) error) *MockStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetDesiredApplicationScaleCall) DoAndReturn(f func(context.Context, application.UUID, int) error) *MockStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitWorkloadVersion mocks base method.
func (m *MockState) SetUnitWorkloadVersion(arg0 context.Context, arg1 unit.Name, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitWorkloadVersion", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitWorkloadVersion indicates an expected call of SetUnitWorkloadVersion.
func (mr *MockStateMockRecorder) SetUnitWorkloadVersion(arg0, arg1, arg2 any) *MockStateSetUnitWorkloadVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitWorkloadVersion", reflect.TypeOf((*MockState)(nil).SetUnitWorkloadVersion), arg0, arg1, arg2)
	return &MockStateSetUnitWorkloadVersionCall{Call: call}
}

// MockStateSetUnitWorkloadVersionCall wrap *gomock.Call
type MockStateSetUnitWorkloadVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetUnitWorkloadVersionCall) Return(arg0 error) *MockStateSetUnitWorkloadVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetUnitWorkloadVersionCall) Do(f func(context.Context, unit.Name, string) error) *MockStateSetUnitWorkloadVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetUnitWorkloadVersionCall) DoAndReturn(f func(context.Context, unit.Name, string) error) *MockStateSetUnitWorkloadVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ShouldAllowCharmUpgradeOnError mocks base method.
func (m *MockState) ShouldAllowCharmUpgradeOnError(arg0 context.Context, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShouldAllowCharmUpgradeOnError", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ShouldAllowCharmUpgradeOnError indicates an expected call of ShouldAllowCharmUpgradeOnError.
func (mr *MockStateMockRecorder) ShouldAllowCharmUpgradeOnError(arg0, arg1 any) *MockStateShouldAllowCharmUpgradeOnErrorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShouldAllowCharmUpgradeOnError", reflect.TypeOf((*MockState)(nil).ShouldAllowCharmUpgradeOnError), arg0, arg1)
	return &MockStateShouldAllowCharmUpgradeOnErrorCall{Call: call}
}

// MockStateShouldAllowCharmUpgradeOnErrorCall wrap *gomock.Call
type MockStateShouldAllowCharmUpgradeOnErrorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateShouldAllowCharmUpgradeOnErrorCall) Return(arg0 bool, arg1 error) *MockStateShouldAllowCharmUpgradeOnErrorCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateShouldAllowCharmUpgradeOnErrorCall) Do(f func(context.Context, string) (bool, error)) *MockStateShouldAllowCharmUpgradeOnErrorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateShouldAllowCharmUpgradeOnErrorCall) DoAndReturn(f func(context.Context, string) (bool, error)) *MockStateShouldAllowCharmUpgradeOnErrorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SpacesExist mocks base method.
func (m *MockState) SpacesExist(arg0 context.Context, arg1 set.Strings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SpacesExist", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SpacesExist indicates an expected call of SpacesExist.
func (mr *MockStateMockRecorder) SpacesExist(arg0, arg1 any) *MockStateSpacesExistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SpacesExist", reflect.TypeOf((*MockState)(nil).SpacesExist), arg0, arg1)
	return &MockStateSpacesExistCall{Call: call}
}

// MockStateSpacesExistCall wrap *gomock.Call
type MockStateSpacesExistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSpacesExistCall) Return(arg0 error) *MockStateSpacesExistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSpacesExistCall) Do(f func(context.Context, set.Strings) error) *MockStateSpacesExistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSpacesExistCall) DoAndReturn(f func(context.Context, set.Strings) error) *MockStateSpacesExistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SupportsContainers mocks base method.
func (m *MockState) SupportsContainers(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportsContainers", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SupportsContainers indicates an expected call of SupportsContainers.
func (mr *MockStateMockRecorder) SupportsContainers(arg0, arg1 any) *MockStateSupportsContainersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportsContainers", reflect.TypeOf((*MockState)(nil).SupportsContainers), arg0, arg1)
	return &MockStateSupportsContainersCall{Call: call}
}

// MockStateSupportsContainersCall wrap *gomock.Call
type MockStateSupportsContainersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSupportsContainersCall) Return(arg0 bool, arg1 error) *MockStateSupportsContainersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSupportsContainersCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateSupportsContainersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSupportsContainersCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateSupportsContainersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsetApplicationConfigKeys mocks base method.
func (m *MockState) UnsetApplicationConfigKeys(arg0 context.Context, arg1 application.UUID, arg2 []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnsetApplicationConfigKeys", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnsetApplicationConfigKeys indicates an expected call of UnsetApplicationConfigKeys.
func (mr *MockStateMockRecorder) UnsetApplicationConfigKeys(arg0, arg1, arg2 any) *MockStateUnsetApplicationConfigKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsetApplicationConfigKeys", reflect.TypeOf((*MockState)(nil).UnsetApplicationConfigKeys), arg0, arg1, arg2)
	return &MockStateUnsetApplicationConfigKeysCall{Call: call}
}

// MockStateUnsetApplicationConfigKeysCall wrap *gomock.Call
type MockStateUnsetApplicationConfigKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUnsetApplicationConfigKeysCall) Return(arg0 error) *MockStateUnsetApplicationConfigKeysCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUnsetApplicationConfigKeysCall) Do(f func(context.Context, application.UUID, []string) error) *MockStateUnsetApplicationConfigKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUnsetApplicationConfigKeysCall) DoAndReturn(f func(context.Context, application.UUID, []string) error) *MockStateUnsetApplicationConfigKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsetExposeSettings mocks base method.
func (m *MockState) UnsetExposeSettings(arg0 context.Context, arg1 application.UUID, arg2 set.Strings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnsetExposeSettings", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnsetExposeSettings indicates an expected call of UnsetExposeSettings.
func (mr *MockStateMockRecorder) UnsetExposeSettings(arg0, arg1, arg2 any) *MockStateUnsetExposeSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsetExposeSettings", reflect.TypeOf((*MockState)(nil).UnsetExposeSettings), arg0, arg1, arg2)
	return &MockStateUnsetExposeSettingsCall{Call: call}
}

// MockStateUnsetExposeSettingsCall wrap *gomock.Call
type MockStateUnsetExposeSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUnsetExposeSettingsCall) Return(arg0 error) *MockStateUnsetExposeSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUnsetExposeSettingsCall) Do(f func(context.Context, application.UUID, set.Strings) error) *MockStateUnsetExposeSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUnsetExposeSettingsCall) DoAndReturn(f func(context.Context, application.UUID, set.Strings) error) *MockStateUnsetExposeSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateApplicationConfigAndSettings mocks base method.
func (m *MockState) UpdateApplicationConfigAndSettings(arg0 context.Context, arg1 application.UUID, arg2 map[string]application0.AddApplicationConfig, arg3 application0.UpdateApplicationSettingsArg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateApplicationConfigAndSettings", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateApplicationConfigAndSettings indicates an expected call of UpdateApplicationConfigAndSettings.
func (mr *MockStateMockRecorder) UpdateApplicationConfigAndSettings(arg0, arg1, arg2, arg3 any) *MockStateUpdateApplicationConfigAndSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateApplicationConfigAndSettings", reflect.TypeOf((*MockState)(nil).UpdateApplicationConfigAndSettings), arg0, arg1, arg2, arg3)
	return &MockStateUpdateApplicationConfigAndSettingsCall{Call: call}
}

// MockStateUpdateApplicationConfigAndSettingsCall wrap *gomock.Call
type MockStateUpdateApplicationConfigAndSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpdateApplicationConfigAndSettingsCall) Return(arg0 error) *MockStateUpdateApplicationConfigAndSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpdateApplicationConfigAndSettingsCall) Do(f func(context.Context, application.UUID, map[string]application0.AddApplicationConfig, application0.UpdateApplicationSettingsArg) error) *MockStateUpdateApplicationConfigAndSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpdateApplicationConfigAndSettingsCall) DoAndReturn(f func(context.Context, application.UUID, map[string]application0.AddApplicationConfig, application0.UpdateApplicationSettingsArg) error) *MockStateUpdateApplicationConfigAndSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateApplicationScale mocks base method.
func (m *MockState) UpdateApplicationScale(arg0 context.Context, arg1 application.UUID, arg2 int) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateApplicationScale", arg0, arg1, arg2)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateApplicationScale indicates an expected call of UpdateApplicationScale.
func (mr *MockStateMockRecorder) UpdateApplicationScale(arg0, arg1, arg2 any) *MockStateUpdateApplicationScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateApplicationScale", reflect.TypeOf((*MockState)(nil).UpdateApplicationScale), arg0, arg1, arg2)
	return &MockStateUpdateApplicationScaleCall{Call: call}
}

// MockStateUpdateApplicationScaleCall wrap *gomock.Call
type MockStateUpdateApplicationScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpdateApplicationScaleCall) Return(arg0 int, arg1 error) *MockStateUpdateApplicationScaleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpdateApplicationScaleCall) Do(f func(context.Context, application.UUID, int) (int, error)) *MockStateUpdateApplicationScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpdateApplicationScaleCall) DoAndReturn(f func(context.Context, application.UUID, int) (int, error)) *MockStateUpdateApplicationScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateCAASUnit mocks base method.
func (m *MockState) UpdateCAASUnit(arg0 context.Context, arg1 unit.Name, arg2 application0.UpdateCAASUnitParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateCAASUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateCAASUnit indicates an expected call of UpdateCAASUnit.
func (mr *MockStateMockRecorder) UpdateCAASUnit(arg0, arg1, arg2 any) *MockStateUpdateCAASUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCAASUnit", reflect.TypeOf((*MockState)(nil).UpdateCAASUnit), arg0, arg1, arg2)
	return &MockStateUpdateCAASUnitCall{Call: call}
}

// MockStateUpdateCAASUnitCall wrap *gomock.Call
type MockStateUpdateCAASUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpdateCAASUnitCall) Return(arg0 error) *MockStateUpdateCAASUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpdateCAASUnitCall) Do(f func(context.Context, unit.Name, application0.UpdateCAASUnitParams) error) *MockStateUpdateCAASUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpdateCAASUnitCall) DoAndReturn(f func(context.Context, unit.Name, application0.UpdateCAASUnitParams) error) *MockStateUpdateCAASUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateUnitCharm mocks base method.
func (m *MockState) UpdateUnitCharm(arg0 context.Context, arg1 unit.Name, arg2 charm.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUnitCharm", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateUnitCharm indicates an expected call of UpdateUnitCharm.
func (mr *MockStateMockRecorder) UpdateUnitCharm(arg0, arg1, arg2 any) *MockStateUpdateUnitCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUnitCharm", reflect.TypeOf((*MockState)(nil).UpdateUnitCharm), arg0, arg1, arg2)
	return &MockStateUpdateUnitCharmCall{Call: call}
}

// MockStateUpdateUnitCharmCall wrap *gomock.Call
type MockStateUpdateUnitCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpdateUnitCharmCall) Return(arg0 error) *MockStateUpdateUnitCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpdateUnitCharmCall) Do(f func(context.Context, unit.Name, charm.ID) error) *MockStateUpdateUnitCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpdateUnitCharmCall) DoAndReturn(f func(context.Context, unit.Name, charm.ID) error) *MockStateUpdateUnitCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertCloudService mocks base method.
func (m *MockState) UpsertCloudService(arg0 context.Context, arg1, arg2 string, arg3 network.ProviderAddresses) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertCloudService", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertCloudService indicates an expected call of UpsertCloudService.
func (mr *MockStateMockRecorder) UpsertCloudService(arg0, arg1, arg2, arg3 any) *MockStateUpsertCloudServiceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertCloudService", reflect.TypeOf((*MockState)(nil).UpsertCloudService), arg0, arg1, arg2, arg3)
	return &MockStateUpsertCloudServiceCall{Call: call}
}

// MockStateUpsertCloudServiceCall wrap *gomock.Call
type MockStateUpsertCloudServiceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpsertCloudServiceCall) Return(arg0 error) *MockStateUpsertCloudServiceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpsertCloudServiceCall) Do(f func(context.Context, string, string, network.ProviderAddresses) error) *MockStateUpsertCloudServiceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpsertCloudServiceCall) DoAndReturn(f func(context.Context, string, string, network.ProviderAddresses) error) *MockStateUpsertCloudServiceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStatusHistory is a mock of StatusHistory interface.
type MockStatusHistory struct {
	ctrl     *gomock.Controller
	recorder *MockStatusHistoryMockRecorder
}

// MockStatusHistoryMockRecorder is the mock recorder for MockStatusHistory.
type MockStatusHistoryMockRecorder struct {
	mock *MockStatusHistory
}

// NewMockStatusHistory creates a new mock instance.
func NewMockStatusHistory(ctrl *gomock.Controller) *MockStatusHistory {
	mock := &MockStatusHistory{ctrl: ctrl}
	mock.recorder = &MockStatusHistoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatusHistory) EXPECT() *MockStatusHistoryMockRecorder {
	return m.recorder
}

// RecordStatus mocks base method.
func (m *MockStatusHistory) RecordStatus(arg0 context.Context, arg1 statushistory.Namespace, arg2 status.StatusInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RecordStatus", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RecordStatus indicates an expected call of RecordStatus.
func (mr *MockStatusHistoryMockRecorder) RecordStatus(arg0, arg1, arg2 any) *MockStatusHistoryRecordStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecordStatus", reflect.TypeOf((*MockStatusHistory)(nil).RecordStatus), arg0, arg1, arg2)
	return &MockStatusHistoryRecordStatusCall{Call: call}
}

// MockStatusHistoryRecordStatusCall wrap *gomock.Call
type MockStatusHistoryRecordStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStatusHistoryRecordStatusCall) Return(arg0 error) *MockStatusHistoryRecordStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStatusHistoryRecordStatusCall) Do(f func(context.Context, statushistory.Namespace, status.StatusInfo) error) *MockStatusHistoryRecordStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStatusHistoryRecordStatusCall) DoAndReturn(f func(context.Context, statushistory.Namespace, status.StatusInfo) error) *MockStatusHistoryRecordStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockWatcherFactory is a mock of WatcherFactory interface.
type MockWatcherFactory struct {
	ctrl     *gomock.Controller
	recorder *MockWatcherFactoryMockRecorder
}

// MockWatcherFactoryMockRecorder is the mock recorder for MockWatcherFactory.
type MockWatcherFactoryMockRecorder struct {
	mock *MockWatcherFactory
}

// NewMockWatcherFactory creates a new mock instance.
func NewMockWatcherFactory(ctrl *gomock.Controller) *MockWatcherFactory {
	mock := &MockWatcherFactory{ctrl: ctrl}
	mock.recorder = &MockWatcherFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWatcherFactory) EXPECT() *MockWatcherFactoryMockRecorder {
	return m.recorder
}

// NewNamespaceMapperWatcher mocks base method.
func (m *MockWatcherFactory) NewNamespaceMapperWatcher(arg0 context.Context, arg1 eventsource.NamespaceQuery, arg2 string, arg3 eventsource.Mapper, arg4 eventsource.FilterOption, arg5 ...eventsource.FilterOption) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewNamespaceMapperWatcher", varargs...)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewNamespaceMapperWatcher indicates an expected call of NewNamespaceMapperWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewNamespaceMapperWatcher(arg0, arg1, arg2, arg3, arg4 any, arg5 ...any) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3, arg4}, arg5...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewNamespaceMapperWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewNamespaceMapperWatcher), varargs...)
	return &MockWatcherFactoryNewNamespaceMapperWatcherCall{Call: call}
}

// MockWatcherFactoryNewNamespaceMapperWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewNamespaceMapperWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) Do(f func(context.Context, eventsource.NamespaceQuery, string, eventsource.Mapper, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) DoAndReturn(f func(context.Context, eventsource.NamespaceQuery, string, eventsource.Mapper, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewNamespaceWatcher mocks base method.
func (m *MockWatcherFactory) NewNamespaceWatcher(arg0 context.Context, arg1 eventsource.NamespaceQuery, arg2 string, arg3 eventsource.FilterOption, arg4 ...eventsource.FilterOption) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewNamespaceWatcher", varargs...)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewNamespaceWatcher indicates an expected call of NewNamespaceWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewNamespaceWatcher(arg0, arg1, arg2, arg3 any, arg4 ...any) *MockWatcherFactoryNewNamespaceWatcherCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3}, arg4...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewNamespaceWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewNamespaceWatcher), varargs...)
	return &MockWatcherFactoryNewNamespaceWatcherCall{Call: call}
}

// MockWatcherFactoryNewNamespaceWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewNamespaceWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewNamespaceWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewNamespaceWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewNamespaceWatcherCall) Do(f func(context.Context, eventsource.NamespaceQuery, string, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewNamespaceWatcherCall) DoAndReturn(f func(context.Context, eventsource.NamespaceQuery, string, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewNotifyMapperWatcher mocks base method.
func (m *MockWatcherFactory) NewNotifyMapperWatcher(arg0 context.Context, arg1 string, arg2 eventsource.Mapper, arg3 eventsource.FilterOption, arg4 ...eventsource.FilterOption) (watcher.Watcher[struct{}], error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewNotifyMapperWatcher", varargs...)
	ret0, _ := ret[0].(watcher.Watcher[struct{}])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewNotifyMapperWatcher indicates an expected call of NewNotifyMapperWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewNotifyMapperWatcher(arg0, arg1, arg2, arg3 any, arg4 ...any) *MockWatcherFactoryNewNotifyMapperWatcherCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3}, arg4...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewNotifyMapperWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewNotifyMapperWatcher), varargs...)
	return &MockWatcherFactoryNewNotifyMapperWatcherCall{Call: call}
}

// MockWatcherFactoryNewNotifyMapperWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewNotifyMapperWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewNotifyMapperWatcherCall) Return(arg0 watcher.Watcher[struct{}], arg1 error) *MockWatcherFactoryNewNotifyMapperWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewNotifyMapperWatcherCall) Do(f func(context.Context, string, eventsource.Mapper, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewNotifyMapperWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewNotifyMapperWatcherCall) DoAndReturn(f func(context.Context, string, eventsource.Mapper, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewNotifyMapperWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewNotifyWatcher mocks base method.
func (m *MockWatcherFactory) NewNotifyWatcher(arg0 context.Context, arg1 string, arg2 eventsource.FilterOption, arg3 ...eventsource.FilterOption) (watcher.Watcher[struct{}], error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewNotifyWatcher", varargs...)
	ret0, _ := ret[0].(watcher.Watcher[struct{}])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewNotifyWatcher indicates an expected call of NewNotifyWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewNotifyWatcher(arg0, arg1, arg2 any, arg3 ...any) *MockWatcherFactoryNewNotifyWatcherCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2}, arg3...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewNotifyWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewNotifyWatcher), varargs...)
	return &MockWatcherFactoryNewNotifyWatcherCall{Call: call}
}

// MockWatcherFactoryNewNotifyWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewNotifyWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewNotifyWatcherCall) Return(arg0 watcher.Watcher[struct{}], arg1 error) *MockWatcherFactoryNewNotifyWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewNotifyWatcherCall) Do(f func(context.Context, string, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewNotifyWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewNotifyWatcherCall) DoAndReturn(f func(context.Context, string, eventsource.FilterOption, ...eventsource.FilterOption) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewNotifyWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewUUIDsWatcher mocks base method.
func (m *MockWatcherFactory) NewUUIDsWatcher(arg0 context.Context, arg1, arg2 string, arg3 changestream.ChangeType) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewUUIDsWatcher", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewUUIDsWatcher indicates an expected call of NewUUIDsWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewUUIDsWatcher(arg0, arg1, arg2, arg3 any) *MockWatcherFactoryNewUUIDsWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewUUIDsWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewUUIDsWatcher), arg0, arg1, arg2, arg3)
	return &MockWatcherFactoryNewUUIDsWatcherCall{Call: call}
}

// MockWatcherFactoryNewUUIDsWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewUUIDsWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewUUIDsWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewUUIDsWatcherCall) Do(f func(context.Context, string, string, changestream.ChangeType) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewUUIDsWatcherCall) DoAndReturn(f func(context.Context, string, string, changestream.ChangeType) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

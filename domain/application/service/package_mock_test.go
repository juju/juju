// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/juju/juju/domain/application/service (interfaces: State,WatcherFactory,AgentVersionGetter,Provider,CharmStore)
//
// Generated by this command:
//
//	mockgen -typed -package service -destination package_mock_test.go github.com/juju/juju/domain/application/service State,WatcherFactory,AgentVersionGetter,Provider,CharmStore
//

// Package service is a generated GoMock package.
package service

import (
	"context"
	"io"
	"reflect"

	"github.com/juju/version/v2"
	"go.uber.org/mock/gomock"

	"github.com/juju/juju/core/application"
	"github.com/juju/juju/core/assumes"
	"github.com/juju/juju/core/changestream"
	"github.com/juju/juju/core/charm"
	"github.com/juju/juju/core/model"
	"github.com/juju/juju/core/network"
	storage2 "github.com/juju/juju/core/storage"
	"github.com/juju/juju/core/unit"
	"github.com/juju/juju/core/watcher"
	"github.com/juju/juju/core/watcher/eventsource"
	application0 "github.com/juju/juju/domain/application"
	"github.com/juju/juju/domain/application/architecture"
	charm0 "github.com/juju/juju/domain/application/charm"
	"github.com/juju/juju/domain/application/charm/store"
	"github.com/juju/juju/domain/life"
	"github.com/juju/juju/domain/storage"
	storage0 "github.com/juju/juju/internal/storage"
)

// MockState is a mock of State interface.
type MockState struct {
	ctrl     *gomock.Controller
	recorder *MockStateMockRecorder
}

// MockStateMockRecorder is the mock recorder for MockState.
type MockStateMockRecorder struct {
	mock *MockState
}

// NewMockState creates a new mock instance.
func NewMockState(ctrl *gomock.Controller) *MockState {
	mock := &MockState{ctrl: ctrl}
	mock.recorder = &MockStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockState) EXPECT() *MockStateMockRecorder {
	return m.recorder
}

// AddStorageForUnit mocks base method.
func (m *MockState) AddStorageForUnit(arg0 context.Context, arg1 storage2.Name, arg2 unit.UUID, arg3 storage0.Directive) ([]storage2.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddStorageForUnit", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]storage2.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddStorageForUnit indicates an expected call of AddStorageForUnit.
func (mr *MockStateMockRecorder) AddStorageForUnit(arg0, arg1, arg2, arg3 any) *MockStateAddStorageForUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddStorageForUnit", reflect.TypeOf((*MockState)(nil).AddStorageForUnit), arg0, arg1, arg2, arg3)
	return &MockStateAddStorageForUnitCall{Call: call}
}

// MockStateAddStorageForUnitCall wrap *gomock.Call
type MockStateAddStorageForUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAddStorageForUnitCall) Return(arg0 []storage2.ID, arg1 error) *MockStateAddStorageForUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAddStorageForUnitCall) Do(f func(context.Context, storage2.Name, unit.UUID, storage0.Directive) ([]storage2.ID, error)) *MockStateAddStorageForUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAddStorageForUnitCall) DoAndReturn(f func(context.Context, storage2.Name, unit.UUID, storage0.Directive) ([]storage2.ID, error)) *MockStateAddStorageForUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddUnits mocks base method.
func (m *MockState) AddUnits(arg0 context.Context, arg1 application.ID, arg2 ...application0.AddUnitArg) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddUnits", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddUnits indicates an expected call of AddUnits.
func (mr *MockStateMockRecorder) AddUnits(arg0, arg1 any, arg2 ...any) *MockStateAddUnitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUnits", reflect.TypeOf((*MockState)(nil).AddUnits), varargs...)
	return &MockStateAddUnitsCall{Call: call}
}

// MockStateAddUnitsCall wrap *gomock.Call
type MockStateAddUnitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAddUnitsCall) Return(arg0 error) *MockStateAddUnitsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAddUnitsCall) Do(f func(context.Context, application.ID, ...application0.AddUnitArg) error) *MockStateAddUnitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAddUnitsCall) DoAndReturn(f func(context.Context, application.ID, ...application0.AddUnitArg) error) *MockStateAddUnitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AttachStorage mocks base method.
func (m *MockState) AttachStorage(arg0 context.Context, arg1 storage2.ID, arg2 unit.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AttachStorage", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// AttachStorage indicates an expected call of AttachStorage.
func (mr *MockStateMockRecorder) AttachStorage(arg0, arg1, arg2 any) *MockStateAttachStorageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachStorage", reflect.TypeOf((*MockState)(nil).AttachStorage), arg0, arg1, arg2)
	return &MockStateAttachStorageCall{Call: call}
}

// MockStateAttachStorageCall wrap *gomock.Call
type MockStateAttachStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAttachStorageCall) Return(arg0 error) *MockStateAttachStorageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAttachStorageCall) Do(f func(context.Context, storage2.ID, unit.UUID) error) *MockStateAttachStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAttachStorageCall) DoAndReturn(f func(context.Context, storage2.ID, unit.UUID) error) *MockStateAttachStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateApplication mocks base method.
func (m *MockState) CreateApplication(arg0 context.Context, arg1 string, arg2 application0.AddApplicationArg, arg3 []application0.AddUnitArg) (application.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateApplication", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateApplication indicates an expected call of CreateApplication.
func (mr *MockStateMockRecorder) CreateApplication(arg0, arg1, arg2, arg3 any) *MockStateCreateApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateApplication", reflect.TypeOf((*MockState)(nil).CreateApplication), arg0, arg1, arg2, arg3)
	return &MockStateCreateApplicationCall{Call: call}
}

// MockStateCreateApplicationCall wrap *gomock.Call
type MockStateCreateApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateCreateApplicationCall) Return(arg0 application.ID, arg1 error) *MockStateCreateApplicationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateCreateApplicationCall) Do(f func(context.Context, string, application0.AddApplicationArg, []application0.AddUnitArg) (application.ID, error)) *MockStateCreateApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateCreateApplicationCall) DoAndReturn(f func(context.Context, string, application0.AddApplicationArg, []application0.AddUnitArg) (application.ID, error)) *MockStateCreateApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteApplication mocks base method.
func (m *MockState) DeleteApplication(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteApplication", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteApplication indicates an expected call of DeleteApplication.
func (mr *MockStateMockRecorder) DeleteApplication(arg0, arg1 any) *MockStateDeleteApplicationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteApplication", reflect.TypeOf((*MockState)(nil).DeleteApplication), arg0, arg1)
	return &MockStateDeleteApplicationCall{Call: call}
}

// MockStateDeleteApplicationCall wrap *gomock.Call
type MockStateDeleteApplicationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateDeleteApplicationCall) Return(arg0 error) *MockStateDeleteApplicationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateDeleteApplicationCall) Do(f func(context.Context, string) error) *MockStateDeleteApplicationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateDeleteApplicationCall) DoAndReturn(f func(context.Context, string) error) *MockStateDeleteApplicationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteCharm mocks base method.
func (m *MockState) DeleteCharm(arg0 context.Context, arg1 charm.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteCharm", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteCharm indicates an expected call of DeleteCharm.
func (mr *MockStateMockRecorder) DeleteCharm(arg0, arg1 any) *MockStateDeleteCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCharm", reflect.TypeOf((*MockState)(nil).DeleteCharm), arg0, arg1)
	return &MockStateDeleteCharmCall{Call: call}
}

// MockStateDeleteCharmCall wrap *gomock.Call
type MockStateDeleteCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateDeleteCharmCall) Return(arg0 error) *MockStateDeleteCharmCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateDeleteCharmCall) Do(f func(context.Context, charm.ID) error) *MockStateDeleteCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateDeleteCharmCall) DoAndReturn(f func(context.Context, charm.ID) error) *MockStateDeleteCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteUnit mocks base method.
func (m *MockState) DeleteUnit(arg0 context.Context, arg1 unit.Name) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteUnit", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteUnit indicates an expected call of DeleteUnit.
func (mr *MockStateMockRecorder) DeleteUnit(arg0, arg1 any) *MockStateDeleteUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUnit", reflect.TypeOf((*MockState)(nil).DeleteUnit), arg0, arg1)
	return &MockStateDeleteUnitCall{Call: call}
}

// MockStateDeleteUnitCall wrap *gomock.Call
type MockStateDeleteUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateDeleteUnitCall) Return(arg0 bool, arg1 error) *MockStateDeleteUnitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateDeleteUnitCall) Do(f func(context.Context, unit.Name) (bool, error)) *MockStateDeleteUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateDeleteUnitCall) DoAndReturn(f func(context.Context, unit.Name) (bool, error)) *MockStateDeleteUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DetachStorage mocks base method.
func (m *MockState) DetachStorage(arg0 context.Context, arg1 storage2.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DetachStorage", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DetachStorage indicates an expected call of DetachStorage.
func (mr *MockStateMockRecorder) DetachStorage(arg0, arg1 any) *MockStateDetachStorageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachStorage", reflect.TypeOf((*MockState)(nil).DetachStorage), arg0, arg1)
	return &MockStateDetachStorageCall{Call: call}
}

// MockStateDetachStorageCall wrap *gomock.Call
type MockStateDetachStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateDetachStorageCall) Return(arg0 error) *MockStateDetachStorageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateDetachStorageCall) Do(f func(context.Context, storage2.ID) error) *MockStateDetachStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateDetachStorageCall) DoAndReturn(f func(context.Context, storage2.ID) error) *MockStateDetachStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DetachStorageForUnit mocks base method.
func (m *MockState) DetachStorageForUnit(arg0 context.Context, arg1 storage2.ID, arg2 unit.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DetachStorageForUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// DetachStorageForUnit indicates an expected call of DetachStorageForUnit.
func (mr *MockStateMockRecorder) DetachStorageForUnit(arg0, arg1, arg2 any) *MockStateDetachStorageForUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachStorageForUnit", reflect.TypeOf((*MockState)(nil).DetachStorageForUnit), arg0, arg1, arg2)
	return &MockStateDetachStorageForUnitCall{Call: call}
}

// MockStateDetachStorageForUnitCall wrap *gomock.Call
type MockStateDetachStorageForUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateDetachStorageForUnitCall) Return(arg0 error) *MockStateDetachStorageForUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateDetachStorageForUnitCall) Do(f func(context.Context, storage2.ID, unit.UUID) error) *MockStateDetachStorageForUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateDetachStorageForUnitCall) DoAndReturn(f func(context.Context, storage2.ID, unit.UUID) error) *MockStateDetachStorageForUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationConfigAndSettings mocks base method.
func (m *MockState) GetApplicationConfigAndSettings(arg0 context.Context, arg1 application.ID) (map[string]application0.ApplicationConfig, application0.ApplicationSettings, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationConfigAndSettings", arg0, arg1)
	ret0, _ := ret[0].(map[string]application0.ApplicationConfig)
	ret1, _ := ret[1].(application0.ApplicationSettings)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApplicationConfigAndSettings indicates an expected call of GetApplicationConfigAndSettings.
func (mr *MockStateMockRecorder) GetApplicationConfigAndSettings(arg0, arg1 any) *MockStateGetApplicationConfigAndSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationConfigAndSettings", reflect.TypeOf((*MockState)(nil).GetApplicationConfigAndSettings), arg0, arg1)
	return &MockStateGetApplicationConfigAndSettingsCall{Call: call}
}

// MockStateGetApplicationConfigAndSettingsCall wrap *gomock.Call
type MockStateGetApplicationConfigAndSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationConfigAndSettingsCall) Return(arg0 map[string]application0.ApplicationConfig, arg1 application0.ApplicationSettings, arg2 error) *MockStateGetApplicationConfigAndSettingsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationConfigAndSettingsCall) Do(f func(context.Context, application.ID) (map[string]application0.ApplicationConfig, application0.ApplicationSettings, error)) *MockStateGetApplicationConfigAndSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationConfigAndSettingsCall) DoAndReturn(f func(context.Context, application.ID) (map[string]application0.ApplicationConfig, application0.ApplicationSettings, error)) *MockStateGetApplicationConfigAndSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationConfigHash mocks base method.
func (m *MockState) GetApplicationConfigHash(arg0 context.Context, arg1 application.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationConfigHash", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationConfigHash indicates an expected call of GetApplicationConfigHash.
func (mr *MockStateMockRecorder) GetApplicationConfigHash(arg0, arg1 any) *MockStateGetApplicationConfigHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationConfigHash", reflect.TypeOf((*MockState)(nil).GetApplicationConfigHash), arg0, arg1)
	return &MockStateGetApplicationConfigHashCall{Call: call}
}

// MockStateGetApplicationConfigHashCall wrap *gomock.Call
type MockStateGetApplicationConfigHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationConfigHashCall) Return(arg0 string, arg1 error) *MockStateGetApplicationConfigHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationConfigHashCall) Do(f func(context.Context, application.ID) (string, error)) *MockStateGetApplicationConfigHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationConfigHashCall) DoAndReturn(f func(context.Context, application.ID) (string, error)) *MockStateGetApplicationConfigHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationIDByName mocks base method.
func (m *MockState) GetApplicationIDByName(arg0 context.Context, arg1 string) (application.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationIDByName", arg0, arg1)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationIDByName indicates an expected call of GetApplicationIDByName.
func (mr *MockStateMockRecorder) GetApplicationIDByName(arg0, arg1 any) *MockStateGetApplicationIDByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationIDByName", reflect.TypeOf((*MockState)(nil).GetApplicationIDByName), arg0, arg1)
	return &MockStateGetApplicationIDByNameCall{Call: call}
}

// MockStateGetApplicationIDByNameCall wrap *gomock.Call
type MockStateGetApplicationIDByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationIDByNameCall) Return(arg0 application.ID, arg1 error) *MockStateGetApplicationIDByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationIDByNameCall) Do(f func(context.Context, string) (application.ID, error)) *MockStateGetApplicationIDByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationIDByNameCall) DoAndReturn(f func(context.Context, string) (application.ID, error)) *MockStateGetApplicationIDByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationIDByUnitName mocks base method.
func (m *MockState) GetApplicationIDByUnitName(arg0 context.Context, arg1 unit.Name) (application.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationIDByUnitName", arg0, arg1)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationIDByUnitName indicates an expected call of GetApplicationIDByUnitName.
func (mr *MockStateMockRecorder) GetApplicationIDByUnitName(arg0, arg1 any) *MockStateGetApplicationIDByUnitNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationIDByUnitName", reflect.TypeOf((*MockState)(nil).GetApplicationIDByUnitName), arg0, arg1)
	return &MockStateGetApplicationIDByUnitNameCall{Call: call}
}

// MockStateGetApplicationIDByUnitNameCall wrap *gomock.Call
type MockStateGetApplicationIDByUnitNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationIDByUnitNameCall) Return(arg0 application.ID, arg1 error) *MockStateGetApplicationIDByUnitNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationIDByUnitNameCall) Do(f func(context.Context, unit.Name) (application.ID, error)) *MockStateGetApplicationIDByUnitNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationIDByUnitNameCall) DoAndReturn(f func(context.Context, unit.Name) (application.ID, error)) *MockStateGetApplicationIDByUnitNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationLife mocks base method.
func (m *MockState) GetApplicationLife(arg0 context.Context, arg1 string) (application.ID, life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationLife", arg0, arg1)
	ret0, _ := ret[0].(application.ID)
	ret1, _ := ret[1].(life.Life)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApplicationLife indicates an expected call of GetApplicationLife.
func (mr *MockStateMockRecorder) GetApplicationLife(arg0, arg1 any) *MockStateGetApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationLife", reflect.TypeOf((*MockState)(nil).GetApplicationLife), arg0, arg1)
	return &MockStateGetApplicationLifeCall{Call: call}
}

// MockStateGetApplicationLifeCall wrap *gomock.Call
type MockStateGetApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationLifeCall) Return(arg0 application.ID, arg1 life.Life, arg2 error) *MockStateGetApplicationLifeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationLifeCall) Do(f func(context.Context, string) (application.ID, life.Life, error)) *MockStateGetApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationLifeCall) DoAndReturn(f func(context.Context, string) (application.ID, life.Life, error)) *MockStateGetApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationScaleState mocks base method.
func (m *MockState) GetApplicationScaleState(arg0 context.Context, arg1 application.ID) (application0.ScaleState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationScaleState", arg0, arg1)
	ret0, _ := ret[0].(application0.ScaleState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationScaleState indicates an expected call of GetApplicationScaleState.
func (mr *MockStateMockRecorder) GetApplicationScaleState(arg0, arg1 any) *MockStateGetApplicationScaleStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationScaleState", reflect.TypeOf((*MockState)(nil).GetApplicationScaleState), arg0, arg1)
	return &MockStateGetApplicationScaleStateCall{Call: call}
}

// MockStateGetApplicationScaleStateCall wrap *gomock.Call
type MockStateGetApplicationScaleStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationScaleStateCall) Return(arg0 application0.ScaleState, arg1 error) *MockStateGetApplicationScaleStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationScaleStateCall) Do(f func(context.Context, application.ID) (application0.ScaleState, error)) *MockStateGetApplicationScaleStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationScaleStateCall) DoAndReturn(f func(context.Context, application.ID) (application0.ScaleState, error)) *MockStateGetApplicationScaleStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationTrustSetting mocks base method.
func (m *MockState) GetApplicationTrustSetting(arg0 context.Context, arg1 application.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationTrustSetting", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationTrustSetting indicates an expected call of GetApplicationTrustSetting.
func (mr *MockStateMockRecorder) GetApplicationTrustSetting(arg0, arg1 any) *MockStateGetApplicationTrustSettingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationTrustSetting", reflect.TypeOf((*MockState)(nil).GetApplicationTrustSetting), arg0, arg1)
	return &MockStateGetApplicationTrustSettingCall{Call: call}
}

// MockStateGetApplicationTrustSettingCall wrap *gomock.Call
type MockStateGetApplicationTrustSettingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationTrustSettingCall) Return(arg0 bool, arg1 error) *MockStateGetApplicationTrustSettingCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationTrustSettingCall) Do(f func(context.Context, application.ID) (bool, error)) *MockStateGetApplicationTrustSettingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationTrustSettingCall) DoAndReturn(f func(context.Context, application.ID) (bool, error)) *MockStateGetApplicationTrustSettingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationUnitLife mocks base method.
func (m *MockState) GetApplicationUnitLife(arg0 context.Context, arg1 string, arg2 ...unit.UUID) (map[unit.UUID]life.Life, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetApplicationUnitLife", varargs...)
	ret0, _ := ret[0].(map[unit.UUID]life.Life)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationUnitLife indicates an expected call of GetApplicationUnitLife.
func (mr *MockStateMockRecorder) GetApplicationUnitLife(arg0, arg1 any, arg2 ...any) *MockStateGetApplicationUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationUnitLife", reflect.TypeOf((*MockState)(nil).GetApplicationUnitLife), varargs...)
	return &MockStateGetApplicationUnitLifeCall{Call: call}
}

// MockStateGetApplicationUnitLifeCall wrap *gomock.Call
type MockStateGetApplicationUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationUnitLifeCall) Return(arg0 map[unit.UUID]life.Life, arg1 error) *MockStateGetApplicationUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationUnitLifeCall) Do(f func(context.Context, string, ...unit.UUID) (map[unit.UUID]life.Life, error)) *MockStateGetApplicationUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationUnitLifeCall) DoAndReturn(f func(context.Context, string, ...unit.UUID) (map[unit.UUID]life.Life, error)) *MockStateGetApplicationUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationsForRevisionUpdater mocks base method.
func (m *MockState) GetApplicationsForRevisionUpdater(arg0 context.Context) ([]application0.RevisionUpdaterApplication, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationsForRevisionUpdater", arg0)
	ret0, _ := ret[0].([]application0.RevisionUpdaterApplication)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationsForRevisionUpdater indicates an expected call of GetApplicationsForRevisionUpdater.
func (mr *MockStateMockRecorder) GetApplicationsForRevisionUpdater(arg0 any) *MockStateGetApplicationsForRevisionUpdaterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationsForRevisionUpdater", reflect.TypeOf((*MockState)(nil).GetApplicationsForRevisionUpdater), arg0)
	return &MockStateGetApplicationsForRevisionUpdaterCall{Call: call}
}

// MockStateGetApplicationsForRevisionUpdaterCall wrap *gomock.Call
type MockStateGetApplicationsForRevisionUpdaterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationsForRevisionUpdaterCall) Return(arg0 []application0.RevisionUpdaterApplication, arg1 error) *MockStateGetApplicationsForRevisionUpdaterCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationsForRevisionUpdaterCall) Do(f func(context.Context) ([]application0.RevisionUpdaterApplication, error)) *MockStateGetApplicationsForRevisionUpdaterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationsForRevisionUpdaterCall) DoAndReturn(f func(context.Context) ([]application0.RevisionUpdaterApplication, error)) *MockStateGetApplicationsForRevisionUpdaterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApplicationsWithPendingCharmsFromUUIDs mocks base method.
func (m *MockState) GetApplicationsWithPendingCharmsFromUUIDs(arg0 context.Context, arg1 []application.ID) ([]application.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetApplicationsWithPendingCharmsFromUUIDs", arg0, arg1)
	ret0, _ := ret[0].([]application.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetApplicationsWithPendingCharmsFromUUIDs indicates an expected call of GetApplicationsWithPendingCharmsFromUUIDs.
func (mr *MockStateMockRecorder) GetApplicationsWithPendingCharmsFromUUIDs(arg0, arg1 any) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApplicationsWithPendingCharmsFromUUIDs", reflect.TypeOf((*MockState)(nil).GetApplicationsWithPendingCharmsFromUUIDs), arg0, arg1)
	return &MockStateGetApplicationsWithPendingCharmsFromUUIDsCall{Call: call}
}

// MockStateGetApplicationsWithPendingCharmsFromUUIDsCall wrap *gomock.Call
type MockStateGetApplicationsWithPendingCharmsFromUUIDsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall) Return(arg0 []application.ID, arg1 error) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall) Do(f func(context.Context, []application.ID) ([]application.ID, error)) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall) DoAndReturn(f func(context.Context, []application.ID) ([]application.ID, error)) *MockStateGetApplicationsWithPendingCharmsFromUUIDsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAsyncCharmDownloadInfo mocks base method.
func (m *MockState) GetAsyncCharmDownloadInfo(arg0 context.Context, arg1 application.ID) (application0.CharmDownloadInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAsyncCharmDownloadInfo", arg0, arg1)
	ret0, _ := ret[0].(application0.CharmDownloadInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAsyncCharmDownloadInfo indicates an expected call of GetAsyncCharmDownloadInfo.
func (mr *MockStateMockRecorder) GetAsyncCharmDownloadInfo(arg0, arg1 any) *MockStateGetAsyncCharmDownloadInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAsyncCharmDownloadInfo", reflect.TypeOf((*MockState)(nil).GetAsyncCharmDownloadInfo), arg0, arg1)
	return &MockStateGetAsyncCharmDownloadInfoCall{Call: call}
}

// MockStateGetAsyncCharmDownloadInfoCall wrap *gomock.Call
type MockStateGetAsyncCharmDownloadInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAsyncCharmDownloadInfoCall) Return(arg0 application0.CharmDownloadInfo, arg1 error) *MockStateGetAsyncCharmDownloadInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAsyncCharmDownloadInfoCall) Do(f func(context.Context, application.ID) (application0.CharmDownloadInfo, error)) *MockStateGetAsyncCharmDownloadInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAsyncCharmDownloadInfoCall) DoAndReturn(f func(context.Context, application.ID) (application0.CharmDownloadInfo, error)) *MockStateGetAsyncCharmDownloadInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAvailableCharmArchiveSHA256 mocks base method.
func (m *MockState) GetAvailableCharmArchiveSHA256(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAvailableCharmArchiveSHA256", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAvailableCharmArchiveSHA256 indicates an expected call of GetAvailableCharmArchiveSHA256.
func (mr *MockStateMockRecorder) GetAvailableCharmArchiveSHA256(arg0, arg1 any) *MockStateGetAvailableCharmArchiveSHA256Call {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAvailableCharmArchiveSHA256", reflect.TypeOf((*MockState)(nil).GetAvailableCharmArchiveSHA256), arg0, arg1)
	return &MockStateGetAvailableCharmArchiveSHA256Call{Call: call}
}

// MockStateGetAvailableCharmArchiveSHA256Call wrap *gomock.Call
type MockStateGetAvailableCharmArchiveSHA256Call struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetAvailableCharmArchiveSHA256Call) Return(arg0 string, arg1 error) *MockStateGetAvailableCharmArchiveSHA256Call {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetAvailableCharmArchiveSHA256Call) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetAvailableCharmArchiveSHA256Call {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetAvailableCharmArchiveSHA256Call) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetAvailableCharmArchiveSHA256Call {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharm mocks base method.
func (m *MockState) GetCharm(arg0 context.Context, arg1 charm.ID) (charm0.Charm, *charm0.DownloadInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharm", arg0, arg1)
	ret0, _ := ret[0].(charm0.Charm)
	ret1, _ := ret[1].(*charm0.DownloadInfo)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharm indicates an expected call of GetCharm.
func (mr *MockStateMockRecorder) GetCharm(arg0, arg1 any) *MockStateGetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharm", reflect.TypeOf((*MockState)(nil).GetCharm), arg0, arg1)
	return &MockStateGetCharmCall{Call: call}
}

// MockStateGetCharmCall wrap *gomock.Call
type MockStateGetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmCall) Return(arg0 charm0.Charm, arg1 *charm0.DownloadInfo, arg2 error) *MockStateGetCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmCall) Do(f func(context.Context, charm.ID) (charm0.Charm, *charm0.DownloadInfo, error)) *MockStateGetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Charm, *charm0.DownloadInfo, error)) *MockStateGetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmActions mocks base method.
func (m *MockState) GetCharmActions(arg0 context.Context, arg1 charm.ID) (charm0.Actions, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmActions", arg0, arg1)
	ret0, _ := ret[0].(charm0.Actions)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmActions indicates an expected call of GetCharmActions.
func (mr *MockStateMockRecorder) GetCharmActions(arg0, arg1 any) *MockStateGetCharmActionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmActions", reflect.TypeOf((*MockState)(nil).GetCharmActions), arg0, arg1)
	return &MockStateGetCharmActionsCall{Call: call}
}

// MockStateGetCharmActionsCall wrap *gomock.Call
type MockStateGetCharmActionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmActionsCall) Return(arg0 charm0.Actions, arg1 error) *MockStateGetCharmActionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmActionsCall) Do(f func(context.Context, charm.ID) (charm0.Actions, error)) *MockStateGetCharmActionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmActionsCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Actions, error)) *MockStateGetCharmActionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmArchiveMetadata mocks base method.
func (m *MockState) GetCharmArchiveMetadata(arg0 context.Context, arg1 charm.ID) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmArchiveMetadata", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmArchiveMetadata indicates an expected call of GetCharmArchiveMetadata.
func (mr *MockStateMockRecorder) GetCharmArchiveMetadata(arg0, arg1 any) *MockStateGetCharmArchiveMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmArchiveMetadata", reflect.TypeOf((*MockState)(nil).GetCharmArchiveMetadata), arg0, arg1)
	return &MockStateGetCharmArchiveMetadataCall{Call: call}
}

// MockStateGetCharmArchiveMetadataCall wrap *gomock.Call
type MockStateGetCharmArchiveMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmArchiveMetadataCall) Return(arg0, arg1 string, arg2 error) *MockStateGetCharmArchiveMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmArchiveMetadataCall) Do(f func(context.Context, charm.ID) (string, string, error)) *MockStateGetCharmArchiveMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmArchiveMetadataCall) DoAndReturn(f func(context.Context, charm.ID) (string, string, error)) *MockStateGetCharmArchiveMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmArchivePath mocks base method.
func (m *MockState) GetCharmArchivePath(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmArchivePath", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmArchivePath indicates an expected call of GetCharmArchivePath.
func (mr *MockStateMockRecorder) GetCharmArchivePath(arg0, arg1 any) *MockStateGetCharmArchivePathCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmArchivePath", reflect.TypeOf((*MockState)(nil).GetCharmArchivePath), arg0, arg1)
	return &MockStateGetCharmArchivePathCall{Call: call}
}

// MockStateGetCharmArchivePathCall wrap *gomock.Call
type MockStateGetCharmArchivePathCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmArchivePathCall) Return(arg0 string, arg1 error) *MockStateGetCharmArchivePathCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmArchivePathCall) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmArchivePathCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmArchivePathCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmArchivePathCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmByApplicationID mocks base method.
func (m *MockState) GetCharmByApplicationID(arg0 context.Context, arg1 application.ID) (charm0.Charm, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmByApplicationID", arg0, arg1)
	ret0, _ := ret[0].(charm0.Charm)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmByApplicationID indicates an expected call of GetCharmByApplicationID.
func (mr *MockStateMockRecorder) GetCharmByApplicationID(arg0, arg1 any) *MockStateGetCharmByApplicationIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmByApplicationID", reflect.TypeOf((*MockState)(nil).GetCharmByApplicationID), arg0, arg1)
	return &MockStateGetCharmByApplicationIDCall{Call: call}
}

// MockStateGetCharmByApplicationIDCall wrap *gomock.Call
type MockStateGetCharmByApplicationIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmByApplicationIDCall) Return(arg0 charm0.Charm, arg1 error) *MockStateGetCharmByApplicationIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmByApplicationIDCall) Do(f func(context.Context, application.ID) (charm0.Charm, error)) *MockStateGetCharmByApplicationIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmByApplicationIDCall) DoAndReturn(f func(context.Context, application.ID) (charm0.Charm, error)) *MockStateGetCharmByApplicationIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmConfig mocks base method.
func (m *MockState) GetCharmConfig(arg0 context.Context, arg1 charm.ID) (charm0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmConfig", arg0, arg1)
	ret0, _ := ret[0].(charm0.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmConfig indicates an expected call of GetCharmConfig.
func (mr *MockStateMockRecorder) GetCharmConfig(arg0, arg1 any) *MockStateGetCharmConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmConfig", reflect.TypeOf((*MockState)(nil).GetCharmConfig), arg0, arg1)
	return &MockStateGetCharmConfigCall{Call: call}
}

// MockStateGetCharmConfigCall wrap *gomock.Call
type MockStateGetCharmConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmConfigCall) Return(arg0 charm0.Config, arg1 error) *MockStateGetCharmConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmConfigCall) Do(f func(context.Context, charm.ID) (charm0.Config, error)) *MockStateGetCharmConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmConfigCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Config, error)) *MockStateGetCharmConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmConfigByApplicationID mocks base method.
func (m *MockState) GetCharmConfigByApplicationID(arg0 context.Context, arg1 application.ID) (charm.ID, charm0.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmConfigByApplicationID", arg0, arg1)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(charm0.Config)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmConfigByApplicationID indicates an expected call of GetCharmConfigByApplicationID.
func (mr *MockStateMockRecorder) GetCharmConfigByApplicationID(arg0, arg1 any) *MockStateGetCharmConfigByApplicationIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmConfigByApplicationID", reflect.TypeOf((*MockState)(nil).GetCharmConfigByApplicationID), arg0, arg1)
	return &MockStateGetCharmConfigByApplicationIDCall{Call: call}
}

// MockStateGetCharmConfigByApplicationIDCall wrap *gomock.Call
type MockStateGetCharmConfigByApplicationIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmConfigByApplicationIDCall) Return(arg0 charm.ID, arg1 charm0.Config, arg2 error) *MockStateGetCharmConfigByApplicationIDCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmConfigByApplicationIDCall) Do(f func(context.Context, application.ID) (charm.ID, charm0.Config, error)) *MockStateGetCharmConfigByApplicationIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmConfigByApplicationIDCall) DoAndReturn(f func(context.Context, application.ID) (charm.ID, charm0.Config, error)) *MockStateGetCharmConfigByApplicationIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmDownloadInfo mocks base method.
func (m *MockState) GetCharmDownloadInfo(arg0 context.Context, arg1 charm.ID) (*charm0.DownloadInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmDownloadInfo", arg0, arg1)
	ret0, _ := ret[0].(*charm0.DownloadInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmDownloadInfo indicates an expected call of GetCharmDownloadInfo.
func (mr *MockStateMockRecorder) GetCharmDownloadInfo(arg0, arg1 any) *MockStateGetCharmDownloadInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmDownloadInfo", reflect.TypeOf((*MockState)(nil).GetCharmDownloadInfo), arg0, arg1)
	return &MockStateGetCharmDownloadInfoCall{Call: call}
}

// MockStateGetCharmDownloadInfoCall wrap *gomock.Call
type MockStateGetCharmDownloadInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmDownloadInfoCall) Return(arg0 *charm0.DownloadInfo, arg1 error) *MockStateGetCharmDownloadInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmDownloadInfoCall) Do(f func(context.Context, charm.ID) (*charm0.DownloadInfo, error)) *MockStateGetCharmDownloadInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmDownloadInfoCall) DoAndReturn(f func(context.Context, charm.ID) (*charm0.DownloadInfo, error)) *MockStateGetCharmDownloadInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmID mocks base method.
func (m *MockState) GetCharmID(arg0 context.Context, arg1 string, arg2 int, arg3 charm0.CharmSource) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmID", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmID indicates an expected call of GetCharmID.
func (mr *MockStateMockRecorder) GetCharmID(arg0, arg1, arg2, arg3 any) *MockStateGetCharmIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmID", reflect.TypeOf((*MockState)(nil).GetCharmID), arg0, arg1, arg2, arg3)
	return &MockStateGetCharmIDCall{Call: call}
}

// MockStateGetCharmIDCall wrap *gomock.Call
type MockStateGetCharmIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmIDCall) Return(arg0 charm.ID, arg1 error) *MockStateGetCharmIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmIDCall) Do(f func(context.Context, string, int, charm0.CharmSource) (charm.ID, error)) *MockStateGetCharmIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmIDCall) DoAndReturn(f func(context.Context, string, int, charm0.CharmSource) (charm.ID, error)) *MockStateGetCharmIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmIDByApplicationName mocks base method.
func (m *MockState) GetCharmIDByApplicationName(arg0 context.Context, arg1 string) (charm.ID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmIDByApplicationName", arg0, arg1)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmIDByApplicationName indicates an expected call of GetCharmIDByApplicationName.
func (mr *MockStateMockRecorder) GetCharmIDByApplicationName(arg0, arg1 any) *MockStateGetCharmIDByApplicationNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmIDByApplicationName", reflect.TypeOf((*MockState)(nil).GetCharmIDByApplicationName), arg0, arg1)
	return &MockStateGetCharmIDByApplicationNameCall{Call: call}
}

// MockStateGetCharmIDByApplicationNameCall wrap *gomock.Call
type MockStateGetCharmIDByApplicationNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmIDByApplicationNameCall) Return(arg0 charm.ID, arg1 error) *MockStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmIDByApplicationNameCall) Do(f func(context.Context, string) (charm.ID, error)) *MockStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmIDByApplicationNameCall) DoAndReturn(f func(context.Context, string) (charm.ID, error)) *MockStateGetCharmIDByApplicationNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmLXDProfile mocks base method.
func (m *MockState) GetCharmLXDProfile(arg0 context.Context, arg1 charm.ID) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmLXDProfile", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCharmLXDProfile indicates an expected call of GetCharmLXDProfile.
func (mr *MockStateMockRecorder) GetCharmLXDProfile(arg0, arg1 any) *MockStateGetCharmLXDProfileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmLXDProfile", reflect.TypeOf((*MockState)(nil).GetCharmLXDProfile), arg0, arg1)
	return &MockStateGetCharmLXDProfileCall{Call: call}
}

// MockStateGetCharmLXDProfileCall wrap *gomock.Call
type MockStateGetCharmLXDProfileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmLXDProfileCall) Return(arg0 []byte, arg1 int, arg2 error) *MockStateGetCharmLXDProfileCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmLXDProfileCall) Do(f func(context.Context, charm.ID) ([]byte, int, error)) *MockStateGetCharmLXDProfileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmLXDProfileCall) DoAndReturn(f func(context.Context, charm.ID) ([]byte, int, error)) *MockStateGetCharmLXDProfileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmLocatorByCharmID mocks base method.
func (m *MockState) GetCharmLocatorByCharmID(arg0 context.Context, arg1 charm.ID) (charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmLocatorByCharmID", arg0, arg1)
	ret0, _ := ret[0].(charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmLocatorByCharmID indicates an expected call of GetCharmLocatorByCharmID.
func (mr *MockStateMockRecorder) GetCharmLocatorByCharmID(arg0, arg1 any) *MockStateGetCharmLocatorByCharmIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmLocatorByCharmID", reflect.TypeOf((*MockState)(nil).GetCharmLocatorByCharmID), arg0, arg1)
	return &MockStateGetCharmLocatorByCharmIDCall{Call: call}
}

// MockStateGetCharmLocatorByCharmIDCall wrap *gomock.Call
type MockStateGetCharmLocatorByCharmIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmLocatorByCharmIDCall) Return(arg0 charm0.CharmLocator, arg1 error) *MockStateGetCharmLocatorByCharmIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmLocatorByCharmIDCall) Do(f func(context.Context, charm.ID) (charm0.CharmLocator, error)) *MockStateGetCharmLocatorByCharmIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmLocatorByCharmIDCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.CharmLocator, error)) *MockStateGetCharmLocatorByCharmIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmManifest mocks base method.
func (m *MockState) GetCharmManifest(arg0 context.Context, arg1 charm.ID) (charm0.Manifest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmManifest", arg0, arg1)
	ret0, _ := ret[0].(charm0.Manifest)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmManifest indicates an expected call of GetCharmManifest.
func (mr *MockStateMockRecorder) GetCharmManifest(arg0, arg1 any) *MockStateGetCharmManifestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmManifest", reflect.TypeOf((*MockState)(nil).GetCharmManifest), arg0, arg1)
	return &MockStateGetCharmManifestCall{Call: call}
}

// MockStateGetCharmManifestCall wrap *gomock.Call
type MockStateGetCharmManifestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmManifestCall) Return(arg0 charm0.Manifest, arg1 error) *MockStateGetCharmManifestCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmManifestCall) Do(f func(context.Context, charm.ID) (charm0.Manifest, error)) *MockStateGetCharmManifestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmManifestCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Manifest, error)) *MockStateGetCharmManifestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadata mocks base method.
func (m *MockState) GetCharmMetadata(arg0 context.Context, arg1 charm.ID) (charm0.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadata", arg0, arg1)
	ret0, _ := ret[0].(charm0.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadata indicates an expected call of GetCharmMetadata.
func (mr *MockStateMockRecorder) GetCharmMetadata(arg0, arg1 any) *MockStateGetCharmMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadata", reflect.TypeOf((*MockState)(nil).GetCharmMetadata), arg0, arg1)
	return &MockStateGetCharmMetadataCall{Call: call}
}

// MockStateGetCharmMetadataCall wrap *gomock.Call
type MockStateGetCharmMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataCall) Return(arg0 charm0.Metadata, arg1 error) *MockStateGetCharmMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataCall) Do(f func(context.Context, charm.ID) (charm0.Metadata, error)) *MockStateGetCharmMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataCall) DoAndReturn(f func(context.Context, charm.ID) (charm0.Metadata, error)) *MockStateGetCharmMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataDescription mocks base method.
func (m *MockState) GetCharmMetadataDescription(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataDescription", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataDescription indicates an expected call of GetCharmMetadataDescription.
func (mr *MockStateMockRecorder) GetCharmMetadataDescription(arg0, arg1 any) *MockStateGetCharmMetadataDescriptionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataDescription", reflect.TypeOf((*MockState)(nil).GetCharmMetadataDescription), arg0, arg1)
	return &MockStateGetCharmMetadataDescriptionCall{Call: call}
}

// MockStateGetCharmMetadataDescriptionCall wrap *gomock.Call
type MockStateGetCharmMetadataDescriptionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataDescriptionCall) Return(arg0 string, arg1 error) *MockStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataDescriptionCall) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataDescriptionCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataDescriptionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataName mocks base method.
func (m *MockState) GetCharmMetadataName(arg0 context.Context, arg1 charm.ID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataName", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataName indicates an expected call of GetCharmMetadataName.
func (mr *MockStateMockRecorder) GetCharmMetadataName(arg0, arg1 any) *MockStateGetCharmMetadataNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataName", reflect.TypeOf((*MockState)(nil).GetCharmMetadataName), arg0, arg1)
	return &MockStateGetCharmMetadataNameCall{Call: call}
}

// MockStateGetCharmMetadataNameCall wrap *gomock.Call
type MockStateGetCharmMetadataNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataNameCall) Return(arg0 string, arg1 error) *MockStateGetCharmMetadataNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataNameCall) Do(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataNameCall) DoAndReturn(f func(context.Context, charm.ID) (string, error)) *MockStateGetCharmMetadataNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataResources mocks base method.
func (m *MockState) GetCharmMetadataResources(arg0 context.Context, arg1 charm.ID) (map[string]charm0.Resource, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataResources", arg0, arg1)
	ret0, _ := ret[0].(map[string]charm0.Resource)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataResources indicates an expected call of GetCharmMetadataResources.
func (mr *MockStateMockRecorder) GetCharmMetadataResources(arg0, arg1 any) *MockStateGetCharmMetadataResourcesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataResources", reflect.TypeOf((*MockState)(nil).GetCharmMetadataResources), arg0, arg1)
	return &MockStateGetCharmMetadataResourcesCall{Call: call}
}

// MockStateGetCharmMetadataResourcesCall wrap *gomock.Call
type MockStateGetCharmMetadataResourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataResourcesCall) Return(arg0 map[string]charm0.Resource, arg1 error) *MockStateGetCharmMetadataResourcesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataResourcesCall) Do(f func(context.Context, charm.ID) (map[string]charm0.Resource, error)) *MockStateGetCharmMetadataResourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataResourcesCall) DoAndReturn(f func(context.Context, charm.ID) (map[string]charm0.Resource, error)) *MockStateGetCharmMetadataResourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmMetadataStorage mocks base method.
func (m *MockState) GetCharmMetadataStorage(arg0 context.Context, arg1 charm.ID) (map[string]charm0.Storage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmMetadataStorage", arg0, arg1)
	ret0, _ := ret[0].(map[string]charm0.Storage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmMetadataStorage indicates an expected call of GetCharmMetadataStorage.
func (mr *MockStateMockRecorder) GetCharmMetadataStorage(arg0, arg1 any) *MockStateGetCharmMetadataStorageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmMetadataStorage", reflect.TypeOf((*MockState)(nil).GetCharmMetadataStorage), arg0, arg1)
	return &MockStateGetCharmMetadataStorageCall{Call: call}
}

// MockStateGetCharmMetadataStorageCall wrap *gomock.Call
type MockStateGetCharmMetadataStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmMetadataStorageCall) Return(arg0 map[string]charm0.Storage, arg1 error) *MockStateGetCharmMetadataStorageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmMetadataStorageCall) Do(f func(context.Context, charm.ID) (map[string]charm0.Storage, error)) *MockStateGetCharmMetadataStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmMetadataStorageCall) DoAndReturn(f func(context.Context, charm.ID) (map[string]charm0.Storage, error)) *MockStateGetCharmMetadataStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCharmModifiedVersion mocks base method.
func (m *MockState) GetCharmModifiedVersion(arg0 context.Context, arg1 application.ID) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCharmModifiedVersion", arg0, arg1)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCharmModifiedVersion indicates an expected call of GetCharmModifiedVersion.
func (mr *MockStateMockRecorder) GetCharmModifiedVersion(arg0, arg1 any) *MockStateGetCharmModifiedVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCharmModifiedVersion", reflect.TypeOf((*MockState)(nil).GetCharmModifiedVersion), arg0, arg1)
	return &MockStateGetCharmModifiedVersionCall{Call: call}
}

// MockStateGetCharmModifiedVersionCall wrap *gomock.Call
type MockStateGetCharmModifiedVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetCharmModifiedVersionCall) Return(arg0 int, arg1 error) *MockStateGetCharmModifiedVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetCharmModifiedVersionCall) Do(f func(context.Context, application.ID) (int, error)) *MockStateGetCharmModifiedVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetCharmModifiedVersionCall) DoAndReturn(f func(context.Context, application.ID) (int, error)) *MockStateGetCharmModifiedVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLatestPendingCharmhubCharm mocks base method.
func (m *MockState) GetLatestPendingCharmhubCharm(arg0 context.Context, arg1 string, arg2 architecture.Architecture) (charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestPendingCharmhubCharm", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestPendingCharmhubCharm indicates an expected call of GetLatestPendingCharmhubCharm.
func (mr *MockStateMockRecorder) GetLatestPendingCharmhubCharm(arg0, arg1, arg2 any) *MockStateGetLatestPendingCharmhubCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestPendingCharmhubCharm", reflect.TypeOf((*MockState)(nil).GetLatestPendingCharmhubCharm), arg0, arg1, arg2)
	return &MockStateGetLatestPendingCharmhubCharmCall{Call: call}
}

// MockStateGetLatestPendingCharmhubCharmCall wrap *gomock.Call
type MockStateGetLatestPendingCharmhubCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetLatestPendingCharmhubCharmCall) Return(arg0 charm0.CharmLocator, arg1 error) *MockStateGetLatestPendingCharmhubCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetLatestPendingCharmhubCharmCall) Do(f func(context.Context, string, architecture.Architecture) (charm0.CharmLocator, error)) *MockStateGetLatestPendingCharmhubCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetLatestPendingCharmhubCharmCall) DoAndReturn(f func(context.Context, string, architecture.Architecture) (charm0.CharmLocator, error)) *MockStateGetLatestPendingCharmhubCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetModelType mocks base method.
func (m *MockState) GetModelType(arg0 context.Context) (model.ModelType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModelType", arg0)
	ret0, _ := ret[0].(model.ModelType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModelType indicates an expected call of GetModelType.
func (mr *MockStateMockRecorder) GetModelType(arg0 any) *MockStateGetModelTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelType", reflect.TypeOf((*MockState)(nil).GetModelType), arg0)
	return &MockStateGetModelTypeCall{Call: call}
}

// MockStateGetModelTypeCall wrap *gomock.Call
type MockStateGetModelTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetModelTypeCall) Return(arg0 model.ModelType, arg1 error) *MockStateGetModelTypeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetModelTypeCall) Do(f func(context.Context) (model.ModelType, error)) *MockStateGetModelTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetModelTypeCall) DoAndReturn(f func(context.Context) (model.ModelType, error)) *MockStateGetModelTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStoragePoolByName mocks base method.
func (m *MockState) GetStoragePoolByName(arg0 context.Context, arg1 string) (storage.StoragePoolDetails, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoragePoolByName", arg0, arg1)
	ret0, _ := ret[0].(storage.StoragePoolDetails)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStoragePoolByName indicates an expected call of GetStoragePoolByName.
func (mr *MockStateMockRecorder) GetStoragePoolByName(arg0, arg1 any) *MockStateGetStoragePoolByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoragePoolByName", reflect.TypeOf((*MockState)(nil).GetStoragePoolByName), arg0, arg1)
	return &MockStateGetStoragePoolByNameCall{Call: call}
}

// MockStateGetStoragePoolByNameCall wrap *gomock.Call
type MockStateGetStoragePoolByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetStoragePoolByNameCall) Return(arg0 storage.StoragePoolDetails, arg1 error) *MockStateGetStoragePoolByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetStoragePoolByNameCall) Do(f func(context.Context, string) (storage.StoragePoolDetails, error)) *MockStateGetStoragePoolByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetStoragePoolByNameCall) DoAndReturn(f func(context.Context, string) (storage.StoragePoolDetails, error)) *MockStateGetStoragePoolByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitLife mocks base method.
func (m *MockState) GetUnitLife(arg0 context.Context, arg1 unit.Name) (life.Life, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitLife", arg0, arg1)
	ret0, _ := ret[0].(life.Life)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitLife indicates an expected call of GetUnitLife.
func (mr *MockStateMockRecorder) GetUnitLife(arg0, arg1 any) *MockStateGetUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitLife", reflect.TypeOf((*MockState)(nil).GetUnitLife), arg0, arg1)
	return &MockStateGetUnitLifeCall{Call: call}
}

// MockStateGetUnitLifeCall wrap *gomock.Call
type MockStateGetUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitLifeCall) Return(arg0 life.Life, arg1 error) *MockStateGetUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitLifeCall) Do(f func(context.Context, unit.Name) (life.Life, error)) *MockStateGetUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitLifeCall) DoAndReturn(f func(context.Context, unit.Name) (life.Life, error)) *MockStateGetUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUnitUUIDByName mocks base method.
func (m *MockState) GetUnitUUIDByName(arg0 context.Context, arg1 unit.Name) (unit.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnitUUIDByName", arg0, arg1)
	ret0, _ := ret[0].(unit.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnitUUIDByName indicates an expected call of GetUnitUUIDByName.
func (mr *MockStateMockRecorder) GetUnitUUIDByName(arg0, arg1 any) *MockStateGetUnitUUIDByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnitUUIDByName", reflect.TypeOf((*MockState)(nil).GetUnitUUIDByName), arg0, arg1)
	return &MockStateGetUnitUUIDByNameCall{Call: call}
}

// MockStateGetUnitUUIDByNameCall wrap *gomock.Call
type MockStateGetUnitUUIDByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateGetUnitUUIDByNameCall) Return(arg0 unit.UUID, arg1 error) *MockStateGetUnitUUIDByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateGetUnitUUIDByNameCall) Do(f func(context.Context, unit.Name) (unit.UUID, error)) *MockStateGetUnitUUIDByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateGetUnitUUIDByNameCall) DoAndReturn(f func(context.Context, unit.Name) (unit.UUID, error)) *MockStateGetUnitUUIDByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementApplicationConfigHash mocks base method.
func (m *MockState) InitialWatchStatementApplicationConfigHash(arg0 string) (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementApplicationConfigHash", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementApplicationConfigHash indicates an expected call of InitialWatchStatementApplicationConfigHash.
func (mr *MockStateMockRecorder) InitialWatchStatementApplicationConfigHash(arg0 any) *MockStateInitialWatchStatementApplicationConfigHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementApplicationConfigHash", reflect.TypeOf((*MockState)(nil).InitialWatchStatementApplicationConfigHash), arg0)
	return &MockStateInitialWatchStatementApplicationConfigHashCall{Call: call}
}

// MockStateInitialWatchStatementApplicationConfigHashCall wrap *gomock.Call
type MockStateInitialWatchStatementApplicationConfigHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementApplicationConfigHashCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementApplicationConfigHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementApplicationConfigHashCall) Do(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationConfigHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementApplicationConfigHashCall) DoAndReturn(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationConfigHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementApplicationsWithPendingCharms mocks base method.
func (m *MockState) InitialWatchStatementApplicationsWithPendingCharms() (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementApplicationsWithPendingCharms")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementApplicationsWithPendingCharms indicates an expected call of InitialWatchStatementApplicationsWithPendingCharms.
func (mr *MockStateMockRecorder) InitialWatchStatementApplicationsWithPendingCharms() *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementApplicationsWithPendingCharms", reflect.TypeOf((*MockState)(nil).InitialWatchStatementApplicationsWithPendingCharms))
	return &MockStateInitialWatchStatementApplicationsWithPendingCharmsCall{Call: call}
}

// MockStateInitialWatchStatementApplicationsWithPendingCharmsCall wrap *gomock.Call
type MockStateInitialWatchStatementApplicationsWithPendingCharmsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall) Do(f func() (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall) DoAndReturn(f func() (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementApplicationsWithPendingCharmsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InitialWatchStatementUnitLife mocks base method.
func (m *MockState) InitialWatchStatementUnitLife(arg0 string) (string, eventsource.NamespaceQuery) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InitialWatchStatementUnitLife", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(eventsource.NamespaceQuery)
	return ret0, ret1
}

// InitialWatchStatementUnitLife indicates an expected call of InitialWatchStatementUnitLife.
func (mr *MockStateMockRecorder) InitialWatchStatementUnitLife(arg0 any) *MockStateInitialWatchStatementUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InitialWatchStatementUnitLife", reflect.TypeOf((*MockState)(nil).InitialWatchStatementUnitLife), arg0)
	return &MockStateInitialWatchStatementUnitLifeCall{Call: call}
}

// MockStateInitialWatchStatementUnitLifeCall wrap *gomock.Call
type MockStateInitialWatchStatementUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInitialWatchStatementUnitLifeCall) Return(arg0 string, arg1 eventsource.NamespaceQuery) *MockStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInitialWatchStatementUnitLifeCall) Do(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInitialWatchStatementUnitLifeCall) DoAndReturn(f func(string) (string, eventsource.NamespaceQuery)) *MockStateInitialWatchStatementUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertCAASUnit mocks base method.
func (m *MockState) InsertCAASUnit(arg0 context.Context, arg1 application.ID, arg2 application0.RegisterCAASUnitArg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertCAASUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertCAASUnit indicates an expected call of InsertCAASUnit.
func (mr *MockStateMockRecorder) InsertCAASUnit(arg0, arg1, arg2 any) *MockStateInsertCAASUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertCAASUnit", reflect.TypeOf((*MockState)(nil).InsertCAASUnit), arg0, arg1, arg2)
	return &MockStateInsertCAASUnitCall{Call: call}
}

// MockStateInsertCAASUnitCall wrap *gomock.Call
type MockStateInsertCAASUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInsertCAASUnitCall) Return(arg0 error) *MockStateInsertCAASUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInsertCAASUnitCall) Do(f func(context.Context, application.ID, application0.RegisterCAASUnitArg) error) *MockStateInsertCAASUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInsertCAASUnitCall) DoAndReturn(f func(context.Context, application.ID, application0.RegisterCAASUnitArg) error) *MockStateInsertCAASUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertUnit mocks base method.
func (m *MockState) InsertUnit(arg0 context.Context, arg1 application.ID, arg2 application0.InsertUnitArg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertUnit indicates an expected call of InsertUnit.
func (mr *MockStateMockRecorder) InsertUnit(arg0, arg1, arg2 any) *MockStateInsertUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertUnit", reflect.TypeOf((*MockState)(nil).InsertUnit), arg0, arg1, arg2)
	return &MockStateInsertUnitCall{Call: call}
}

// MockStateInsertUnitCall wrap *gomock.Call
type MockStateInsertUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateInsertUnitCall) Return(arg0 error) *MockStateInsertUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateInsertUnitCall) Do(f func(context.Context, application.ID, application0.InsertUnitArg) error) *MockStateInsertUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateInsertUnitCall) DoAndReturn(f func(context.Context, application.ID, application0.InsertUnitArg) error) *MockStateInsertUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsCharmAvailable mocks base method.
func (m *MockState) IsCharmAvailable(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCharmAvailable", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCharmAvailable indicates an expected call of IsCharmAvailable.
func (mr *MockStateMockRecorder) IsCharmAvailable(arg0, arg1 any) *MockStateIsCharmAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCharmAvailable", reflect.TypeOf((*MockState)(nil).IsCharmAvailable), arg0, arg1)
	return &MockStateIsCharmAvailableCall{Call: call}
}

// MockStateIsCharmAvailableCall wrap *gomock.Call
type MockStateIsCharmAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsCharmAvailableCall) Return(arg0 bool, arg1 error) *MockStateIsCharmAvailableCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsCharmAvailableCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateIsCharmAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsCharmAvailableCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateIsCharmAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsControllerCharm mocks base method.
func (m *MockState) IsControllerCharm(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsControllerCharm", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsControllerCharm indicates an expected call of IsControllerCharm.
func (mr *MockStateMockRecorder) IsControllerCharm(arg0, arg1 any) *MockStateIsControllerCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsControllerCharm", reflect.TypeOf((*MockState)(nil).IsControllerCharm), arg0, arg1)
	return &MockStateIsControllerCharmCall{Call: call}
}

// MockStateIsControllerCharmCall wrap *gomock.Call
type MockStateIsControllerCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsControllerCharmCall) Return(arg0 bool, arg1 error) *MockStateIsControllerCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsControllerCharmCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateIsControllerCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsControllerCharmCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateIsControllerCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsSubordinateCharm mocks base method.
func (m *MockState) IsSubordinateCharm(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSubordinateCharm", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsSubordinateCharm indicates an expected call of IsSubordinateCharm.
func (mr *MockStateMockRecorder) IsSubordinateCharm(arg0, arg1 any) *MockStateIsSubordinateCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSubordinateCharm", reflect.TypeOf((*MockState)(nil).IsSubordinateCharm), arg0, arg1)
	return &MockStateIsSubordinateCharmCall{Call: call}
}

// MockStateIsSubordinateCharmCall wrap *gomock.Call
type MockStateIsSubordinateCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateIsSubordinateCharmCall) Return(arg0 bool, arg1 error) *MockStateIsSubordinateCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateIsSubordinateCharmCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateIsSubordinateCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateIsSubordinateCharmCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateIsSubordinateCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCharmLocators mocks base method.
func (m *MockState) ListCharmLocators(arg0 context.Context) ([]charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharmLocators", arg0)
	ret0, _ := ret[0].([]charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharmLocators indicates an expected call of ListCharmLocators.
func (mr *MockStateMockRecorder) ListCharmLocators(arg0 any) *MockStateListCharmLocatorsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharmLocators", reflect.TypeOf((*MockState)(nil).ListCharmLocators), arg0)
	return &MockStateListCharmLocatorsCall{Call: call}
}

// MockStateListCharmLocatorsCall wrap *gomock.Call
type MockStateListCharmLocatorsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateListCharmLocatorsCall) Return(arg0 []charm0.CharmLocator, arg1 error) *MockStateListCharmLocatorsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateListCharmLocatorsCall) Do(f func(context.Context) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateListCharmLocatorsCall) DoAndReturn(f func(context.Context) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCharmLocatorsByNames mocks base method.
func (m *MockState) ListCharmLocatorsByNames(arg0 context.Context, arg1 []string) ([]charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharmLocatorsByNames", arg0, arg1)
	ret0, _ := ret[0].([]charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharmLocatorsByNames indicates an expected call of ListCharmLocatorsByNames.
func (mr *MockStateMockRecorder) ListCharmLocatorsByNames(arg0, arg1 any) *MockStateListCharmLocatorsByNamesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharmLocatorsByNames", reflect.TypeOf((*MockState)(nil).ListCharmLocatorsByNames), arg0, arg1)
	return &MockStateListCharmLocatorsByNamesCall{Call: call}
}

// MockStateListCharmLocatorsByNamesCall wrap *gomock.Call
type MockStateListCharmLocatorsByNamesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateListCharmLocatorsByNamesCall) Return(arg0 []charm0.CharmLocator, arg1 error) *MockStateListCharmLocatorsByNamesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateListCharmLocatorsByNamesCall) Do(f func(context.Context, []string) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsByNamesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateListCharmLocatorsByNamesCall) DoAndReturn(f func(context.Context, []string) ([]charm0.CharmLocator, error)) *MockStateListCharmLocatorsByNamesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveCharmDownload mocks base method.
func (m *MockState) ResolveCharmDownload(arg0 context.Context, arg1 charm.ID, arg2 application0.ResolvedCharmDownload) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveCharmDownload", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResolveCharmDownload indicates an expected call of ResolveCharmDownload.
func (mr *MockStateMockRecorder) ResolveCharmDownload(arg0, arg1, arg2 any) *MockStateResolveCharmDownloadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveCharmDownload", reflect.TypeOf((*MockState)(nil).ResolveCharmDownload), arg0, arg1, arg2)
	return &MockStateResolveCharmDownloadCall{Call: call}
}

// MockStateResolveCharmDownloadCall wrap *gomock.Call
type MockStateResolveCharmDownloadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateResolveCharmDownloadCall) Return(arg0 error) *MockStateResolveCharmDownloadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateResolveCharmDownloadCall) Do(f func(context.Context, charm.ID, application0.ResolvedCharmDownload) error) *MockStateResolveCharmDownloadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateResolveCharmDownloadCall) DoAndReturn(f func(context.Context, charm.ID, application0.ResolvedCharmDownload) error) *MockStateResolveCharmDownloadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveMigratingUploadedCharm mocks base method.
func (m *MockState) ResolveMigratingUploadedCharm(arg0 context.Context, arg1 charm.ID, arg2 charm0.ResolvedMigratingUploadedCharm) (charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveMigratingUploadedCharm", arg0, arg1, arg2)
	ret0, _ := ret[0].(charm0.CharmLocator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveMigratingUploadedCharm indicates an expected call of ResolveMigratingUploadedCharm.
func (mr *MockStateMockRecorder) ResolveMigratingUploadedCharm(arg0, arg1, arg2 any) *MockStateResolveMigratingUploadedCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveMigratingUploadedCharm", reflect.TypeOf((*MockState)(nil).ResolveMigratingUploadedCharm), arg0, arg1, arg2)
	return &MockStateResolveMigratingUploadedCharmCall{Call: call}
}

// MockStateResolveMigratingUploadedCharmCall wrap *gomock.Call
type MockStateResolveMigratingUploadedCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateResolveMigratingUploadedCharmCall) Return(arg0 charm0.CharmLocator, arg1 error) *MockStateResolveMigratingUploadedCharmCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateResolveMigratingUploadedCharmCall) Do(f func(context.Context, charm.ID, charm0.ResolvedMigratingUploadedCharm) (charm0.CharmLocator, error)) *MockStateResolveMigratingUploadedCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateResolveMigratingUploadedCharmCall) DoAndReturn(f func(context.Context, charm.ID, charm0.ResolvedMigratingUploadedCharm) (charm0.CharmLocator, error)) *MockStateResolveMigratingUploadedCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationConfigAndSettings mocks base method.
func (m *MockState) SetApplicationConfigAndSettings(arg0 context.Context, arg1 application.ID, arg2 charm.ID, arg3 map[string]application0.ApplicationConfig, arg4 application0.ApplicationSettings) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationConfigAndSettings", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationConfigAndSettings indicates an expected call of SetApplicationConfigAndSettings.
func (mr *MockStateMockRecorder) SetApplicationConfigAndSettings(arg0, arg1, arg2, arg3, arg4 any) *MockStateSetApplicationConfigAndSettingsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationConfigAndSettings", reflect.TypeOf((*MockState)(nil).SetApplicationConfigAndSettings), arg0, arg1, arg2, arg3, arg4)
	return &MockStateSetApplicationConfigAndSettingsCall{Call: call}
}

// MockStateSetApplicationConfigAndSettingsCall wrap *gomock.Call
type MockStateSetApplicationConfigAndSettingsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetApplicationConfigAndSettingsCall) Return(arg0 error) *MockStateSetApplicationConfigAndSettingsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetApplicationConfigAndSettingsCall) Do(f func(context.Context, application.ID, charm.ID, map[string]application0.ApplicationConfig, application0.ApplicationSettings) error) *MockStateSetApplicationConfigAndSettingsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetApplicationConfigAndSettingsCall) DoAndReturn(f func(context.Context, application.ID, charm.ID, map[string]application0.ApplicationConfig, application0.ApplicationSettings) error) *MockStateSetApplicationConfigAndSettingsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationLife mocks base method.
func (m *MockState) SetApplicationLife(arg0 context.Context, arg1 application.ID, arg2 life.Life) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationLife", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationLife indicates an expected call of SetApplicationLife.
func (mr *MockStateMockRecorder) SetApplicationLife(arg0, arg1, arg2 any) *MockStateSetApplicationLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationLife", reflect.TypeOf((*MockState)(nil).SetApplicationLife), arg0, arg1, arg2)
	return &MockStateSetApplicationLifeCall{Call: call}
}

// MockStateSetApplicationLifeCall wrap *gomock.Call
type MockStateSetApplicationLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetApplicationLifeCall) Return(arg0 error) *MockStateSetApplicationLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetApplicationLifeCall) Do(f func(context.Context, application.ID, life.Life) error) *MockStateSetApplicationLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetApplicationLifeCall) DoAndReturn(f func(context.Context, application.ID, life.Life) error) *MockStateSetApplicationLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetApplicationScalingState mocks base method.
func (m *MockState) SetApplicationScalingState(arg0 context.Context, arg1 application.ID, arg2 *int, arg3 int, arg4 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetApplicationScalingState", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetApplicationScalingState indicates an expected call of SetApplicationScalingState.
func (mr *MockStateMockRecorder) SetApplicationScalingState(arg0, arg1, arg2, arg3, arg4 any) *MockStateSetApplicationScalingStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetApplicationScalingState", reflect.TypeOf((*MockState)(nil).SetApplicationScalingState), arg0, arg1, arg2, arg3, arg4)
	return &MockStateSetApplicationScalingStateCall{Call: call}
}

// MockStateSetApplicationScalingStateCall wrap *gomock.Call
type MockStateSetApplicationScalingStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetApplicationScalingStateCall) Return(arg0 error) *MockStateSetApplicationScalingStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetApplicationScalingStateCall) Do(f func(context.Context, application.ID, *int, int, bool) error) *MockStateSetApplicationScalingStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetApplicationScalingStateCall) DoAndReturn(f func(context.Context, application.ID, *int, int, bool) error) *MockStateSetApplicationScalingStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharm mocks base method.
func (m *MockState) SetCharm(arg0 context.Context, arg1 charm0.Charm, arg2 *charm0.DownloadInfo, arg3 bool) (charm.ID, charm0.CharmLocator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharm", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(charm.ID)
	ret1, _ := ret[1].(charm0.CharmLocator)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SetCharm indicates an expected call of SetCharm.
func (mr *MockStateMockRecorder) SetCharm(arg0, arg1, arg2, arg3 any) *MockStateSetCharmCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharm", reflect.TypeOf((*MockState)(nil).SetCharm), arg0, arg1, arg2, arg3)
	return &MockStateSetCharmCall{Call: call}
}

// MockStateSetCharmCall wrap *gomock.Call
type MockStateSetCharmCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetCharmCall) Return(arg0 charm.ID, arg1 charm0.CharmLocator, arg2 error) *MockStateSetCharmCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetCharmCall) Do(f func(context.Context, charm0.Charm, *charm0.DownloadInfo, bool) (charm.ID, charm0.CharmLocator, error)) *MockStateSetCharmCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetCharmCall) DoAndReturn(f func(context.Context, charm0.Charm, *charm0.DownloadInfo, bool) (charm.ID, charm0.CharmLocator, error)) *MockStateSetCharmCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCharmAvailable mocks base method.
func (m *MockState) SetCharmAvailable(arg0 context.Context, arg1 charm.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCharmAvailable", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCharmAvailable indicates an expected call of SetCharmAvailable.
func (mr *MockStateMockRecorder) SetCharmAvailable(arg0, arg1 any) *MockStateSetCharmAvailableCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCharmAvailable", reflect.TypeOf((*MockState)(nil).SetCharmAvailable), arg0, arg1)
	return &MockStateSetCharmAvailableCall{Call: call}
}

// MockStateSetCharmAvailableCall wrap *gomock.Call
type MockStateSetCharmAvailableCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetCharmAvailableCall) Return(arg0 error) *MockStateSetCharmAvailableCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetCharmAvailableCall) Do(f func(context.Context, charm.ID) error) *MockStateSetCharmAvailableCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetCharmAvailableCall) DoAndReturn(f func(context.Context, charm.ID) error) *MockStateSetCharmAvailableCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetDesiredApplicationScale mocks base method.
func (m *MockState) SetDesiredApplicationScale(arg0 context.Context, arg1 application.ID, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDesiredApplicationScale", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDesiredApplicationScale indicates an expected call of SetDesiredApplicationScale.
func (mr *MockStateMockRecorder) SetDesiredApplicationScale(arg0, arg1, arg2 any) *MockStateSetDesiredApplicationScaleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDesiredApplicationScale", reflect.TypeOf((*MockState)(nil).SetDesiredApplicationScale), arg0, arg1, arg2)
	return &MockStateSetDesiredApplicationScaleCall{Call: call}
}

// MockStateSetDesiredApplicationScaleCall wrap *gomock.Call
type MockStateSetDesiredApplicationScaleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetDesiredApplicationScaleCall) Return(arg0 error) *MockStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetDesiredApplicationScaleCall) Do(f func(context.Context, application.ID, int) error) *MockStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetDesiredApplicationScaleCall) DoAndReturn(f func(context.Context, application.ID, int) error) *MockStateSetDesiredApplicationScaleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitLife mocks base method.
func (m *MockState) SetUnitLife(arg0 context.Context, arg1 unit.Name, arg2 life.Life) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitLife", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitLife indicates an expected call of SetUnitLife.
func (mr *MockStateMockRecorder) SetUnitLife(arg0, arg1, arg2 any) *MockStateSetUnitLifeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitLife", reflect.TypeOf((*MockState)(nil).SetUnitLife), arg0, arg1, arg2)
	return &MockStateSetUnitLifeCall{Call: call}
}

// MockStateSetUnitLifeCall wrap *gomock.Call
type MockStateSetUnitLifeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetUnitLifeCall) Return(arg0 error) *MockStateSetUnitLifeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetUnitLifeCall) Do(f func(context.Context, unit.Name, life.Life) error) *MockStateSetUnitLifeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetUnitLifeCall) DoAndReturn(f func(context.Context, unit.Name, life.Life) error) *MockStateSetUnitLifeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUnitPassword mocks base method.
func (m *MockState) SetUnitPassword(arg0 context.Context, arg1 unit.UUID, arg2 application0.PasswordInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUnitPassword", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetUnitPassword indicates an expected call of SetUnitPassword.
func (mr *MockStateMockRecorder) SetUnitPassword(arg0, arg1, arg2 any) *MockStateSetUnitPasswordCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUnitPassword", reflect.TypeOf((*MockState)(nil).SetUnitPassword), arg0, arg1, arg2)
	return &MockStateSetUnitPasswordCall{Call: call}
}

// MockStateSetUnitPasswordCall wrap *gomock.Call
type MockStateSetUnitPasswordCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSetUnitPasswordCall) Return(arg0 error) *MockStateSetUnitPasswordCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSetUnitPasswordCall) Do(f func(context.Context, unit.UUID, application0.PasswordInfo) error) *MockStateSetUnitPasswordCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSetUnitPasswordCall) DoAndReturn(f func(context.Context, unit.UUID, application0.PasswordInfo) error) *MockStateSetUnitPasswordCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StorageDefaults mocks base method.
func (m *MockState) StorageDefaults(arg0 context.Context) (storage.StorageDefaults, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StorageDefaults", arg0)
	ret0, _ := ret[0].(storage.StorageDefaults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StorageDefaults indicates an expected call of StorageDefaults.
func (mr *MockStateMockRecorder) StorageDefaults(arg0 any) *MockStateStorageDefaultsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageDefaults", reflect.TypeOf((*MockState)(nil).StorageDefaults), arg0)
	return &MockStateStorageDefaultsCall{Call: call}
}

// MockStateStorageDefaultsCall wrap *gomock.Call
type MockStateStorageDefaultsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateStorageDefaultsCall) Return(arg0 storage.StorageDefaults, arg1 error) *MockStateStorageDefaultsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateStorageDefaultsCall) Do(f func(context.Context) (storage.StorageDefaults, error)) *MockStateStorageDefaultsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateStorageDefaultsCall) DoAndReturn(f func(context.Context) (storage.StorageDefaults, error)) *MockStateStorageDefaultsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SupportsContainers mocks base method.
func (m *MockState) SupportsContainers(arg0 context.Context, arg1 charm.ID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportsContainers", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SupportsContainers indicates an expected call of SupportsContainers.
func (mr *MockStateMockRecorder) SupportsContainers(arg0, arg1 any) *MockStateSupportsContainersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportsContainers", reflect.TypeOf((*MockState)(nil).SupportsContainers), arg0, arg1)
	return &MockStateSupportsContainersCall{Call: call}
}

// MockStateSupportsContainersCall wrap *gomock.Call
type MockStateSupportsContainersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateSupportsContainersCall) Return(arg0 bool, arg1 error) *MockStateSupportsContainersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateSupportsContainersCall) Do(f func(context.Context, charm.ID) (bool, error)) *MockStateSupportsContainersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateSupportsContainersCall) DoAndReturn(f func(context.Context, charm.ID) (bool, error)) *MockStateSupportsContainersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsetApplicationConfigKeys mocks base method.
func (m *MockState) UnsetApplicationConfigKeys(arg0 context.Context, arg1 application.ID, arg2 []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnsetApplicationConfigKeys", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnsetApplicationConfigKeys indicates an expected call of UnsetApplicationConfigKeys.
func (mr *MockStateMockRecorder) UnsetApplicationConfigKeys(arg0, arg1, arg2 any) *MockStateUnsetApplicationConfigKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsetApplicationConfigKeys", reflect.TypeOf((*MockState)(nil).UnsetApplicationConfigKeys), arg0, arg1, arg2)
	return &MockStateUnsetApplicationConfigKeysCall{Call: call}
}

// MockStateUnsetApplicationConfigKeysCall wrap *gomock.Call
type MockStateUnsetApplicationConfigKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUnsetApplicationConfigKeysCall) Return(arg0 error) *MockStateUnsetApplicationConfigKeysCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUnsetApplicationConfigKeysCall) Do(f func(context.Context, application.ID, []string) error) *MockStateUnsetApplicationConfigKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUnsetApplicationConfigKeysCall) DoAndReturn(f func(context.Context, application.ID, []string) error) *MockStateUnsetApplicationConfigKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateCAASUnit mocks base method.
func (m *MockState) UpdateCAASUnit(arg0 context.Context, arg1 unit.Name, arg2 application0.UpdateCAASUnitParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateCAASUnit", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateCAASUnit indicates an expected call of UpdateCAASUnit.
func (mr *MockStateMockRecorder) UpdateCAASUnit(arg0, arg1, arg2 any) *MockStateUpdateCAASUnitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCAASUnit", reflect.TypeOf((*MockState)(nil).UpdateCAASUnit), arg0, arg1, arg2)
	return &MockStateUpdateCAASUnitCall{Call: call}
}

// MockStateUpdateCAASUnitCall wrap *gomock.Call
type MockStateUpdateCAASUnitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpdateCAASUnitCall) Return(arg0 error) *MockStateUpdateCAASUnitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpdateCAASUnitCall) Do(f func(context.Context, unit.Name, application0.UpdateCAASUnitParams) error) *MockStateUpdateCAASUnitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpdateCAASUnitCall) DoAndReturn(f func(context.Context, unit.Name, application0.UpdateCAASUnitParams) error) *MockStateUpdateCAASUnitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertCloudService mocks base method.
func (m *MockState) UpsertCloudService(arg0 context.Context, arg1, arg2 string, arg3 network.SpaceAddresses) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertCloudService", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertCloudService indicates an expected call of UpsertCloudService.
func (mr *MockStateMockRecorder) UpsertCloudService(arg0, arg1, arg2, arg3 any) *MockStateUpsertCloudServiceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertCloudService", reflect.TypeOf((*MockState)(nil).UpsertCloudService), arg0, arg1, arg2, arg3)
	return &MockStateUpsertCloudServiceCall{Call: call}
}

// MockStateUpsertCloudServiceCall wrap *gomock.Call
type MockStateUpsertCloudServiceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateUpsertCloudServiceCall) Return(arg0 error) *MockStateUpsertCloudServiceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateUpsertCloudServiceCall) Do(f func(context.Context, string, string, network.SpaceAddresses) error) *MockStateUpsertCloudServiceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateUpsertCloudServiceCall) DoAndReturn(f func(context.Context, string, string, network.SpaceAddresses) error) *MockStateUpsertCloudServiceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockWatcherFactory is a mock of WatcherFactory interface.
type MockWatcherFactory struct {
	ctrl     *gomock.Controller
	recorder *MockWatcherFactoryMockRecorder
}

// MockWatcherFactoryMockRecorder is the mock recorder for MockWatcherFactory.
type MockWatcherFactoryMockRecorder struct {
	mock *MockWatcherFactory
}

// NewMockWatcherFactory creates a new mock instance.
func NewMockWatcherFactory(ctrl *gomock.Controller) *MockWatcherFactory {
	mock := &MockWatcherFactory{ctrl: ctrl}
	mock.recorder = &MockWatcherFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWatcherFactory) EXPECT() *MockWatcherFactoryMockRecorder {
	return m.recorder
}

// NewNamespaceMapperWatcher mocks base method.
func (m *MockWatcherFactory) NewNamespaceMapperWatcher(arg0 string, arg1 changestream.ChangeType, arg2 eventsource.NamespaceQuery, arg3 eventsource.Mapper) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewNamespaceMapperWatcher", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewNamespaceMapperWatcher indicates an expected call of NewNamespaceMapperWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewNamespaceMapperWatcher(arg0, arg1, arg2, arg3 any) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewNamespaceMapperWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewNamespaceMapperWatcher), arg0, arg1, arg2, arg3)
	return &MockWatcherFactoryNewNamespaceMapperWatcherCall{Call: call}
}

// MockWatcherFactoryNewNamespaceMapperWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewNamespaceMapperWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) Do(f func(string, changestream.ChangeType, eventsource.NamespaceQuery, eventsource.Mapper) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewNamespaceMapperWatcherCall) DoAndReturn(f func(string, changestream.ChangeType, eventsource.NamespaceQuery, eventsource.Mapper) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewNamespaceMapperWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewUUIDsWatcher mocks base method.
func (m *MockWatcherFactory) NewUUIDsWatcher(arg0 string, arg1 changestream.ChangeType) (watcher.Watcher[[]string], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewUUIDsWatcher", arg0, arg1)
	ret0, _ := ret[0].(watcher.Watcher[[]string])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewUUIDsWatcher indicates an expected call of NewUUIDsWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewUUIDsWatcher(arg0, arg1 any) *MockWatcherFactoryNewUUIDsWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewUUIDsWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewUUIDsWatcher), arg0, arg1)
	return &MockWatcherFactoryNewUUIDsWatcherCall{Call: call}
}

// MockWatcherFactoryNewUUIDsWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewUUIDsWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewUUIDsWatcherCall) Return(arg0 watcher.Watcher[[]string], arg1 error) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewUUIDsWatcherCall) Do(f func(string, changestream.ChangeType) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewUUIDsWatcherCall) DoAndReturn(f func(string, changestream.ChangeType) (watcher.Watcher[[]string], error)) *MockWatcherFactoryNewUUIDsWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewValueMapperWatcher mocks base method.
func (m *MockWatcherFactory) NewValueMapperWatcher(arg0, arg1 string, arg2 changestream.ChangeType, arg3 eventsource.Mapper) (watcher.Watcher[struct{}], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewValueMapperWatcher", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(watcher.Watcher[struct{}])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewValueMapperWatcher indicates an expected call of NewValueMapperWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewValueMapperWatcher(arg0, arg1, arg2, arg3 any) *MockWatcherFactoryNewValueMapperWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewValueMapperWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewValueMapperWatcher), arg0, arg1, arg2, arg3)
	return &MockWatcherFactoryNewValueMapperWatcherCall{Call: call}
}

// MockWatcherFactoryNewValueMapperWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewValueMapperWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewValueMapperWatcherCall) Return(arg0 watcher.Watcher[struct{}], arg1 error) *MockWatcherFactoryNewValueMapperWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewValueMapperWatcherCall) Do(f func(string, string, changestream.ChangeType, eventsource.Mapper) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewValueMapperWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewValueMapperWatcherCall) DoAndReturn(f func(string, string, changestream.ChangeType, eventsource.Mapper) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewValueMapperWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewValueWatcher mocks base method.
func (m *MockWatcherFactory) NewValueWatcher(arg0, arg1 string, arg2 changestream.ChangeType) (watcher.Watcher[struct{}], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewValueWatcher", arg0, arg1, arg2)
	ret0, _ := ret[0].(watcher.Watcher[struct{}])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewValueWatcher indicates an expected call of NewValueWatcher.
func (mr *MockWatcherFactoryMockRecorder) NewValueWatcher(arg0, arg1, arg2 any) *MockWatcherFactoryNewValueWatcherCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewValueWatcher", reflect.TypeOf((*MockWatcherFactory)(nil).NewValueWatcher), arg0, arg1, arg2)
	return &MockWatcherFactoryNewValueWatcherCall{Call: call}
}

// MockWatcherFactoryNewValueWatcherCall wrap *gomock.Call
type MockWatcherFactoryNewValueWatcherCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWatcherFactoryNewValueWatcherCall) Return(arg0 watcher.Watcher[struct{}], arg1 error) *MockWatcherFactoryNewValueWatcherCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWatcherFactoryNewValueWatcherCall) Do(f func(string, string, changestream.ChangeType) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewValueWatcherCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWatcherFactoryNewValueWatcherCall) DoAndReturn(f func(string, string, changestream.ChangeType) (watcher.Watcher[struct{}], error)) *MockWatcherFactoryNewValueWatcherCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockAgentVersionGetter is a mock of AgentVersionGetter interface.
type MockAgentVersionGetter struct {
	ctrl     *gomock.Controller
	recorder *MockAgentVersionGetterMockRecorder
}

// MockAgentVersionGetterMockRecorder is the mock recorder for MockAgentVersionGetter.
type MockAgentVersionGetterMockRecorder struct {
	mock *MockAgentVersionGetter
}

// NewMockAgentVersionGetter creates a new mock instance.
func NewMockAgentVersionGetter(ctrl *gomock.Controller) *MockAgentVersionGetter {
	mock := &MockAgentVersionGetter{ctrl: ctrl}
	mock.recorder = &MockAgentVersionGetterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAgentVersionGetter) EXPECT() *MockAgentVersionGetterMockRecorder {
	return m.recorder
}

// GetModelTargetAgentVersion mocks base method.
func (m *MockAgentVersionGetter) GetModelTargetAgentVersion(arg0 context.Context, arg1 model.UUID) (version.Number, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModelTargetAgentVersion", arg0, arg1)
	ret0, _ := ret[0].(version.Number)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModelTargetAgentVersion indicates an expected call of GetModelTargetAgentVersion.
func (mr *MockAgentVersionGetterMockRecorder) GetModelTargetAgentVersion(arg0, arg1 any) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelTargetAgentVersion", reflect.TypeOf((*MockAgentVersionGetter)(nil).GetModelTargetAgentVersion), arg0, arg1)
	return &MockAgentVersionGetterGetModelTargetAgentVersionCall{Call: call}
}

// MockAgentVersionGetterGetModelTargetAgentVersionCall wrap *gomock.Call
type MockAgentVersionGetterGetModelTargetAgentVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) Return(arg0 version.Number, arg1 error) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) Do(f func(context.Context, model.UUID) (version.Number, error)) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAgentVersionGetterGetModelTargetAgentVersionCall) DoAndReturn(f func(context.Context, model.UUID) (version.Number, error)) *MockAgentVersionGetterGetModelTargetAgentVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockProvider is a mock of Provider interface.
type MockProvider struct {
	ctrl     *gomock.Controller
	recorder *MockProviderMockRecorder
}

// MockProviderMockRecorder is the mock recorder for MockProvider.
type MockProviderMockRecorder struct {
	mock *MockProvider
}

// NewMockProvider creates a new mock instance.
func NewMockProvider(ctrl *gomock.Controller) *MockProvider {
	mock := &MockProvider{ctrl: ctrl}
	mock.recorder = &MockProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProvider) EXPECT() *MockProviderMockRecorder {
	return m.recorder
}

// SupportedFeatures mocks base method.
func (m *MockProvider) SupportedFeatures() (assumes.FeatureSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportedFeatures")
	ret0, _ := ret[0].(assumes.FeatureSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SupportedFeatures indicates an expected call of SupportedFeatures.
func (mr *MockProviderMockRecorder) SupportedFeatures() *MockProviderSupportedFeaturesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportedFeatures", reflect.TypeOf((*MockProvider)(nil).SupportedFeatures))
	return &MockProviderSupportedFeaturesCall{Call: call}
}

// MockProviderSupportedFeaturesCall wrap *gomock.Call
type MockProviderSupportedFeaturesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProviderSupportedFeaturesCall) Return(arg0 assumes.FeatureSet, arg1 error) *MockProviderSupportedFeaturesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProviderSupportedFeaturesCall) Do(f func() (assumes.FeatureSet, error)) *MockProviderSupportedFeaturesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProviderSupportedFeaturesCall) DoAndReturn(f func() (assumes.FeatureSet, error)) *MockProviderSupportedFeaturesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCharmStore is a mock of CharmStore interface.
type MockCharmStore struct {
	ctrl     *gomock.Controller
	recorder *MockCharmStoreMockRecorder
}

// MockCharmStoreMockRecorder is the mock recorder for MockCharmStore.
type MockCharmStoreMockRecorder struct {
	mock *MockCharmStore
}

// NewMockCharmStore creates a new mock instance.
func NewMockCharmStore(ctrl *gomock.Controller) *MockCharmStore {
	mock := &MockCharmStore{ctrl: ctrl}
	mock.recorder = &MockCharmStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCharmStore) EXPECT() *MockCharmStoreMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockCharmStore) Get(arg0 context.Context, arg1 string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", arg0, arg1)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCharmStoreMockRecorder) Get(arg0, arg1 any) *MockCharmStoreGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCharmStore)(nil).Get), arg0, arg1)
	return &MockCharmStoreGetCall{Call: call}
}

// MockCharmStoreGetCall wrap *gomock.Call
type MockCharmStoreGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreGetCall) Return(arg0 io.ReadCloser, arg1 error) *MockCharmStoreGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreGetCall) Do(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreGetCall) DoAndReturn(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBySHA256Prefix mocks base method.
func (m *MockCharmStore) GetBySHA256Prefix(arg0 context.Context, arg1 string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBySHA256Prefix", arg0, arg1)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBySHA256Prefix indicates an expected call of GetBySHA256Prefix.
func (mr *MockCharmStoreMockRecorder) GetBySHA256Prefix(arg0, arg1 any) *MockCharmStoreGetBySHA256PrefixCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBySHA256Prefix", reflect.TypeOf((*MockCharmStore)(nil).GetBySHA256Prefix), arg0, arg1)
	return &MockCharmStoreGetBySHA256PrefixCall{Call: call}
}

// MockCharmStoreGetBySHA256PrefixCall wrap *gomock.Call
type MockCharmStoreGetBySHA256PrefixCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreGetBySHA256PrefixCall) Return(arg0 io.ReadCloser, arg1 error) *MockCharmStoreGetBySHA256PrefixCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreGetBySHA256PrefixCall) Do(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetBySHA256PrefixCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreGetBySHA256PrefixCall) DoAndReturn(f func(context.Context, string) (io.ReadCloser, error)) *MockCharmStoreGetBySHA256PrefixCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockCharmStore) Store(arg0 context.Context, arg1 string, arg2 int64, arg3 string) (store.StoreResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(store.StoreResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Store indicates an expected call of Store.
func (mr *MockCharmStoreMockRecorder) Store(arg0, arg1, arg2, arg3 any) *MockCharmStoreStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockCharmStore)(nil).Store), arg0, arg1, arg2, arg3)
	return &MockCharmStoreStoreCall{Call: call}
}

// MockCharmStoreStoreCall wrap *gomock.Call
type MockCharmStoreStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreStoreCall) Return(arg0 store.StoreResult, arg1 error) *MockCharmStoreStoreCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreStoreCall) Do(f func(context.Context, string, int64, string) (store.StoreResult, error)) *MockCharmStoreStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreStoreCall) DoAndReturn(f func(context.Context, string, int64, string) (store.StoreResult, error)) *MockCharmStoreStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreFromReader mocks base method.
func (m *MockCharmStore) StoreFromReader(arg0 context.Context, arg1 io.Reader, arg2 string) (store.StoreFromReaderResult, store.Digest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreFromReader", arg0, arg1, arg2)
	ret0, _ := ret[0].(store.StoreFromReaderResult)
	ret1, _ := ret[1].(store.Digest)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// StoreFromReader indicates an expected call of StoreFromReader.
func (mr *MockCharmStoreMockRecorder) StoreFromReader(arg0, arg1, arg2 any) *MockCharmStoreStoreFromReaderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreFromReader", reflect.TypeOf((*MockCharmStore)(nil).StoreFromReader), arg0, arg1, arg2)
	return &MockCharmStoreStoreFromReaderCall{Call: call}
}

// MockCharmStoreStoreFromReaderCall wrap *gomock.Call
type MockCharmStoreStoreFromReaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCharmStoreStoreFromReaderCall) Return(arg0 store.StoreFromReaderResult, arg1 store.Digest, arg2 error) *MockCharmStoreStoreFromReaderCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCharmStoreStoreFromReaderCall) Do(f func(context.Context, io.Reader, string) (store.StoreFromReaderResult, store.Digest, error)) *MockCharmStoreStoreFromReaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCharmStoreStoreFromReaderCall) DoAndReturn(f func(context.Context, io.Reader, string) (store.StoreFromReaderResult, store.Digest, error)) *MockCharmStoreStoreFromReaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

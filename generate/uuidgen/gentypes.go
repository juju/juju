// Copyright 2025 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package main

import (
	"fmt"
	"os"
	"text/template"
)

// UUIDType represents metadata for generating UUID types in the context of
// file generation.
type UUIDType struct {
	TypeName    string
	Description string
}

// FileParams represents metadata for generating the file.
type FileParams struct {
	Package string
	Types   []UUIDType
}

// Template for the generated file header.
const fileHeaderTemplate = `// Code generated by generate/uuidgen; DO NOT EDIT.
// Copyright 2025 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package {{.Package}}

import (
	coreerrors "github.com/juju/juju/core/errors"
	"github.com/juju/juju/internal/errors"
	"github.com/juju/juju/internal/uuid"
)
`

// Template for the generated file types.
const uuidTypeTemplate = `
// {{.TypeName}} represents a {{.Description}} unique identifier.
type {{.TypeName}} string

// New{{.TypeName}} is a convenience function for generating a new {{.Description}} uuid.
func New{{.TypeName}}() ({{.TypeName}}, error) {
	uuid, err := uuid.NewUUID()
	if err != nil {
		return {{.TypeName}}(""), err
	}
	return {{.TypeName}}(uuid.String()), nil
}

// Parse{{.TypeName}} returns a new {{.TypeName}} from the given string. If the string is not a
// valid uuid an error satisfying [errors.NotValid] will be returned.
func Parse{{.TypeName}}(value string) ({{.TypeName}}, error) {
	if !uuid.IsValidUUIDString(value) {
		return "", errors.Errorf("parsing {{.Description}} uuid %q: %w", value, coreerrors.NotValid)
	}
	return {{.TypeName}}(value), nil
}

// String implements the stringer interface for {{.TypeName}}.
func (u {{.TypeName}}) String() string {
	return string(u)
}

// Validate ensures the consistency of the {{.TypeName}}. If the uuid is invalid an error
// satisfying [errors.NotValid] will be returned.
func (u {{.TypeName}}) Validate() error {
	if u == "" {
		return errors.Errorf("{{.Description}} uuid cannot be empty").Add(coreerrors.NotValid)
	}
	if !uuid.IsValidUUIDString(string(u)) {
		return errors.Errorf("{{.Description}} uuid %q: %w", u, coreerrors.NotValid)
	}
	return nil
}
`

// generateTypeFile generates a file for UUID types based on the provided
// parameters and writes it to disk.
// Arguments:
//   - outputFile: The path where the generated file will be created.
//   - params: Contains the package information and a list of UUID types with
//     their names and descriptions.
//
// Note: The generated file will be created with the directory of generate
// command as root.
func generateTypeFile(outputFile string, params FileParams) {
	// Create the output file
	file, err := os.Create(outputFile)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	// Write the file header
	headerTmpl, err := template.New("header").Parse(fileHeaderTemplate)
	if err != nil {
		fmt.Printf("Error parsing header template: %v\n", err)
		os.Exit(1)
	}

	if err := headerTmpl.Execute(file, params); err != nil {
		fmt.Printf("Error executing header template: %v\n", err)
		os.Exit(1)
	}

	// Parse the type template once
	typeTmpl, err := template.New("type").Parse(uuidTypeTemplate)
	if err != nil {
		fmt.Printf("Error parsing type template: %v\n", err)
		os.Exit(1)
	}

	// Write each type to the file
	for _, uuidType := range params.Types {
		if err := typeTmpl.Execute(file, uuidType); err != nil {
			fmt.Printf("Error executing type template for %s: %v\n", uuidType.TypeName, err)
			os.Exit(1)
		}
	}

	fmt.Printf("Generated %s with %d UUID types\n", outputFile, len(params.Types))
}

// Copyright 2025 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package main

import (
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"
)

// GenUUIDType represents metadata for generating UUID types in the context of
// file generation and testing.
type GenUUIDType struct {
	TypeName    string
	Description string
	Package     string
}

// GenHeaderParams represents metadata for generating the header of the
// generated file.
type GenHeaderParams struct {
	UUIDPackage string
}

// Template for the generated file header.
const genHeaderTemplate = `// Code generated by generate/uuidgen; DO NOT EDIT.
// Copyright 2025 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package testing

import (
	"github.com/juju/tc"

	"github.com/juju/juju/{{.UUIDPackage}}"
)
`

// Template for the generated file methods.
const genMethodTemplate = `

// Gen{{.TypeName}} can be used in testing for generating a {{.Description}} UUID
// that is checked for subsequent errors using the test suit's go check
// instance.
func Gen{{.TypeName}}(c *tc.C) {{.Package}}.{{.TypeName}} {
	id, err := {{.Package}}.New{{.TypeName}}()
	c.Assert(err, tc.ErrorIsNil)
	return id
}
`

// generateTestGenFile generates a test utility file for UUID types based on the
// provided parameters and writes it to disk.
// Arguments:
//   - outputFile: The path where the generated test file will be created.
//   - params: Contains the package information and a list of UUID types with
//     their names and descriptions.
func generateTestGenFile(outputFile string, params FileParams) {
	// Compute generated uuid package
	uuidPackage := findUUIDPackage()

	outputFile = path.Join(path.Dir(outputFile), "testing", path.Base(outputFile))
	// Create the output file
	file, err := os.Create(outputFile)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	// Write the file header
	headerTmpl, err := template.New("header").Parse(genHeaderTemplate)
	if err != nil {
		fmt.Printf("Error parsing header template: %v\n", err)
		os.Exit(1)
	}

	if err := headerTmpl.Execute(file, GenHeaderParams{UUIDPackage: uuidPackage}); err != nil {
		fmt.Printf("Error executing header template: %v\n", err)
		os.Exit(1)
	}

	// Parse the type template once
	typeTmpl, err := template.New("type").Parse(genMethodTemplate)
	if err != nil {
		fmt.Printf("Error parsing type template: %v\n", err)
		os.Exit(1)
	}

	// Write each type to the file
	for _, uuidType := range params.Types {
		if err := typeTmpl.Execute(file, GenUUIDType{
			TypeName:    uuidType.TypeName,
			Description: uuidType.Description,
			Package:     params.Package,
		}); err != nil {
			fmt.Printf("Error executing type template for %s: %v\n", uuidType.TypeName, err)
			os.Exit(1)
		}
	}

	fmt.Printf("Generated %s with %d UUID types\n", outputFile, len(params.Types))
}

// findUUIDPackage returns the name of the uuid package related to this helper.
func findUUIDPackage() string {

	fullPath, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	// Find the last occurrence of "/juju/"
	lastJujuIndex := strings.LastIndex(fullPath, "juju/")
	if lastJujuIndex == -1 {
		panic("unexpected file path (should be a subdirectory of a juju project): " + fullPath)
	}

	// Extract everything after the last "juju/"
	return fullPath[lastJujuIndex+5:] // +5 to skip "juju/"
}
